<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Sun, 12 Apr 2015 12:25:06 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>ソーシャル・ボタンの色</title>
      <link>http://hail2u.net/blog/webdesign/social-button-color.html</link>
      <description>ウェブサイトにソーシャル・ボタンを設置する際にその色はどうすると良いのかは悩みどころだ。効果的であることとビジュアル・デザインとの兼ね合いという二つの点から考えないとならないからだ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/social-button-color.html</guid>
      <pubDate>Sun, 12 Apr 2015 12:25:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="/images/blog/social-button-color.png"><img alt="Facebook/Tumblr/Twitter/Pinterest" src="/images/blog/social-button-color.png"></a>
</figure>

<p>ウェブサイトにソーシャル・ボタンを設置する際にその色はどうすると良いのかは悩みどころだ。効果的であることとビジュアル・デザインとの兼ね合いという二つの点から考えないとならないからだ。</p>

<h2>対応するソーシャル・ネットワークのテーマカラー</h2>

<p>もっとも認識されやすいのは対応するソーシャル・ネットワークを象徴する色でボタンを作成することだ。認識されやすさはその利用につながるので、マーケティングの面から重視するのならばこうすべきだろう。もちろん元々その色で作成されているであろう公式のウィジェットを使うのが望ましい。</p>

<h2>ウェブサイトのテーマカラー</h2>

<p>ソーシャル・ネットワークを象徴する色で作成する場合と比べて認識度では劣るが、コンテンツとの差異を確保した上で、何らかのアクションを起こすことのできるものだとは理解されやすい。リンクやナビゲーションとは差異をつけづらいので、それらとは大きさや形(他では使っていないシェイプにするなど)でより識別しやすくする必要がある。</p>

<h2>無彩色</h2>

<p>無彩色で作成されたボタンはどんなビジュアル・デザインにも馴染みやすい。<code>:hover</code>で色を変える工夫なども通用しなくなりつつあるので、何らかの形でアピールすることはまず無理だと意識しておく必要がある。つまりそれを越えて認識出来る人であるところの常連向けに置いておくという程度にしか役には立たないだろう。</p>

<hr>

<p>ソーシャル・ボタンの効果とビジュアル・デザインとの馴染みやすさは、ほぼ両立できない。インターネットというものがウェブサイト同士がつながって成り立っていることを考えると、それぞれの対応するソーシャル・ネットワークを象徴するカラーで作成した方が望ましいのではないかと思う。もしかすると無彩色で作り、それをアニメーションさせれば両立できるかもしれないが、かなりの挑戦になることだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>ボルディエ</title>
      <link>http://hail2u.net/blog/misc/bordier.html</link>
      <description>パリみやげのボルディエのバターをパンにつけて食べてる。まずは海藻入りのやつから。食べたことなかったのでわかめみたいな感じの味がしちゃうのかと思ったけど、塩気がちょっと特徴的という程度だった。ただこれがバターかみたいな感動があってすごかった。それが600円くらいで半ポンド以上買える(250gで4.5€)とかフランスすごい。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/bordier.html</guid>
      <pubDate>Sat, 11 Apr 2015 14:23:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="/images/blog/bordier-beurre-de-baratte-aux-algues.jpg"><img alt="ボルディエの海藻入りバター" src="/images/blog/bordier-beurre-de-baratte-aux-algues.jpg"></a>
</figure>

<p>パリみやげの<a href="http://www.lebeurrebordier.com/">ボルディエ</a>のバターをパンにつけて食べてる。まずは海藻入りのやつから。食べたことなかったのでわかめみたいな感じの味がしちゃうのかと思ったけど、塩気がちょっと特徴的という程度だった。ただこれがバターかみたいな感動があってすごかった。それが600円くらいで半ポンド以上買える(250gで4.5€)とかフランスすごい。</p>

<p>ボルディエの海藻バターはBS1かなんかのTV番組ですごい昔に見て、ブリキっぽい桶に入れた牛乳を古い木で出来たプロペラみたいなヘラを人力で回して作っていたような記憶がある。ぐるぐる回してバターを作るみたいなの発禁になった絵本で虎がバターになるのしか知らなかった。それ以来ずっと一度食べてみたいなーと思ってたけど、日本ではエシレ以上に扱いがない。怪しげな並行輸入くらいでしか見つからない気がした。新宿の伊勢丹とか銀座の松屋とかいけばあるのかな。</p>

<hr>

<p>エシレのバターもおみやげでもらった。成城石井とか丸井で50gの丸いやつが500円以上で売ってるけど、これも現地だと200円しないくらいだったとか。</p>

<p>バターの摂り過ぎで病気になっても悔いはない程度にどちらもうまい。</p>]]></content:encoded>
    </item>

    <item>
      <title>CSS MQPackerのCLI</title>
      <link>http://hail2u.net/blog/webdesign/css-mqpacker-cli.html</link>
      <description>CSS MQPackerのような簡単な変換ライブラリーは概ねPostCSSからやGruntからなどで利用することが想定されている。しかしGruntやgulpに絶望する人が増えた現在、そういった便利環境に縛られない形で実行する手段も用意する必要がありそうな気配がある。ので、追加し始めた。リリースまでにはもうちょっとかかりそう。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/css-mqpacker-cli.html</guid>
      <pubDate>Fri, 10 Apr 2015 13:34:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/hail2u/node-css-mqpacker">CSS MQPacker</a>のような簡単な変換ライブラリーは概ねPostCSSからやGruntからなどで利用することが想定されている。しかしGruntやgulpに絶望する人が増えた現在、そういった便利環境に縛られない形で実行する手段も用意する必要がありそうな気配がある。ので、追加し始めた。リリースまでにはもうちょっとかかりそう。</p>

<p>標準入力を読んで、変換し、標準出力に吐く。</p>

<pre><samp>$ <kbd>sass style.scss | mqpacker --sort --sourcemap - | csswring --sourcemap - style.min.css</kbd>
</pre>

<p>CSSWringと同じく、このような形でパイプすることを想定した簡単なものとして実装している。入力ファイル名で<code>-</code>を使うと標準入力を読むというだけのものだ。</p>

<p>パフォーマンスという問題はあるものの、npmが実行できる環境なら何も考えずに実行できる仕組みはあると助かることはなくはない。makeからも使えるとかそういう意味でも。パフォーマンスにおいては、実行時における依存パッケージの初期化コストや、パイプにもかかわらずソースマップを使うとファイルの読み書きも発生することなど問題を抱えるが、解決する問題と比べてトントンというところだろう。</p>

<hr>

<p>こういうパイプでつなぐぞプログラムの作法みたいなものがよくわかっていない。他にもビルド・ツールではよくあるケースの1対多や多対多みたいなソースとビルドの対応関係はどうすればよいのかよくわからなかったりする。こういった作法や定石みたいなものがある程度Node.js界隈でも共有されるようにならないと、<code>npm run-script</code>とメジャーなシェル・プログラムだけで何とかする世界は実現が難しいんじゃないかなと思っている。</p>

<p>この辺りの話は「我慢」というキーワードでもうちょっと書きたい。</p>]]></content:encoded>
    </item>

    <item>
      <title>左寄せvs.中央寄せ</title>
      <link>http://hail2u.net/blog/webdesign/left-aligned-vs-centering.html</link>
      <description>一時期は全てのウェブサイトが中央寄せになるのではないかというくらいの勢いだったような気がするが、最近は左寄せが盛り返しているようだ。AwwwardsやHTTPSTERなどのジャンルレスのウェブデザイン・ギャラリーを見るとなんとなくそう思う。正確に言うとレイアウトは中央寄せしつつ、テキストは左寄せしているウェブサイトが増えている。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/left-aligned-vs-centering.html</guid>
      <pubDate>Thu, 09 Apr 2015 15:09:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>一時期は全てのウェブサイトが中央寄せになるのではないかというくらいの勢いだったような気がするが、最近は左寄せが盛り返しているようだ。<a href="http://www.awwwards.com/">Awwwards</a>や<a href="http://httpster.net/">HTTPSTER</a>などのジャンルレスのウェブデザイン・ギャラリーを見るとなんとなくそう思う。正確に言うとレイアウトは中央寄せしつつ、テキストは左寄せしているウェブサイトが増えている。</p>

<p>レイアウトの中央寄せは、<a href="http://baymard.com/blog/line-length-readability">最適な一行の文字数</a>に限界があることを考えると採用せざるをえない。<a href="http://www.w3.org/TR/css3-multicol/">CSSでマルチカラム・レイアウト</a>が簡単に提供できる様になれば少し変わる可能性はあるが、縦スクロールとマルチカラム・レイアウトの相性は良くない。実装方法は色々変化していくことだろうが、レイアウトの中央寄せ自体はこのまま継続して行われていきそうだ。</p>

<p>テキストの左寄せが盛り返しつつあるのは、ウェブ・フォントの流行と共にタイポグラフィーへの傾倒が進んだことによる結果だろうか。CSSの実装が追いついていない現状では、俗に<a href="http://en.wikipedia.org/wiki/Typographic_alignment#Flush_left">flush left (またはragged right)</a>と呼ばれるような右がガタガタになっている状態になるという特徴がある。しかしそれも以下のような理由でプラスに働く。</p>

<ul>
<li>自然な形で余白を確保しやすい</li>
<li>矩形である画像や表などとの明確な差異をつけやすい</li>
<li>見出し等で良いアクセントになりうる(欧文タイポグラフィーのみ)</li>
</ul>

<p>余白とコントラストをどう作るかをタイポグラフィーという比較的低いレイヤーで解決しようとしていると言えるだろう。</p>

<p>日本語のウェブサイトでこまめに改行を入れて文章を書くスタイルがいまだマジョリティーを保っている理由はいくつかありそうだが、そのひとつに文字の密度が下がることはある。欧文と比べて文字の密度そのものが高いため、文章単位で密度を下げようとすると、文字間や行間を空けるか、こまめに改行するかくらいしか対処する方法がない。これもまたタイポグラフィーというレイヤーでの工夫であるのかもしれない。</p>

<p>今ひとつ受け入れがたいスタイルだが、それなりに意味と効果があると感じるようになった。</p>]]></content:encoded>
    </item>

    <item>
      <title>Hanes Japan Fit (2015)</title>
      <link>http://hail2u.net/blog/gadget/hanes-japan-fit-h5110.html</link>
      <description>ヘインズのJapan Fitが今年の春夏モデル(H5110とパッケージのシールに印字されている)から少し変わったみたい。前のものも悪くはなかったのでもう一回、今度はUrban Researchのものを買った。</description>
      <category>Gadget</category>
      <guid isPermaLink="true">http://hail2u.net/blog/gadget/hanes-japan-fit-h5110.html</guid>
      <pubDate>Wed, 08 Apr 2015 00:44:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="http://www.amazon.co.jp/gp/product/B00RF2Z8LM/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00RF2Z8LM&amp;linkCode=as2&amp;tag=hail2unet-22">ヘインズのJapan Fit</a>が今年の春夏モデル(H5110とパッケージのシールに印字されている)から少し変わったみたい。前のものも悪くはなかったのでもう一回、今度は<a href="http://www.urban-research.jp/item/9010001/H5110UR/">Urban Researchのもの</a>を買った。</p>

<p>サイズは前と同じ。着丈もそのままだったのがちょっと残念。柔らかさはそのままで、ほんのちょっと厚くなった気がする。着慣れちゃったし、このマイナー・チェンジで微妙に評価が上がって、安定して出るんなら一生これで諦められるかなという感じにはなってきた。</p>

<p>相当しっかりした印象あるけど、でもまだ一枚で着るのは無理かなという感じ。柔らかいのはやはり相当きれいな状態じゃないと肌着っぽく見える。丸胴なのでアイロンをかけるというわけにもいかないし。開封直後の一回だけは着ても許されそう。</p>

<hr>

<figure>
  <a href="/images/blog/hanes-premium-japan-fit.jpg"><img alt="ヘインズプレミアムジャパンフィットは茶筒型のパッケージに1着ずつ詰められている" src="/images/blog/hanes-premium-japan-fit.jpg"></a>

  <figcaption>Hanes Premium Japan Fit Package</figcaption>
</figure>

<p>今年からちょっとだけ高いプレミアム・ライン(Made in Japanのやつ)の方でもJapan Fitが出てるみたい(もっと高い奴もあるっぽい)。入っているのは1着だけなようなのでかなり高い。ここらへんで売ってない……。卒業証書入れみたいなパッケージの筒だけ欲しい。ああいう丸いスポンと抜ける筒、すごい好き。茶筒と言えば良いのかな。人類の英知が詰まっている気がする。</p>]]></content:encoded>
    </item>

    <item>
      <title>CSSにおける単位</title>
      <link>http://hail2u.net/blog/webdesign/css-units.html</link>
      <description>CSSの単位はそれぞれに意味があり、それぞれに合った使い方があるはずだ。R.I.P. REM, Viva CSS Reference Pixel!という記事を読んで強くそう思った。ブラウザーの実装がpx指定でもうまく機能するように寄ったのは確かだが、それはつまりpx単位を使いたいところではpx単位を使えるようになったということに過ぎない。同時にemやrem単位を使いたいところではそれらを使えるということだ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/css-units.html</guid>
      <pubDate>Tue, 07 Apr 2015 00:50:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>CSSの単位はそれぞれに意味があり、それぞれに合った使い方があるはずだ。<a href="https://mindtheshift.wordpress.com/2015/04/02/r-i-p-rem-viva-css-reference-pixel/">R.I.P. REM, Viva CSS Reference Pixel!</a>という記事を読んで強くそう思った。ブラウザーの実装が<code>px</code>指定でもうまく機能するように寄ったのは確かだが、それはつまり<code>px</code>単位を使いたいところでは<code>px</code>単位を使えるようになったということに過ぎない。同時に<code>em</code>や<code>rem</code>単位を使いたいところではそれらを使えるということだ。</p>

<p>使用する単位の統一は一貫性をもたらすように思えるが、それはコード上においてのみだろう。ある要素がどのような大きさで表示されるべきかは、コードではなく仕様で決定される。仕様はある程度までは絶対的な単位での設計されていくが、インターネットが様々な機器とソフトウェアで閲覧される現在、相対的な単位の出番は自然と多くなる。そこを無理に統一しようとすると、当然ひずみができやすくなるだろう。</p>

<p><code>px</code>単位に対して<code>rem</code>単位の優位性、またはその逆を論じるのは無意味とは言わないが、その差異を根拠にどちらかに統一するというのは現実的ではない。その上、将来的にも不安が残る。単位が必要になるそれぞれの場所で適切な単位を取捨選択することが可能になりつつあるので、なるべくそうしつつ、バグに対してのみ安全な単位で対処してやるというのが妥当ではないだろうか。</p>]]></content:encoded>
    </item>

    <item>
      <title>Modularized Normalize.scss v3.0.3</title>
      <link>http://hail2u.net/blog/webdesign/modularized-normalize-scss-v3.0.3.html</link>
      <description>Normalize.cssのv3.0.3がリリースされたようなので、Modularized Normalize.scssも追随させた。主な変更点は現在のFirefox ESRであるv31を最低ラインに変更したことによるベンダー拡張プリフィックスの整理くらいか。多少npmから扱いやすくなってもいる。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/modularized-normalize-scss-v3.0.3.html</guid>
      <pubDate>Mon, 06 Apr 2015 14:19:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/necolas/normalize.css/releases/tag/3.0.3">Normalize.cssのv3.0.3</a>がリリースされたようなので、<a href="https://github.com/hail2u/normalize.scss/releases/tag/v3.0.3">Modularized Normalize.scss</a>も追随させた。主な変更点は現在のFirefox ESRであるv31を最低ラインに変更したことによるベンダー拡張プリフィックスの整理くらいか。多少npmから扱いやすくなってもいる。</p>

<p>まだGitHub Pagesの方が更新されていないためテストは通らないが、手元では通せたので大丈夫なはずだ。</p>

<hr>

<p>Normalize.cssはそろそろその役目を終えているような空気と合意がある。それはとても良いことであるのだけど、それと同時にリセットCSSの復権だ的な意見があるのはちょっと悲しい。<q><a href="http://t32k.me/mol/log/wisteria/">真っ白なキャンバス</a></q>という表現と意味はわからないこともないけど、それはjQueryのような危険性を内包するもので、ポリフィル(もどき)として作られ更新されているNormalize.cssの良さはまた別のところ、つまりそれへの依存を徐々に減らすことができることにあると思う。</p>

<pre><code>h1 {
  font-weight: normal;
}

...

.title {
  font-weight: bold;
}
</code></pre>

<p>僕はこういったリセットしたものを戻す作業が無駄としか思えなくて、あるものはそのまま利用すれば良いし、そうでないのなら文脈に従って変更していきたい。</p>

<p>Normalize.cssが役目を終えつつあるということは、つまりブラウザー(に類するもの)でHTMLがどのように表示されるかが安定し始めたとうことであって、覚えることはもうほとんどなくなったということだと思う。そういったブラウザーのCSSの扱いを覚えることというのは、ブラウザーが実装したウェブ標準のインターフェイスの利用方法を覚えることと同じはずだ。それならばリセットするより少しづつ不要なノーマリゼーションを削除していき、最終的には依存なしで普通に書けるようになることを目指すのが良い。</p>

<hr>

<p>Modularized Normalize.scssはそういう用途で使うためのプラッガブルなポリフィルとして考えて、作り、使っている。</p>]]></content:encoded>
    </item>

    <item>
      <title>CSS Font LoadingとFont Face Observer、Web Font Loader</title>
      <link>http://hail2u.net/blog/webdesign/css-font-loading-font-face-observer-and-web-font-loader.html</link>
      <description>ウェブ標準であるCSS Font Loadingが気軽に使えるようになるにはまだまだ時間がかかりそうだ。そのポリフィルであるFont Loaderは動作が不安定かつ開発が止まっており信用できない。代替技術としてはポリフィルと同じ開発者が積極的にコミットしているFont Face Observerと、広く使われているWeb Font Loaderがある。同じフォントの読み込みを検知する場合、この三者ではどのようにコードが変わってくるのだろうか。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/css-font-loading-font-face-observer-and-web-font-loader.html</guid>
      <pubDate>Sun, 05 Apr 2015 14:47:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>ウェブ標準である<a href="http://www.w3.org/TR/css-font-loading/">CSS Font Loading</a>が気軽に使えるようになるにはまだまだ時間がかかりそうだ。そのポリフィルである<a href="https://github.com/bramstein/fontloader">Font Loader</a>は動作が不安定かつ開発が止まっており信用できない。代替技術としてはポリフィルと同じ開発者が積極的にコミットしている<a href="https://github.com/bramstein/fontfaceobserver">Font Face Observer</a>と、広く使われている<a href="https://github.com/typekit/webfontloader">Web Font Loader</a>がある。同じフォントの読み込みを検知する場合、この三者ではどのようにコードが変わってくるのだろうか。</p>

<p>以下のコード例では、自前でホスティングしている<a href="http://en.wikipedia.org/wiki/Open_Sans">Open Sans</a>の読み込みが完了・失敗したら<code>body</code>要素にクラスを振るという単純なケースを書き分ける。</p>

<h2>CSS Font Loading</h2>

<p>CSS Font Loading仕様はPromiseによる実装で、読み込み待ちはPromiseで解決することになる。</p>

<pre><code>new FontFace(
  &#39;Open Sans&#39;,
  &#39;<mark>url(/assets/font/open-sans/r.woff)</mark>&#39;
).load().then(function (fontface) {
  <mark>document.fonts.add(fontface);</mark>
  document.body.className += &#39; loaded&#39;;
}, function (reason) {
  document.body.className += &#39; failed&#39;;
  throw new Error(reason);
});
</code></pre>

<p>気をつけるのはウェブ・フォントのURLを<code>url()</code>でくくる必要があること、そして読み込み成功時に<code>add()</code>することくらいだろう。Promiseなので、読み込み失敗は<code>then()</code>の第二引数に指定した関数で処理すれば良い。</p>

<h2>Font Face Observer</h2>

<p>Font Face Observerはウェブ標準と同じくPromiseによる実装のためウェブ標準と置換えがしやすい……と思いきや、ウェブ・フォントを読み込む機能自体は持っていない。そのためウェブ・フォントCSSを自前で読み込み、そのウェブ・フォントが利用可能になったかどうかをもって読み込み完了が決定される。</p>

<pre><code><mark>var cssFont = document.createElement(&#39;link&#39;);
cssFont.href = &#39;/assets/css/open-sans.css&#39;;
cssFont.rel = &#39;stylesheet&#39;;
document.head.appendChild(cssFont);</mark>
new FontFaceObserver(
  &#39;<mark>Open Sans</mark>&#39;,
  {}
).check().then(function () {
  document.body.className += &#39; loaded&#39;;
}, function (reason) {
  document.body.className += &#39; failed&#39;;
  throw new Error(reason);
});
</code></pre>

<p>気をつけるのは<code>FontFaceObserver</code>コンストラクターへ渡す第一引数の値と読み込むウェブ・フォントCSSでの<code>font-family</code>の値が一致していることだ。こちらもPromiseのため第二引数に指定した関数で読み込み失敗を処理できる。ただし読み込みする機能自体を持っておらずイベント監視(スクロールイベントで監視しているので軽量)のため、デフォルトの3秒、または<code>check()</code>の第二引数で指定したミリ秒数のタイムアウトでも読み込み失敗になる。</p>

<h2>Web Font Loader</h2>

<p>使っている人はおなじみだろうがWeb Font LoaderはPromiseによる実装ではない。ウェブ標準とはコードが大きく異る。</p>

<pre><code>WebFont.load({
  custom: {
    families: [&#39;Open Sans&#39;],
    <mark>urls: [&#39;/assets/css/open-sans.css&#39;]</mark>
  },
  <mark>fontactive</mark>: function () {
    document.body.className += &#39; loaded&#39;;
  },
  <mark>fontinactive</mark>: function (family) {
    document.body.className += &#39; failed&#39;;
    throw new Error(&#39;Web font &quot;&#39; + family + &#39;&quot; not loaded.&#39;);
  }
});
</code></pre>

<p>このようにライブラリーが用意する<code>WebFont</code>オブジェクトの<code>load()</code>メソッドですべて指定することになる。自前で用意したウェブ・フォントを使いたい場合は<code>custom</code>フィールドで<code>families</code>と<code>urls</code>を指定することで読み込みを行う。Font Face Observerとは違うウェブ・フォントの読み込み機能自体は半分(ウェブ・フォントCSSの読み込みだけ)内蔵されているということだ。読み込みエラーは<code>fontinactive</code>フィールドで指定した関数で処理できる。こちらもタイムアウト(デフォルトでは5秒)でもエラーになる。</p>

<hr>

<p>コード量の面でもPromiseで書くことができるという面でもウェブ標準での実装が優秀だが、ほぼChrome以外で使えないないものは使えない上、ポリフィルは本当に信用ができない。Font Face ObserverはPromiseによる実装で良さそうに見えるが、少し前のリリース(v1.4.1)では何度も呼ぶとかなりの確率で読み込みに成功しても(フォント・ファイル自体は正常に読み込まれている)失敗の方の関数が呼ばれることが高確率で起こっていた。</p>

<p>結局のところ、まだまだWeb Font Loaderで安定ということになると思う。Font Face Observerは悪くはないけれども、ポリフィルでないのなら安定のWeb Font Loaderの方がマシだろう。軽量という点はすこし魅力的だが、多くの場合はウェブページごとに一回呼ぶだけだろうと思われるので、それほど魅力的なファクターではない。</p>

<p>僕は今のところはWeb Font Loaderを使いつつ、常にウェブ標準での置換えを意識しておくという書き方をしている。Font Face Observerは使う利点を見出すことができなかった。</p>]]></content:encoded>
    </item>

    <item>
      <title>餃子</title>
      <link>http://hail2u.net/blog/misc/gyouza.html</link>
      <description>無心になって野菜を刻み、無心になって豚ひき肉と混ぜ、無心になって餃子の皮で包むと、あとは焼くか茹でると餃子になる。あんまり考えずに無心に作れるので好き。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/gyouza.html</guid>
      <pubDate>Sat, 04 Apr 2015 18:54:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>無心になって野菜を刻み、無心になって豚ひき肉と混ぜ、無心になって餃子の皮で包むと、あとは焼くか茹でると餃子になる。あんまり考えずに無心に作れるので好き。</p>

<p>ずっと焼き色を付けてから水を入れて蒸し焼きにしてたんだけど、蒸し焼きにしてからあとで油を回し入れて焼き色を付けるみたいなやり方もあるのか。そちらの方が羽根みたいなのを付ける場合は簡単らしい。羽根好きじゃないのでつけようとも考えたことないけど。一旦普通に茹でて、最後に焼き色付けるというやり方は今度やってみよう。</p>

<p>餃子の最大の問題は、無心で作って包むところまで終わると満足してしまって、それほど食べる気起きなくなるところ。</p>]]></content:encoded>
    </item>

    <item>
      <title>Do Note</title>
      <link>http://hail2u.net/blog/software/do-note.html</link>
      <description>Do Noteを使い始めた。IFTTTの出した何か書いたら何かするだけのアプリ。今のところリマインダーへの登録、ツイート、そしてDropboxへメモの保存にしている。3つまでしかレシピを作れないという制限は心地良い不自由さかなと感じる。ひいき目だけど。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/do-note.html</guid>
      <pubDate>Fri, 03 Apr 2015 16:11:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://ifttt.com/products/do/note">Do Note</a>を使い始めた。IFTTTの出した何か書いたら何かするだけのアプリ。今のところリマインダーへの登録、ツイート、そしてDropboxへメモの保存にしている。3つまでしかレシピを作れないという制限は心地良い不自由さかなと感じる。ひいき目だけど。</p>

<p>リマインダーのようなタスク・リストへの登録は意外に手間がかかることがある。アプリの起動、リストの選択、タスクの入力だけだが、大抵は既定のリストにシュッと登録したいだけなのにそうはいかなかったりする。Inbox by Googleのリマインダー登録みたいなのが完成形なのかなという感じはするけど、できる限りメール以外をGoogleに任せないようにしているので、僕は使えない。</p>

<p>Do Noteでは起動すると前回使ったレシピでのメモ画面になる。のでアプリ起動から即既定のリストへのリマインダー登録が行える。他のレシピを使った後に必ずリマインダーのレシピに戻すことを忘れなければ常にこの状態を維持できる。</p>

<p>ツイートはなんといってもタイムラインが目に入らないのが良い。僕はまずURLとかを投げることはないので、これで十分かなと感じる。タイムラインは色々楽しいのだけど、やっぱり楽しいだけじゃない。タイムラインに張り付くのは気が向いた時だけみたいなのが性に合っているみたい。</p>

<p>最後は普通のメモ。主にブログのたたき台やアイディアのメモ、書かなきゃ行けなそうなコードの断片などをとりあえずDropboxに放り込んでおくだけのレシピ。Evernoteをオススメしてくれた人もいたけど、Evernoteの🐘がとにかく好きになれない。ユーザー層もあまり好きではない。そもそもそんなにメモが氾濫しない。通常は紙のメモパッドにペンで書いてる。とかでDo Noteに落ち着いた。でも<a href="http://www.squarespace.com/apps/#note">@ykskのオススメしてくれたSquarespace Note</a>にはちょっとグラついてる。</p>

<p>でも過去のメモの管理は今のところ必要としていないので、Do NoteでDropboxにとりあえず投げておくという形でお手軽にやっている。更新したくなったり、そこそこちゃんと書きたくなったらDropboxと連携できるMarkdownエディターである<a href="http://writeboxapps.com/">Writebox</a>のウェブ版でやるということに。もちろんPCの前に座ってたらVimやFocusWriteを使っているけど。Writeboxは分割プレビューやインライン・プレビューみたいな<del>ゴミみたい</del><ins>便利</ins>な機能がなくて非常に好き。</p>

<hr>

<p>IFTTTに支配されつつあり、ダメな感じがしてきた。所詮定型作業の自動化だと思っているので、無くなったら死ぬとかはないと思うけど、ちょっと良くない傾向だ。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
