<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja-JP"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja-JP</language>
    <copyright>Copyright &#x00a9; 2002-2014, Kyo Nagashima</copyright>
    <managingEditor>kyo@hail2u.net (Kyo Nagashima)</managingEditor>
    <webMaster>kyo@hail2u.net (Kyo Nagashima)</webMaster>
    <lastBuildDate>Wed, 26 Nov 2014 07:07:07 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="http://hail2u.net/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>ナイン・ストーリーズ</title>
      <link>http://hail2u.net/blog/media/nine-stories.html</link>
      <description>読もうと思ったらなかったのでナイン・ストーリーズを買って読んでた。3回目くらいの新潮文庫版。いつ読んでもすっきりしなくて、難解な小説を読んだ的な満腹感があって楽しい。</description>
      <author>kyo@hail2u.net (Kyo Nagashima)</author>
      <category>Media</category>
      <guid isPermaLink="true">http://hail2u.net/blog/media/nine-stories.html</guid>
      <pubDate>Wed, 26 Nov 2014 07:06:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="http://www.amazon.co.jp/gp/product/4102057013/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4102057013&amp;linkCode=as2&amp;tag=hail2unet-22"><img src="http://ecx.images-amazon.com/images/I/416EBEXR8PL.jpg" alt="ナイン・ストーリーズ (新潮文庫): サリンジャー, 野崎 孝: 本"></a>
</figure>

<p>読もうと思ったらなかったので<a href="http://www.amazon.co.jp/gp/product/4102057013/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4102057013&amp;linkCode=as2&amp;tag=hail2unet-22">ナイン・ストーリーズ</a>を買って読んでた。3回目くらいの新潮文庫版。いつ読んでもすっきりしなくて、難解な小説を読んだ的な満腹感があって楽しい。</p>

<p>サリンジャーはたまに(3年に一度くらい)読むんだけど、いつも読まなきゃ良かったとか思う。読む度に印象と感想が変わっていくので、そういう意味では面白いし好きなんだけど、どんどん愛せなくなってくる。なので次に読むまで間があく→また印象が変わる→間があくと悪循環している。</p>

<p>これをあと2周くらいすると最初期のハマった心持ちに戻れるような気がしていて、また3年後くらいに読むんじゃないかと思う。</p>

<hr>

<p>そのまま流れでアッシュ・リンクスのお話の方を読んでて、時間がいくらあっても足りない。</p>]]></content:encoded>
    </item>

    <item>
      <title>CSSWringとCSS MQPackerのv2.0.0をリリース</title>
      <link>http://hail2u.net/blog/webdesign/csswring-and-css-mqpacker-v2.0.0.html</link>
      <description>CSSWringとCSS MQPackerをPostCSS v3に更新したものをリリースした。どのバージョンを上げるか迷ったが、メジャー・バージョンアップして気持ち悪いのは自分だけなので、ユーザーに混乱を与えないようにメジャー・バージョンを上げることにした。</description>
      <author>kyo@hail2u.net (Kyo Nagashima)</author>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/csswring-and-css-mqpacker-v2.0.0.html</guid>
      <pubDate>Tue, 25 Nov 2014 09:12:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/hail2u/node-csswring">CSSWring</a>と<a href="https://github.com/hail2u/node-css-mqpacker">CSS MQPacker</a>をPostCSS v3に更新したものをリリースした。<a href="http://hail2u.net/blog/software/major-update-of-dependencies.html">どのバージョンを上げるか</a>迷ったが、メジャー・バージョンアップして気持ち悪いのは自分だけなので、ユーザーに混乱を与えないようにメジャー・バージョンを上げることにした。</p>

<p>PostCSSにそのまま渡されるオプションのうち<code>map</code>キーのデフォルト値が変わったことが互換性のない変更ということになる。今まで通りソース・マップ・ファイルを外部に吐き、元ソースを含めない場合は以下のように設定してやる必要がある。</p>

<pre><code>var csswring = require(&#39;csswring&#39;);

var result = csswring.wring(css, {
  map: {
    inline: false,
    sourcesContent: false
  },
  from: &#39;from.css&#39;,
  to: &#39;to.css&#39;
});
</code></pre>

<p>つまりインラインにソース・マップを埋め込む<code>inline</code>オプションと、元ソースをソース・マップに含める<code>sourcesContent</code>オプションが<code>false</code>から<code>true</code>に変更になったので、それぞれを無効にしてやる必要があるということだ。単純にインラインで元ソース付きのソース・マップでも構わないのなら、<code>map</code>オプションを<code>true</code>にするだけで良い。</p>

<pre><code>var csswring = require(&#39;csswring&#39;);

var result = csswring.wring(css, {
  map: true
});
</code></pre>

<p>この場合はインラインで全て解決するので、<code>from</code>や<code>to</code>オプションも不要になる。</p>

<hr>

<p>インラインをデフォルトにした理由はちょっと良くわかっていない。インラインの方がパス解決などの点で都合が良いことが多く、開発現場では使いやすいからなのではないかと想像している。今までのように<code>map: true</code>だと出力するCSSが肥大化する(3倍超)ので、開発とリリースそれぞれのビルドにおいてオプションを変えて生成するように気を付ける必要があるだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>ファビコンでData URIは使えるか</title>
      <link>http://hail2u.net/blog/webdesign/data-uri-for-a-favicon.html</link>
      <description>ちょっとした理由があって、外部リソースにまったく依存しないページを作る必要があった。大抵のもののインライン化については知識があったのだけど、ファビコンをData URIでインライン化できるかはよく知らなかったため簡単なテスト・ページを作って調べてみたが、ChromeやFirefoxでは大丈夫なようだった。</description>
      <author>kyo@hail2u.net (Kyo Nagashima)</author>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/data-uri-for-a-favicon.html</guid>
      <pubDate>Mon, 24 Nov 2014 05:53:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>ちょっとした理由があって、外部リソースにまったく依存しないページを作る必要があった。大抵のもののインライン化については知識があったのだけど、ファビコンをData URIでインライン化できるかはよく知らなかったため簡単なテスト・ページを作って調べてみたが、ChromeやFirefoxでは大丈夫なようだった。</p>

<p>View Demo: <a href="http://hail2u.net/pub/test/602.html">Data URI Favicon</a></p>

<p>単色の緑の四角がファビコンとして表示されれば対応していることになる。表の通り、Chrome 39やFirefox 33では問題なく表示された。対してInternet Explorer 11 (及び12)ではうまく読めなかった。ファビコンの参照は<code>link</code>要素で行うため、読める方が好ましいはずだ。Internet Explorerの実装が行き届いていないと言って良い。</p>

<p>簡単に回避する手段もなさそうなので、ファビコンをインライン化するのは難しいと結論づけた。</p>

<hr>

<p>ファビコンをもインライン化したい理由は、HTTPリクエストを0にすることに加えて同じドメイン配下のページとは違うファビコンにするという要件があったことだった。多くのブラウザーではファビコンが設定されていない場合にルートの<code>favicon.ico</code>を見に行くという仕様になっているので、どうにかして別のファビコンを設定しなければならなかった。この仕様には悩ませられることがままある。もちろん<code>apple-touch-icon.png</code>とかでも。</p>

<p>決め打ちで何かされたりしないストイックなブラウザーが良いな。</p>]]></content:encoded>
    </item>

    <item>
      <title>大きすぎるヒーロー・イメージ</title>
      <link>http://hail2u.net/blog/webdesign/too-big.html</link>
      <description>Your hero image is too big and here’s why it worksという記事を読んだ。ヒーロー・イメージとはアイキャッチ画像のことと言っても良い。初見では少し誤読したが、どうもヒーロー・イメージによりユーザーの目的達成をサポートできると主張したいようだ。</description>
      <author>kyo@hail2u.net (Kyo Nagashima)</author>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/too-big.html</guid>
      <pubDate>Sun, 23 Nov 2014 04:38:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="http://metropoly.co.uk/blog/your-hero-image-is-too-big/">Your hero image is too big and here’s why it works</a>という記事を読んだ。ヒーロー・イメージとはアイキャッチ画像のことと言っても良い。初見では少し誤読したが、どうも<em>ヒーロー・イメージによりユーザーの目的達成をサポートできる</em>と主張したいようだ。</p>

<p>例として自身で作成したウェブサイトでヒーロー・イメージに主要なコンテンツへリンクしているボタンを重ねたものと新聞の一面の話を取り上げている。単に大きい画像で目を惹くのではなく、画像の大きさとコンテンツの重要度に関連性を持たせ、情報を整理・提示してやろうということのようだ。</p>

<p>でも、クライアントに「ヒーロー・セクションが画面を専有しすぎているんじゃないか？」と言われた時点で失敗しているような気がしないでもない。また、この記事自体のヒーロー・イメージが機能しておらず説得力に欠ける。</p>

<hr>

<p>画像の大きさや画面専有度を、その重要性に合わせて多様なデバイスで調整するのは至難だ。例えば横長のディスプレイと縦長のディスプレイでは専有度を同じにしようとすると、ずいぶんと違う大きさの画像を使わないとならないだろう。更に重ねる文字やボタンの大きさのことを考えると、ヒーロー・イメージの一貫性を多様なデバイスで提供することは簡単にはいかない。</p>

<p>こういった点でヒーロー・イメージはその見た目に反してレスポンシブ・デザインと相性が良くないという思いを強くした。</p>]]></content:encoded>
    </item>

    <item>
      <title>おそうじ浴槽</title>
      <link>http://hail2u.net/blog/gadget/osouji-yokusou.html</link>
      <description>新しい風呂はノーリツの快適オプションのひとつのおそうじ浴槽機能付きのものになった。風呂場の外に設置されたリモコンのボタンを押すだけで15分くらいで浴槽がまずまずきれいに洗われる。ゴボゴボゴボブシャージャバジャバゴボゴボゴボゴボ。やることは毎日ボタンを押すのとたまにバスマジックリンを補充するだけ。</description>
      <author>kyo@hail2u.net (Kyo Nagashima)</author>
      <category>Gadget</category>
      <guid isPermaLink="true">http://hail2u.net/blog/gadget/osouji-yokusou.html</guid>
      <pubDate>Sat, 22 Nov 2014 03:11:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>新しい風呂は<a href="http://www.noritz.co.jp/product/bathroom/point">ノーリツの快適オプションのひとつのおそうじ浴槽</a>機能付きのものになった。風呂場の外に設置されたリモコンのボタンを押すだけで15分くらいで浴槽がまずまずきれいに洗われる。ゴボゴボゴボブシャージャバジャバゴボゴボゴボゴボ。やることは毎日ボタンを押すのとたまに<a href="http://www.amazon.co.jp/gp/product/B000TGKHPI/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B000TGKHPI&amp;linkCode=as2&amp;tag=hail2unet-22">バスマジックリン</a>を補充するだけ。</p>

<p>自動で何かやってくれる家電としては玄関照明やウォシュレットの類い(便器の自動洗浄)・ロボット掃除機・食洗機など、量販店で売っている単体のものが主で、それらは満足のいくもの。ただそういったものだけではなく、ビルトインの大型のものが、またはビルトインのものしか存在しないものもある。それらはリスクも大きいが見返りもかなり大きい。</p>

<p>システムキッチンのビルトイン食洗機はもちろんだけど、クリナップの<a href="http://cleanup.jp/kitchen/cleanlady/cl_ragehood.shtml">洗エールレンジフード</a>とかもかなりすごい。月に一回お湯をセットしてボタンを押すだけで換気扇の掃除が終わる(10分くらい)。自動化家電は単体のものの方が良い面(コストとリスクとメリットのバランス)も多いけど、そういった選択肢が用意されないおそうじ浴槽や洗エールレンジフードのようなものはとても魅力的。特にリフォームやマンションの選択においては。</p>

<p>自動化家電楽しいな。</p>]]></content:encoded>
    </item>

    <item>
      <title>Handlebars.js v2.0.0における出力の変化</title>
      <link>http://hail2u.net/blog/coding/output-changes-on-handlebarsjs-v2.0.0.html</link>
      <description>Handlebars.jsのv2.0.0が9月に出ていたようだ。今更気付いたので更新してみたら、出力が少し変わっていた。改行や空白の扱いがMustacheのspec通りになったということらしい。パーシャルで親テンプレートのインデントが継承されたり、改行が二重にならなくなったりと、おおよそ直感的な出力に変わったと言えそう。</description>
      <author>kyo@hail2u.net (Kyo Nagashima)</author>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/output-changes-on-handlebarsjs-v2.0.0.html</guid>
      <pubDate>Fri, 21 Nov 2014 01:44:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/wycats/handlebars.js/releases/tag/v2.0.0">Handlebars.jsのv2.0.0</a>が9月に出ていたようだ。今更気付いたので更新してみたら、出力が少し変わっていた。改行や空白の扱いが<a href="https://github.com/mustache/spec">Mustacheのspec</a>通りになったということらしい。パーシャルで親テンプレートのインデントが継承されたり、改行が二重にならなくなったりと、おおよそ直感的な出力に変わったと言えそう。</p>

<p>例えば、以下のようなパーシャルを呼ぶテンプレートがあるとする。</p>

<pre><code>&lt;header&gt;
  {{&gt; navigation}}
&lt;/header&gt;
</code></pre>

<p>navigationパーシャルは以下のようなもので、インデントなし・最後に改行ありという普通に書いたものとする。</p>

<pre><code>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/features&quot;&gt;Features&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/pricing&quot;&gt;Pricing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/support&quot;&gt;Support&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>旧バージョンでは以下のように出力されていた。インデントが無視され、最後の改行が重なる。</p>

<pre><code>&lt;header&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/features&quot;&gt;Features&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/pricing&quot;&gt;Pricing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/support&quot;&gt;Support&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/header&gt;
</code></pre>

<p><code>{{&gt; navigation}}</code>が書いてあったところにただそのまま流し込んだだけと言って良い。対してv2.0.0では以下のようにインデントが継承され、最後の改行が重ならないようになる。</p>

<pre><code>&lt;header&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/features&quot;&gt;Features&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/pricing&quot;&gt;Pricing&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/support&quot;&gt;Support&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/header&gt;
</code></pre>

<p>きれい。この辺りのことはMustacheのspecできちんと定義されてるので、Handlebars.jsが正しく処理するようになったと考えて良さそう。</p>

<hr>

<p>自前のHTML生成スクリプトでアドホックにパーシャルの最後の改行を消してたとこを削除できたので、すこぶる気分が良い。</p>]]></content:encoded>
    </item>

    <item>
      <title>Markdownの参照形式によるリンク</title>
      <link>http://hail2u.net/blog/coding/markdown-reference-style-links.html</link>
      <description>Markdownでリンクを作成する方法には2種類ある。インラインで記述する方法が最もよく使われており、必ずHTMLに変換するということならばこれだけで十分とも言える。もう一つの参照形式で記述する方法はほとんど使われていないが、Markdown文書をテキストとして読む場合に、ともすれば長くなりがちなURLが本文に挟まらないので格段に読みやすさが向上する。</description>
      <author>kyo@hail2u.net (Kyo Nagashima)</author>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/markdown-reference-style-links.html</guid>
      <pubDate>Thu, 20 Nov 2014 03:38:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="http://daringfireball.net/projects/markdown/syntax#link">Markdownでリンクを作成する方法</a>には2種類ある。インラインで記述する方法が最もよく使われており、必ずHTMLに変換するということならばこれだけで十分とも言える。もう一つの参照形式で記述する方法はほとんど使われていないが、Markdown文書をテキストとして読む場合に、ともすれば長くなりがちなURLが本文に挟まらないので格段に読みやすさが向上する。</p>

<pre><code>This is <mark>[an example reference-style link][1]</mark>.

<mark>[1]: http://example.com/</mark>
</code></pre>

<p>参照形式ではこのような形でリンクを作成する。本文では<code>[link text][id]</code>という形で書き、文書の最後に<code>[id]: URL</code>という形で書くわけだ。ちょうど脚注のような形になる。<code>[id]: URL</code>は任意の場所に書くことができるが、読みやすさと書きやすさの両面から最後にまとめて書いた方が良いだろう。</p>

<p>この<code>id</code>は省略できるので以下のようにして作成することもできる。</p>

<pre><code>This is [an example reference-style link]<mark>[]</mark>.

<mark>[an example reference-style link]</mark>: http://example.com/
</code></pre>

<p>実はこの空の<code>[]</code>も省略できるので以下のようにしてもまた作成することができる。</p>

<pre><code>This is <mark>[an example reference-style link]</mark>.

[an example reference-style link]: http://example.com/
</code></pre>

<p>この<code>[]</code>の省略についてはドキュメントでは触れられていないが、オリジナルのMarkdown実装及び多くの派生実装でも動作する。本文がよりすっきりすることと、リンクの対応が明確なことがこの書き方の利点だと言える。しかし同じ文字列を繰り返して書くことになるので、決して効率的であるとは言えない。</p>

<p>数字のIDを使う書き方は脚注として見やすく効率的なのに対して、<code>[]</code>を省略した書き方は連番を管理する必要がないためメンテナンス性が高い。どちらでも良いが統一はした方が良いだろう。</p>

<hr>

<p>ウェブログの記事のようにほぼ簡易HTML記法としてMarkdownを使うだけの場合はインラインで書いても問題になることはない。しかし一文や段落の長さといった文章の体裁にも気を使いたい場合、インラインで書かれたURLは大きくその作業を阻害する。参照形式によるリンクを利用するとより自然に文章を添削することが可能になるだろう。</p>

<p>またプロジェクトのREADMEなど、Markdown文書がそのままテキストととして読まれることも多い場合にも威力を発揮する。紙の文書で欄外の注を読むような感覚でリンクを読むことができるだろう。編集する側としても脚注のような形で最後に参考リンクのリストのようなものをまとめておけることは利点が多いはずだ。</p>

<p>他に80文字で改行を入れる記述ルールとの相性の良さも見逃せない。インラインの場合には80文字で改行するのはとても難しくなるが、参照形式ならほぼ問題になることはない。</p>

<hr>

<p>あまり使われていない参照形式によるリンクだが、こちらを使うことにより、文書を実際の表示に近い形で編集することが可能になる。そうなることによって文書がより良い体裁を持って公開できるようになることに繋がる。かもしれない。</p>]]></content:encoded>
    </item>

    <item>
      <title>依存しているもののメジャー・バージョンアップ</title>
      <link>http://hail2u.net/blog/software/major-update-of-dependencies.html</link>
      <description>自身のライブラリーなどにおける依存しているものがSemantic Versioningで言うところのメジャー・バージョンアップした場合、APIに互換性のない変更が加えられたということなので、動作を確認して自身のライブラリーもバージョンアップする必要がある。多くの場合、パッチ・バージョンアップで十分だが、互換性のない変更が加わったAPIを透過的に使っていた場合にどうすれば良いのかよくわからなくなった。</description>
      <author>kyo@hail2u.net (Kyo Nagashima)</author>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/major-update-of-dependencies.html</guid>
      <pubDate>Wed, 19 Nov 2014 08:57:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>自身のライブラリーなどにおける依存しているものが<a href="http://semver.org/">Semantic Versioning</a>で言うところのメジャー・バージョンアップした場合、APIに互換性のない変更が加えられたということなので、動作を確認して自身のライブラリーもバージョンアップする必要がある。多くの場合、パッチ・バージョンアップで十分だが、互換性のない変更が加わったAPIを透過的に使っていた場合にどうすれば良いのかよくわからなくなった。</p>

<p>透過的に使っていたAPIに互換性のない変更が加わっているということは、ユーザーがライブラリーを使う方法に互換性のない変更が加わるということになる。仮にこれが依存しているものの変更でないとすると、当然メジャー・バージョンアップすべき変更ということになる。</p>

<p>しかしこういった場合にメジャー・バージョンアップするとすると、最悪の場合依存しているもののメジャー・バージョンアップごとに自身のライブラリーもメジャー・バージョンアップしなくてはならなくなる。自身のライブラリーにおける変更は少ないか全くないにも関わらず、だ。これはフラストレーションが溜まりそうな予感しかない。</p>

<ul>
<li>API<em>そのもの</em>においてどういう変更が加わったのか</li>
<li>APIの<em>使われ方</em>においてどういう変更が加わったのか</li>
</ul>

<p>このどちらの観点でSemantic Versioningのバージョンアップを行うかということになる。後者を重視した方がユーザーに優しいと言えるが、後に首を絞めることになりそうだ。</p>

<hr>

<p>PostCSS v3でSource Mapがデフォルトでインラインに埋め込まれるようになった影響で、自分で作っているCSSWringやCSS MQPackerの使い方に互換性のない変更が加わることとなった。この際にこういった疑問を持ったわけだが、まだ自分の中ですら結論は出ていない。</p>

<p>とりあえずバージョンは上げると戻せないので、上げないと思う。後ろ向きな理由だ。</p>]]></content:encoded>
    </item>

    <item>
      <title>CSSWringで標準入力を読めるように</title>
      <link>http://hail2u.net/blog/coding/read-stdin-in-csswring-cli.html</link>
      <description>先週末の某カンファレンスの方面から無言の圧力を感じたので、CSSWringのCLIプログラムをパイプで繋げられるようにした。入力ファイルが省略されたら……で実装しようとしていたが、オプションの組み合わせの分岐がややこしい。面倒そうだったので入力ファイルとして指定した文字列が-だった場合に……で実装した。</description>
      <author>kyo@hail2u.net (Kyo Nagashima)</author>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/read-stdin-in-csswring-cli.html</guid>
      <pubDate>Tue, 18 Nov 2014 01:47:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>先週末の某カンファレンスの方面から無言の圧力を感じたので、<a href="https://github.com/hail2u/node-csswring">CSSWring</a>のCLIプログラムを<a href="https://github.com/hail2u/node-csswring/commit/95d5346b096bf1063afbe4add18f46b82405032d">パイプで繋げられるように</a>した。入力ファイルが省略されたら……で実装しようとしていたが、オプションの組み合わせの分岐がややこしい。面倒そうだったので入力ファイルとして指定した文字列が<code>-</code>だった場合に……で実装した。</p>

<p>利用方法は今まで入力ファイル名を指定した部分を<code>-</code>に差し替えるだけで良い。特に今までの使い方を阻害することもないと思う。</p>

<pre><samp>$ <kbd>cat input.css | csswring -</kbd>
$ <kbd>csswring - &lt;input.css</kbd>
</samp></pre>

<p>もちろんこのどちらでも大丈夫になっている。この場合は出力ファイルを省略しているので標準出力へ処理結果が吐かれる。</p>

<pre><samp>$ <kbd>cat input.css | csswring - out.css</kbd>
</samp></pre>

<p>標準入力を読みつつ、出力ファイルを指定することもできる。この場合は<code>out.css</code>に処理結果が吐かれる。</p>

<pre><samp>$ <kbd>cat input.css | csswring --sourcemap -</kbd>
$ <kbd>cat input.css | csswring --sourcemap - out.css</kbd>
</samp></pre>

<p>Source Mapsも問題なく出力される。前者ではインラインでData URI化されて埋め込まれ、後者では<code>out.css.map</code>に吐かれる。</p>

<hr>

<p>実装では<a href="http://hail2u.net/blog/coding/nodejs-read-stdin.html">標準入力を同期的に読もうか</a>とも考えたが、同期に固執するほどではないのでNode.js界隈のCLIプログラム達でメジャーな<code>process.openStdin()</code>を使って実装した。<code>process.openStdin()</code>はドキュメントに載っていない気がする。ここが非同期になった関係で出力部分に少し手を入れることになったが、概ねそのままで済んだので新たにバグは入っていないと思う。</p>

<p>ここらへんまで面倒を見てくれるNode.jsパッケージなどもいくつかあるようだ。しかしインタラクティブな入力を処理する必要もないプログラムなので、この程度のもので良いだろう。</p>

<hr>

<p><a href="https://github.com/postcss/postcss/issues/134">PostCSS v3のパーサーのバグ</a>の修正を待って、まとめてリリースする予定だ。そのうち気が向いたら出力の方も善処する。</p>]]></content:encoded>
    </item>

    <item>
      <title>PostCSS v3の変更点</title>
      <link>http://hail2u.net/blog/coding/postcss-v3.html</link>
      <description>PostCSS v3.0.0がリリースされ、かなり高速化した。一部互換性のないAPIの変更があるが、多くは内部的な変更でそれほど影響はないような印象だ。</description>
      <author>kyo@hail2u.net (Kyo Nagashima)</author>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/postcss-v3.html</guid>
      <pubDate>Mon, 17 Nov 2014 02:51:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/postcss/postcss/releases/tag/3.0.0">PostCSS v3.0.0</a>がリリースされ、かなり高速化した。一部互換性のないAPIの変更があるが、多くは内部的な変更でそれほど影響はないような印象だ。</p>

<p>一番大きな変更点はノードの配列名の統一だろう。今までルールセット内の定義の配列は<code>decls</code>、ルールセットの配列は<code>rules</code>と分けられていたが、v3.0.0で<code>childs</code>に統一された。At-ruleでは子ノードに定義をとるもの(<code>@font-face</code>など)とルールセットをとるもの(<code>@media</code>など)があるので、別々に処理しなければならないパターンもありえたが、その必要が少し減ることになる。</p>

<p>なお<code>childs</code>という違和感のある名称はv3.1.0で<code>children</code>(か<code>nodes</code>など)に修正される模様。</p>

<p>もうひとつはSource Mapの生成でインラインのものがデフォルトになったことだ。別ファイルに吐きたい場合は明示的に無効にする必要がある。言い換えると<code>from</code>や<code>to</code>が事実上必須ではなくなったということでもある。</p>

<pre><code>var postcss = require(&#39;postcss&#39;);
var css = &#39;.foo { color: black }&#39;;

console.log(postcss.process(css, {
  <mark>map: true</mark>
}));
// .foo { color: black }
// /*# sourceMappingURL=data:application/json:base64,... */

console.log(postcss.process(css, {
  <mark>map: {
    inline: false
  },</mark>
  from: &#39;in.css&#39;,
  to: &#39;out.css&#39;
}));
// .foo { color: black }
// /*# sourceMappingURL=to.css.map */
</code></pre>

<p>ただし既に外部Source Mapファイルを参照しているCSSを処理する場合は、そのまま外部Source Mapファイルを更新するようになっている。ここらへんを強制的に変更する手段が用意されていないようで、片手落ちっぽい。</p>

<p>またデフォルトで元ソースを埋め込むようにも変更になった。微妙な部分だけれど、元ソースが不要になるとパス解決の面で楽ができると思うので、歓迎できる変更と捉えている。</p>

<hr>

<p>速度の改善がメインのようなので、既存のコードはちょっとした変更だけで動くように思う。Source Mapsだけには注意してやりたい。</p>

<p><a href="https://github.com/hail2u/node-csswring">CSSWring</a>は少々手を入れる必要があったが、簡単な変更でだいたい大丈夫そうだ。ついでにCLIツールで出力ファイル名がなかった場合にインラインでSource Mapを埋め込むようにしておいた。<a href="https://github.com/hail2u/node-css-mqpacker">CSS MQPacker</a>は特に変更することなく更新出来た……が、テストがテストになってない(<code>undefiend === undefined</code>で通ってた)ようなので修正した。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
