<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja-JP"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja-JP</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Sat, 14 Feb 2015 16:23:13 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>夢</title>
      <link>http://hail2u.net/blog/misc/dreaming-20150214.html</link>
      <description>歩いてたらいきなり臭い。しばらくすると防護服を着た人に囲まれる。そのままずっとにらみ合いを続けているとどんどん臭くなっていき、慌てて脇の下とか手とかを嗅いだが臭くない。なんでだろうとお尻に手を伸ばしてからその手を嗅いだら臭くてびっくりしたところで目が覚めた。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/dreaming-20150214.html</guid>
      <pubDate>Sat, 14 Feb 2015 16:20:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>歩いてたらいきなり臭い。しばらくすると防護服を着た人に囲まれる。そのままずっとにらみ合いを続けているとどんどん臭くなっていき、慌てて脇の下とか手とかを嗅いだが臭くない。なんでだろうとお尻に手を伸ばしてからその手を嗅いだら臭くてびっくりしたところで目が覚めた。</p>

<p>自分が寝ながらすごく臭いおならをしただけだった。そのうち大きい方を漏らしそうで怖い。</p>]]></content:encoded>
    </item>

    <item>
      <title>IE11でのfile:プロトコルに対するHistory APIによる操作</title>
      <link>http://hail2u.net/blog/coding/history-api-for-file-protocol-on-ie11.html</link>
      <description>Internet Explorer 11でfile:///で始まるローカル・ファイルのURLをHistory APIで変更すると、ドライブレターがどんどん増えていく現象が起こることを知った。実行する度に/C:が先頭に追加されていく。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/history-api-for-file-protocol-on-ie11.html</guid>
      <pubDate>Fri, 13 Feb 2015 01:08:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Internet Explorer 11で<code>file:///</code>で始まるローカル・ファイルのURLをHistory APIで変更すると、ドライブレターがどんどん増えていく現象が起こることを知った。実行する度に<code>/C:</code>が先頭に追加されていく。</p>

<pre><code>history.replaceState(null, &#39;&#39;, location.pathname);
</code></pre>

<p>相対URLで書きかえが起こるはずなので、こうするとクエリー文字列やフラグメント識別子を削除してクリーンなURLに書き換わるはずだ。実際、普通のウェブサイトで試すと問題なくうまくいく。しかし<code>file:///</code>プロトコルでローカルのファイルを開いている場合、想定通りに動かない。</p>

<pre><samp>&gt; <kbd>location.pathname</kbd>
&lt; &quot;/C:/Users/Kyo/Desktop/test.html&quot;
&gt; <kbd>history.replaceState(null, &#39;&#39;, location.pathname)</kbd>
&lt; undefined
&gt; <kbd>location.pathname</kbd>
&lt; &quot;/C:/C:/Users/Kyo/Desktop/test.html&quot;
</samp></pre>

<p>このようにドライブレターが増殖する。URLの書き換え自体はこのおかしなURLにちゃんと(？)書き換わっているので、この状態で再読込すると「このページは表示できません」になる。</p>

<hr>

<p>明らかにバグと言えそうだが、実際に何か致命的なことが起こるとも思えないバグだ。報告はしておいたけど、悪いこともできなそうな気がするので放置されそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>フルスクリーンでオーバーレイの検索ボックス</title>
      <link>http://hail2u.net/blog/webdesign/fullscreen-overlay-searchbox.html</link>
      <description>増えてきたフルスクリーンでオーバーレイの検索ボックスだが、まだこれといった無難な実装方法はないように見える。今だとvw/vh/vmin/vmax単位を使ってレイアウト、:target擬似クラスを使ってトグルという形にすれば、ほぼCSSで実現できそうだ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/fullscreen-overlay-searchbox.html</guid>
      <pubDate>Thu, 12 Feb 2015 00:55:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="/images/blog/fullscreen-overlay-searchbox.png"><img alt="虫眼鏡アイコンをクリックすると、フルスクリーンかつオーバーレイで表示されるタイプの検索ボックス" height="627" src="/images/blog/fullscreen-overlay-searchbox.png" width="1200"></a>
</figure>

<p>増えてきたフルスクリーンでオーバーレイの検索ボックスだが、まだこれといった無難な実装方法はないように見える。今だと<a href="http://www.w3.org/TR/css3-values/#viewport-relative-lengths"><code>vw</code>/<code>vh</code>/<code>vmin</code>/<code>vmax</code>単位</a>を使ってレイアウト、<a href="http://www.w3.org/TR/css3-selectors/#target-pseudo"><code>:target</code>擬似クラス</a>を使ってトグルという形にすれば、ほぼCSSで実現できそうだ。</p>

<p>View Demo: <a href="/pub/test/609.html">Fullscreen Overlay Searchbox</a></p>

<p>デモではShow Searchboxというリンクをクリックすると検索ボックスが表示され、検索ボックスの左上にある✖をクリックすると閉じることができる。実際のウェブサイトではリンクの代わりに虫眼鏡のアイコンでも使ってやれば良いだろう。</p>

<h2>マークアップ</h2>

<pre><code>&lt;aside id=&quot;search&quot; class=&quot;searchbox&quot;&gt;
  &lt;h1&gt;Search this site&lt;/h1&gt;

  &lt;form&gt;
    &lt;input class=&quot;query&quot; placeholder=&quot;Enter search keyword(s)&quot; type=&quot;search&quot;&gt;
  &lt;/form&gt;

  &lt;footer&gt;
    &lt;a class=&quot;close&quot; href=&quot;#top&quot;&gt;Back to Top&lt;/a&gt;
  &lt;/footer&gt;
&lt;/aside&gt;
</code></pre>

<p>検索ボックスのマークアップは<code>aside</code>要素を使って、このような形にした。<code>id</code>属性は後に<code>:target</code>擬似クラスで利用するため、必須になる。</p>

<p><code>h1</code>要素は冗長な気もするが、通常は隠れたセクションであることを考慮すると、見出しはあった方が良いだろう。<code>label</code>要素や<code>input type=submit&quot;</code>を使う必要がないフォームであることも考えると、このような一般的な文言で見出しを付けておくのが無難か。</p>

<p>閉じるボタンは<code>a</code>要素で<code>#top</code>に移動させるようにして実現するが、リンク文字列は「閉じる」や「Close」ではない方が良い。CSS側で✖に変えたりすることになるが、リンクそのものの機能としてはページの最上部に移動するという機能でしかないからだ。CSSが無効の時に「閉じる」というリンクで「ページの最上部に移動する」ことになるのがおかしいからというように考えても良いだろう。</p>

<h2>フルスクリーン化</h2>

<pre><code>.searchbox {
  height: 100vh;
  left: 0;
  position: fixed;
  top: 0;
  width: 100vw;
}
</code></pre>

<p>検索ボックスのレイアウトでは<code>vw</code>と<code>vh</code>単位を使って描画領域全体と同じサイズになるようにして、フルスクリーンになるようにする。サイズさえ正しければ<code>position: fixed</code>で配置するだけで、きれいに全体にかぶさるはずだ。</p>

<h2>閉じるボタン</h2>

<pre><code>.searchbox .close {
  display: block;
  font-size: 8vmin;
  height: 8vmin;
  left: 1vmin;
  position: absolute;
  top: 1vmin;
  width: 8vmin;
}

.searchbox .close::before {
  content: &#39;✖&#39;;
  display: block;
  height: 100%;
  width: 100%;
}
</code></pre>

<p>閉じるボタンでは<code>vmin</code>単位を使うことで占有する面積を一定以下に維持し、大きすぎる・小さすぎるがあまりないようにしておいた。<code>font-size</code>でも使えるので、うまく使ってやるときれいに文字(記号)を配置することができる。また、<code>vw</code>や<code>vh</code>ではなく<code>vmin</code>単位を使うことで、縦横のどちらが余っているのかわからない検索フォームの領域とかぶさらないようにもできる。そうすると閉じるボタンがクリックできないというような事故や検索フォームをクリアーするアイコンとかぶったというような事故を避けることができるはずだ。</p>

<p>もうひとつスクロールバーの有無という問題があるので、左上に配置すると簡単になる。スクロールバーの有無をCSSで判定するのは難しく、かといってそのためだけにJavaScriptを使うのももったいない。<code>calc()</code>を使うと何とかなるが、直感的ではない。近年のOSのGUIを考えると、閉じるボタンが右上というのももはや暗黙の了解とは言えなくなってきたので、左上でもわかりやすければ大丈夫だろう。</p>

<p>アイコン化は簡単にユニコードの<a href="http://en.wikipedia.org/wiki/Dingbat#Unicode">Dingbatsブロック</a>のHeavy Multiplication Xを利用した。うかつに絵文字で良さそうなものを探すと予期せぬカラー化などが起こるので、こういったUIでおとなしめに使う場合はこの辺りの記号から選択すると良い。</p>

<h2>検索ボックス</h2>

<pre><code>.searchbox .query {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  font-size: 7vmin;
  left: 10vw;
  margin-top: -0.675em;
  position: absolute;
  top: 50%;
  width: 80vw;
}
</code></pre>

<p>検索フォームは縦横中央寄せをすることになる。<code>transform: translate()</code>を使って配置しても良いが、運が悪いと枠線や背景画像がぼやけてしまう。この場合はサイズが明確なので、絶対配置と負のマージンで配置する方が安定する。Flexboxも悪くないが、単純な縦方向のセンタリングには少し牛刀感がある。</p>

<p>左位置の指定や幅においても<code>vw</code>単位を使うことで、前述の閉じるボタンとうまくマッチさせることができる。画面サイズに従ってある程度可変して欲しいフォント・サイズは<code>vmin</code>を使って調節するのが簡単だ。メディア・クエリーを使ってビューポートのサイズで切り替えるのも悪くないがそこそこ手間がかかる。</p>

<h2>トグルの実装</h2>

<pre><code>#searchbox {
  display: none;
}

#searchbox:target {
  display: block;
}
</code></pre>

<p>トグルの機能はフラグメント識別子と<code>:target</code>擬似クラスの組み合わせで簡単に実装できる。閉じるボタンのリンク先を<code>#top</code>にしてやると、それをクリック(タッチ)することで<code>#search:target</code>を無効にできるため、うまいこと検索ボックスを閉じることができるというわけだ。ここでIDセレクターをちゃんと使うことで、フルスクリーンでオーバーレイにするビジュアル・デザインのためのルール群とトグルのためのルールを切り分けることができる。</p>

<p>デモでは検索ボックスを消した後に残るフラグメント識別子を<code>histroy.replaceState()</code>を使って消しているが、これをやめればCSSのみでできるだろう。</p>

<hr>

<p>フルスクリーンでオーバーレイの検索ボックスは、独立したコンポーネントとしてデザインしやすいのが大きな利点だ。そうデザインできることで、異なるデバイス間でも似た検索体験を提供でき、また違うプロジェクトでも再利用することも比較的容易になる。ここで作ったデモもほぼどこでも使えるように出来たと思う。</p>

<p>しかし独立したコンポーネントとしてデザインするためには、構造(HTML)として安定した形(独立したセクション)である必要があり、その上で前後の文脈や周辺の要素に依存しないようにCSSを書いていく必要がある。<code>vw</code>や<code>vh</code>、<code>vmin</code>、<code>vmax</code>といった描画領域を基準にした単位は、親要素はもちろん<code>body</code>や<code>html</code>要素のレンダリング状況を迂回してサイズを決定できるので、そういったCSSの書き方に大いに役に立つ。</p>]]></content:encoded>
    </item>

    <item>
      <title>バターなし！牛乳なし！のヨーグルトを使ったスコーン</title>
      <link>http://hail2u.net/blog/misc/yogurt-scone.html</link>
      <description>ヨーグルトを水切りしてクリームとホエーに分け、それをバターと牛乳の代わりにして作るスコーンを作った。水切りに時間はかかったものの、バターの時とほぼ同じ感覚で作ることができ、特に難しくなかった。美味しかったけれど、やっぱりスコーンではないかなーというできあがりだ。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/yogurt-scone.html</guid>
      <pubDate>Wed, 11 Feb 2015 00:01:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="/images/blog/yogurt-scone.jpg"><img alt="水切りしたヨーグルトを使い、バターなし！牛乳なし！で作ったスコーン" src="/images/blog/yogurt-scone.jpg"></a>
</figure>

<p>ヨーグルトを水切りしてクリームとホエーに分け、それをバターと牛乳の代わりにして作るスコーンを作った。水切りに時間はかかったものの、バターの時とほぼ同じ感覚で作ることができ、特に難しくなかった。美味しかったけれど、やっぱりスコーンではないかなーというできあがりだ。</p>

<p>ヨーグルトの水切りはガーゼを二重にして筒状の容器にかぶせてから輪ゴムで止めたものでやった。キッチンペーパーでも可能なようだけれど、ヨーグルトの水分量の多さにも依存するので、ガーゼやふきんの方が無難そうだ。きっちりクリーム状にするには一晩かかる。ヨーグルトは<a href="http://product.koiwaimilk.com/product/yogurt/nama_400.html">小岩井 生乳100％ヨーグルト</a>を丸々400g使った。これで大体200g弱のクリームと150ccくらいのホエーに分離するようだ。</p>

<table>
<thead>
<tr>
<th>材料</th>
<th style="text-align:right">分量</th>
</tr>
</thead>
<tbody>
<tr>
<td>小麦粉</td>
<td style="text-align:right">150g</td>
</tr>
<tr>
<td>ベーキングパウダー</td>
<td style="text-align:right">10g</td>
</tr>
<tr>
<td>砂糖</td>
<td style="text-align:right">大さじ2</td>
</tr>
<tr>
<td>塩</td>
<td style="text-align:right">小さじ1/3</td>
</tr>
<tr>
<td>ヨーグルトクリーム</td>
<td style="text-align:right">50g</td>
</tr>
<tr>
<td>ホエー</td>
<td style="text-align:right">大さじ1</td>
</tr>
<tr>
<td>サラダ油</td>
<td style="text-align:right">大さじ1</td>
</tr>
<tr>
<td>溶き卵</td>
<td style="text-align:right">1/2個</td>
</tr>
</tbody>
</table>

<p>この分量で7個分として焼いたところ、こぶし大より一回りくらい小さいサイズに焼きあがった。バターなし！牛乳なし！</p>

<p>小麦粉から塩までを一旦混ぜあわせ、そこにヨーグルトクリームを加えて更に混ぜ、最後にホエーから溶き卵までを混ぜると生地がまとまる。ゴルフボールくらいに丸めただけで焼いたところ、ポワンとパンみたいにふっくらしてしまったので、ちゃんとのばして型抜きした方が良いのかもしれない。</p>

<p>サクフワで普通のスコーンとは違った美味しさだった。まわりはカリッと焼きあがることもあって、甘食とかの食感に近い。甘みが強めだったので、砂糖はもうちょっと減らしても良いかもしれないけれど、それだと今度はヨーグルトクリームの酸味やベーキングパウダーの苦味が出てしまいそうだ。</p>

<hr>

<p>スコーンのサクサクではないサックリ感みたいなのはやはりバターなようだ。ちょくちょくバターをなたね油などで代用したお菓子レシピとか見かけるが、あんまり期待はできない感じがしてきた。でも今度やってみよう。</p>

<p>余ったホエーは野菜入れてスープにして飲んだが、これは微妙だった(まずくはない)。このホエーと牛乳でリコッタチーズのようなものができあがるらしいので、今度やる時は挑戦してみようと思う。ヨーグルトクリームの方はレーズンパンに塗ったり、コーヒーに浮かべたり、どうやっても美味しかった。</p>]]></content:encoded>
    </item>

    <item>
      <title>置換要素の絶対配置</title>
      <link>http://hail2u.net/blog/webdesign/absolute-positioning-on-replaced-element.html</link>
      <description>検索ボックスを更新して検索ボタンを左に動かした……つもりだったが、動いていなかったのを直していた。単純に置換要素を絶対配置する時にautoの扱いが非置換要素と違うことを完全に忘れていたのが原因で直せたが、どうしてこうなるのかがよくわからなくなったので少し調べてみたが更に混乱しただけだった。Chrome 40 (31あたりから変わったらしい？)の挙動が正しそうだが……。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/absolute-positioning-on-replaced-element.html</guid>
      <pubDate>Tue, 10 Feb 2015 11:36:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>検索ボックスを更新して検索ボタンを左に動かした……つもりだったが、動いていなかったのを直していた。単純に置換要素を絶対配置する時に<code>auto</code>の扱いが非置換要素と違うことを完全に忘れていたのが原因で直せたが、どうしてこうなるのかがよくわからなくなったので少し調べてみたが更に混乱しただけだった。Chrome 40 (31あたりから変わったらしい？)の挙動が正しそうだが……。</p>

<p>View Demo: <a href="/pub/test/608.html">position: absolute on Replaced Element</a></p>

<p>デモでは置換要素を二つ(入力ボックスと送信ボタン)並べ、送信ボタンを絶対配置しようとしている。</p>

<p>最初の例では入力ボックスの幅が<code>100%</code>になっており、枠線の分だけはみ出す状態だ。この状態で続く送信ボタンを絶対配置し、<code>left</code>プロパティーを無指定にすると、なぜかInternet Explorer 11では入力ボックスの隣に配置される。他のブラウザーでは入力ボックスのすぐ下だ。</p>

<p>二番目の例では入力ボックスに<code>box-sizing</code>プロパティーを適用して、幅を<code>100%</code>にしてもはみ出さないようにしている。この状態ではFirefox 35やMobile Safari 8でも送信ボタンが入力ボックスの隣に配置されるようになる。Chrome 40では入力ボックスのすぐ下だ。</p>

<p>三番目の例では送信ボタンへ<code>left: 0</code>を指定している。Internet Explorer 11では入力ボックスに重なってしまう。他のブラウザーでは入力ボックスのすぐ下だ。</p>

<hr>

<p>折り返しが起きるタイミングと<code>left: auto</code>の解釈の違いが重なっていて、たまたま似たような配置になったりならなかったりするようだ。<a href="http://www.w3.org/TR/CSS2/visudet.html#abs-replaced-width">仕様</a>(<a href="http://www.w3.org/TR/2015/WD-css3-positioning-20150203/#abs-replaced-width">最新の仕様</a>も含め)がややこしいこともあって、どれがバグでどれが仕様なのかよくわからなくなった。</p>

<p>ともかく<code>auto</code>による適当な配置に期待せずにばっちりと値を指定することでこの辺りでハマることはなくなるだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>Drawic v2.9.0</title>
      <link>http://hail2u.net/blog/webdesign/drawic-v2.9.0.html</link>
      <description>はてなブックマークでブックマークするリンクを復活させた都合で、はてな系のアイコンを4種類、Drawicに追加してv2.9.0にした。はてなのアイコン平べったい。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/drawic-v2.9.0.html</guid>
      <pubDate>Mon, 09 Feb 2015 10:44:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="http://hail2u.github.io/drawic/"><img alt="はてな・人力検索はてな・はてなブックマーク・はてなブロク" height="627" src="/images/blog/drawic-v2.9.0.png" width="1200"></a>
</figure>

<p>はてなブックマークでブックマークするリンクを復活させた都合で、はてな系のアイコンを4種類、<a href="http://hail2u.github.io/drawic/">Drawic</a>に追加してv2.9.0にした。はてなのアイコン平べったい。</p>

<p>ブックマークするリンクを追加する時、はてなブックマークでブックマークするページがユーザーごとにユニークなことをすっかり忘れてた。TwitterやFacebookみたいなURLか、あの大きいブックマーク画面へリダイレクトしてくれるURLみたいなの欲しい気がする……と<code>/my/add.confirm</code>をエンドポイントにするとリダイレクトしてくれることを思い出したので、これを使うことにした。</p>

<p>まだブックマークされていない時のページが気になるけど、ブックマークレットの画面を流用するよりは多分マシ。</p>]]></content:encoded>
    </item>

    <item>
      <title>文字参照と属性セレクター</title>
      <link>http://hail2u.net/blog/webdesign/character-reference-and-attribute-selector.html</link>
      <description>文字参照を含む可能性がある属性の値を使ってセレクターを自動生成するような仕組みで少しハマった。文字参照をそのまま属性セレクターの値として指定してしまったので、うまく動かなかった。style要素に記述するようなケースでも、属性セレクターの値には文字参照は使えない。戻して書き、必要ならバックスラッシュでエスケープする。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/character-reference-and-attribute-selector.html</guid>
      <pubDate>Sun, 08 Feb 2015 10:12:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>文字参照を含む可能性がある属性の値を使ってセレクターを自動生成するような仕組みで少しハマった。文字参照をそのまま属性セレクターの値として指定してしまったので、うまく動かなかった。<code>style</code>要素に記述するようなケースでも、属性セレクターの値には文字参照は使えない。戻して書き、必要ならバックスラッシュでエスケープする。</p>

<p>View Demo: <a href="/pub/test/607.html">Character Reference and Attribute Selector</a></p>

<p>デモの<code>p</code>要素には<code>title</code>属性の値に二重引用符が文字参照で入っている。普通に文字参照を使って属性セレクターを書いた場合、要素が選択できない。また属性セレクターでの二重引用符は特別な意味を持つので、引用符なしのつもりで書いても同じように選択できない。文字参照を戻した上で以下のどれかで指定する必要がある。</p>

<ul>
<li>一重引用符で括る</li>
<li>二重引用符で括り、エスケープする</li>
<li>二重引用符をエスケープする</li>
</ul>

<p>属性セレクターでは引用符で括ることが必須ではないので、エスケープするだけでも大丈夫だった。</p>

<hr>

<p>やりたかった仕組みではユーザーの入力によって仕込まれた<code>title</code>属性の値に従ってセレクターを生成して、スタイルを追加するというようなものなので、ユーザーの入力をそのまま<code>style</code>要素の子に追加する必要があり、かなり危険そうだ。別の方法を考えなければならなくなった……。</p>]]></content:encoded>
    </item>

    <item>
      <title>node-git-release v1.1.2</title>
      <link>http://hail2u.net/blog/software/node-git-release-v1.1.2.html</link>
      <description>node-git-releaseをio.js v1.1.0を要件にして、child_process.spawnSync()を使って書き直した。使い方をうまく考えつかなくて、あんまりきれいにならない。asyncパッケージを使った方がスッキリ見えるのは慣れの問題だろうか。とか下書きしていたらNode.js v0.12.0が出て、こちらでも*Sync()がサポートされ、動くようになったようだ(試してない)。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/node-git-release-v1.1.2.html</guid>
      <pubDate>Sat, 07 Feb 2015 09:38:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/hail2u/node-git-release">node-git-release</a>をio.js v1.1.0を要件にして、<code>child_process.spawnSync()</code>を使って書き直した。使い方をうまく考えつかなくて、あんまりきれいにならない。asyncパッケージを使った方がスッキリ見えるのは慣れの問題だろうか。とか下書きしていたらNode.js v0.12.0が出て、こちらでも<code>*Sync()</code>がサポートされ、動くようになったようだ(試してない)。</p>

<p><code>package.json</code>でio.jsの特定バージョンを要件にしたい場合、<code>engines</code>フィールドでは<code>iojs</code>というキーで指定するようだ。npmの公式ドキュメントでは特に触れられていないが、Herokuでは既にこれを見て実装されているという話だった。</p>

<pre><code>{
  &quot;engines&quot;: {
    &quot;iojs&quot;: &quot;&gt;=v1.1.0&quot;
  }
}
</code></pre>

<p>当然ながら実行をブロックしてくれるわけではないので、気休め程度と言って良い。他、この<code>engines</code>フィールドでio.js v1.1.0<em>または</em>Node.js v0.12.0という要件にしたい場合の書き方がわからないという問題もあった。配列で書くしかないような気がするが、解釈できるのだろうか。色々想定されていなさそうなフィールドなので、Herokuで明示的にio.jsを使いたいという場合を除いて指定しない方が良さそうだ。</p>

<hr>

<p>WindowsのGitがアレでアレなので、いまだ<code>npm publish</code>することができない。一生無理そう。</p>]]></content:encoded>
    </item>

    <item>
      <title>銀ぶら</title>
      <link>http://hail2u.net/blog/misc/ginbura.html</link>
      <description>Patrickの直営店へは銀座駅から有楽町ルミネ、松屋銀座を経由しながら歩いた。この辺りは昔(10年以上前)とあんまり変わっていない気もしたけど、楽しそうな店や変な建物があって、やはり銀座は楽しい。Cole HaanやArc’terixの店舗などをのぞいていたら、電車で下がったテンションもすぐに上がった。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/ginbura.html</guid>
      <pubDate>Fri, 06 Feb 2015 07:56:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="/images/blog/ginbura.jpg"><img alt="銀座三越の隣にあるピアス銀座ビル" height="2760" src="/images/blog/ginbura.jpg" width="2448"></a>
</figure>

<p><a href="https://www.google.com/maps/place/PATRICK+LABO+GINZA/@35.672537,139.770912,17z/data=!4m6!1m3!3m2!1s0x60188be1a52511d7:0x95a40c38fe1238b8!2sPATRICK+LABO+GINZA!3m1!1s0x60188be1a52511d7:0x95a40c38fe1238b8">Patrickの直営店</a>へは銀座駅から有楽町ルミネ、松屋銀座を経由しながら歩いた。この辺りは昔(10年以上前)とあんまり変わっていない気もしたけど、楽しそうな店や変な建物があって、やはり銀座は楽しい。<a href="https://www.colehaan.co.jp/">Cole Haan</a>や<a href="http://arcteryx.com/Home.aspx?language=JP">Arc’terix</a>の店舗などをのぞいていたら、電車で下がったテンションもすぐに上がった。</p>

<figure>
  <a href="/images/blog/patrick-labo-ginza.jpg"><img alt="こじんまりとしたPatrick直営店、Patrick LABO GINZA" height="2400" src="/images/blog/patrick-labo-ginza.jpg" width="2400"></a>

  <figcaption>Patrick LABO GINZA</figcaption>
</figure>

<p>帰りは京橋の方をぶらぶらしてから、東京駅をくぐり、新丸ビル、三菱一号館美術館、皇居の堀沿いと歩いて、東京駅に戻って帰った。<a href="http://www.kataoka.com/echire-shop.html">エシレ</a>で何かパンを買えばよかったけど、フラフラするの楽しすぎてまったく思い出せなかった。</p>

<figure>
  <a href="/images/blog/tokyo-marunouchi-chuo-guchi-to-koukyo.jpg"><img alt="東京駅丸の内中央口から皇居へは何にもない歩道になっている" height="2448" src="/images/blog/tokyo-marunouchi-chuo-guchi-to-koukyo.jpg" width="3264"></a>

  <figcaption>丸の内中央口から皇居</figcaption>
</figure>

<p>疲れたけど足に馴染み始めた<a href="/blog/gadget/camper-mil-chelsea-boots.html">Camperのブーツ</a>がいい仕事してくれた。</p>]]></content:encoded>
    </item>

    <item>
      <title>EDJOの(デ)メリット</title>
      <link>http://hail2u.net/blog/webdesign/on-every-declaration-just-once.html</link>
      <description>Every Declaration Just Once (以下EDJO)アプローチの最大のメリットはなんだろうかということについて考えていた。情報設計と重なるところがまるでないため、設計思想としては完全に成立しない。つまりCSSを設計することを放棄し、設計されたHTMLに対してスタイルを割り当てていく手法としてのみ存在しうる。このことがすなわちメリットなのではないだろうか。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/on-every-declaration-just-once.html</guid>
      <pubDate>Thu, 05 Feb 2015 11:54:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Every Declaration Just Once (以下EDJO)アプローチの最大のメリットはなんだろうかということについて考えていた。情報設計と重なるところがまるでないため、設計思想としては完全に成立しない。つまりCSSを設計することを放棄し、設計されたHTMLに対してスタイルを割り当てていく手法としてのみ存在しうる。このことがすなわちメリットなのではないだろうか。</p>

<p>CSSの限られた文法が情報設計に基づく複雑な構造の表現に適さないことは明白だ。OOCSSではHTMLとCSSを設計のもとに平等に扱っていたが、どうしてもCSSにおいては限界があり、複雑な命名規則やCSSプリプロセッサーの登場となったのではないかと思う。CSSプリプロセッサーの高機能化により実現可能になりつつあるが、それと同時に高度に抽象化された複雑さも氾濫しつつある。</p>

<p>EDJOにおいては<a href="https://github.com/hail2u/node-edjo/blob/master/test.edjo.css">その書かれ方</a>を見ればわかる通り、設計というものを放棄することになる。設計されたHTMLに対してスタイルを割り当てていくという作業にすべては集約されることになるだろう。CSSは単にHTMLへスタルを割り当てていくのみでそれ以上の意味は持たない。OOCSSにおいてはともすれば「貧弱さ」と表現されるCSS文法の単純さに似合った割り切りであると言えよう。</p>

<p>CSSでの設計の放棄とEDJOの採用には、いくつかの派生的なデメリットとメリットが含まれる。</p>

<h2>CSSのわかりやすさ</h2>

<p>論理的な単位で定義がまとまっていないため、定義そのものはわかっても、他と組み合わせた結果どうなるかまでは不透明で、わかりやすさに欠けるCSSになる。定義が上書きされることがまずないという点ではOOCSSのような論理的な単位で管理するよりも<em>誤解</em>をする可能性は減るが、全般的にはデメリットと言えるだろう。</p>

<p>このわかりやすさの欠如はデバッガビリティーというようなものにはあまり影響をあたえることはない。なぜならこのわかりにくさの欠如はCSSファイルを相手にして格闘することが不可能なことを意味するので、ブラウザーに内蔵されている開発者ツールという武器を必ず使うことになるからだ。そういう意味では開発者ツールとは相性が良いとも言えるだろう。</p>

<h2>セレクター数</h2>

<p>IE9以下にはよく忘れてよくハマるCSSファイルごとのセレクター数に限界があるという仕様がある。定義ごとにセレクターを割り当てていくという手法の都合上、その限界はかなり簡単に突破してしまう。普通にCSSを書く場合と比べると、おおまかに3–5倍程度にセレクター数が増えると見積もる必要がある。</p>

<p>OOCSS+CSSプリプロセッサーで書く場合と比べるならば遭遇しやすいというだけに過ぎないとも言えるが、現実的な問題ではある。運用でカバーすることは難しいので、必ず<a href="https://www.npmjs.com/package/grunt-selector4096">チェックすること</a>と、<a href="http://blesscss.com/">機械的に処理すること</a>を徹底する必要はあるだろう。</p>

<h2>オブジェクトの再構築</h2>

<p>OOCSSで書いている時に避けて通れないのがオブジェクトの再構築だ。<a href="http://dskd.jp/archives/57.html">EDJOなオブジェクトの妄想という記事</a>でも触れられているが、僕もこれは非常に大きいと考える。OOCSSのオブジェクトを再構築するのは非常にコストが高い。単にオブジェクトのスタイルの編集だけに留まらず、そのリネーム、新たなオブジェクトの設計、参照の書きかえ、と必要になる作業が非常に多い。</p>

<p>EDJOにおいてはセレクターの書き足し、必要ならルールセットの追加という2つのパターンで常に完了する。OOCSSにおけるオブジェクトのような参照の対象を、CSSの仕様(または実装)にまで遡るため、書きかえたくてもできないという方が適切かもしれない。</p>

<p>このことはオブジェクトの再構築を避けるためによく行うプロパティーの上書きをなくせるということでもある。それに伴ってほぼ上書きが不要になることからセレクターの詳細度への配慮が不要になることでもあり、CSSにおける制約からHTMLのクラス名に強い命名規則を強制しなくても良いということでもある。</p>

<h2>差分</h2>

<p>近年の開発において差分への意識は不可欠であるとも言える。確実なマージのためにはレビューが不可欠であり、適切なレビューのためには差分が明確であることがある程度要求される。</p>

<p>通常のCSSの書き方では、CSSへのルールセットのブロック単位での追加とHTMLへのクラスの追加が差分として表示されることになる。対してEDJOではCSSへの編集のみに集約されることだろう。</p>

<pre><code>@@ -1,4 +1,5 @@
 .foo,
+.bar,
 .black-text {
   color: black;
 }
</code></pre>

<p>CSSにおける差分もこのような単純な行の追加の組み合わせだけになる。他の差分ブロックと混ざることもない。</p>

<hr>

<p>設計の放棄と言っても、実際には情報設計が最初にあり、それを反映させたHTMLがある。EDJOでは情報設計を元にするのではなく、それを元にしたHTMLに対してアピアランスとしてスタイルを割り当てていくというわけだ。情報設計の元でHTMLとCSSを並列させる場合、両者をきれいに連携させるためには強力な命名規則か高機能なCSSプリプロセッサー、またはその両者が必要になってしまう。それをHTMLに完全にCSSを従属させることでシンプルでストレートで逆転することのない序列を強いることができるのがEDJOの良いところだろう。</p>

<p>反面、論理的な構造を持たないため、CSSファイル単体で完結しないという問題がある。機械的な生成ではない形でスタイル・ガイド(のようなもの)を作成し、それを基準にブラウザーの開発者ツールでデバッグするという形での開発でないと苦しいだろう。書き方の違いに慣れることも含め、ドラスティックに開発フローを変更する手法であると言える。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
