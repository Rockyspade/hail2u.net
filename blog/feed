<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja-JP"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja-JP</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Tue, 13 Jan 2015 13:22:52 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="http://hail2u.net/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>白Tシャツ</title>
      <link>http://hail2u.net/blog/misc/white-t-shirt.html</link>
      <description>良さそうな白いTシャツがなかなか見つからず、結局HanesのJapan FitなるもののBEAMSのロゴ入りのバージョンを買った。着丈がもうちょっと短めのを探すとなると大変なようなので、もうインナーでしか着ないと決め、これにした。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/white-t-shirt.html</guid>
      <pubDate>Tue, 13 Jan 2015 13:22:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="http://www.amazon.co.jp/gp/product/B00KQ4CAWG/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00KQ4CAWG&amp;linkCode=as2&amp;tag=hail2unet-22"><img src="http://ecx.images-amazon.com/images/I/31FHI7XxhAL.jpg" alt="(ビームス) BEAMS HANES / T-SHIRTS Japan Fit"></a>
</figure>

<p>良さそうな白いTシャツがなかなか見つからず、結局<a href="http://www.amazon.co.jp/gp/product/B00KQ4CAWG/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00KQ4CAWG&amp;linkCode=as2&amp;tag=hail2unet-22">HanesのJapan FitなるもののBEAMSのロゴ入りのバージョン</a>を買った。着丈がもうちょっと短めのを探すとなると大変なようなので、もうインナーでしか着ないと決め、これにした。</p>

<p>最初はちょっとへなへなすぎて頼りなかったけど、数回洗うとちょっとしまってきた。若干ゆるめな襟もびろんびろんにヘタったりはしなそうだ。一枚で着るのは無理があるけど、肌触りは良くインナーとしては優秀。難点は裾にあるタグ。肌に当たらないようにとあの位置なのはわかるんだけど、どうせなら外しやすく別に縫い付けてくれるか、ロゴと同じ位置に印刷だと良かった。</p>

<hr>

<p>この秋冬は<a href="http://www.pinterest.com/hail2u/bought/">ブーツ買ったりジーンズ買ったりセーター買ったり帽子買ったり財布買ったりコート買ったり</a>してた。あと袖を破いてしまったジャケットの代替と、場つなぎで買ったら1ヶ月で壊れ始めたスニーカーを諦めてちゃんとしたのも買いたい。こうしてどんどん新しいパソコン買うのが先延ばしになっていく……。Broadwell出たらとかWindows 10出たらとか理由を付けて誤魔化している。</p>]]></content:encoded>
    </item>

    <item>
      <title>Gruntプラグインの同梱</title>
      <link>http://hail2u.net/blog/coding/with-grunt-plugin.html</link>
      <description>遂に別々に管理するのが面倒になったので、PostCSSを使ったツールにGruntプラグインも同梱するようにした。grunt-postcssなどから使う方が効率的なので、もはや単体のGruntプラグインはメンテナンスが放棄されがちだ。CSSWring v2.1.0とCSS MQPacker v2.1.0には既に同梱されている(まだPostCSS v4.0.0にはなっていない)。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/with-grunt-plugin.html</guid>
      <pubDate>Mon, 12 Jan 2015 01:36:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>遂に別々に管理するのが面倒になったので、PostCSSを使ったツールにGruntプラグインも同梱するようにした。<a href="https://github.com/nDmitry/grunt-postcss">grunt-postcss</a>などから使う方が効率的なので、もはや単体のGruntプラグインはメンテナンスが放棄されがちだ。<a href="https://github.com/hail2u/node-csswring/tree/ba3642d9d94149e3519de5db2993ca5232752d2b">CSSWring v2.1.0</a>と<a href="https://github.com/hail2u/node-css-mqpacker/tree/e234fdb3d7565740f68450b5f33b81c9d777dddf">CSS MQPacker v2.1.0</a>には既に同梱されている(まだPostCSS v4.0.0にはなっていない)。</p>

<p><a href="https://github.com/sindresorhus/load-grunt-tasks">load-grunt-tasks</a>などのGruntプラグイン読み込み自動化パッケージの恩恵には預かれないため、<code>Gruntfile.js</code>で自前で読み込んでやる必要がある。</p>

<pre><code>module.exports = function (grunt) {
  grunt.loadNpmTasks(&#39;css-mqpacker&#39;);
  grunt.loadNpmTasks(&#39;csswring&#39;);
};
</code></pre>

<p>両者とも設定はないが、PostCSSの<code>process()</code>の第二引数にしていするオプションを<code>options</code>を使って指定できるようにはなっている。のでSource Mapsも自在に吐ける。継承したい場合は<code>map: true</code>を指定してやるだけで、PostCSSが賢いのでだいたい動く。</p>

<hr>

<p>PostCSSを利用する単体のGruntプラグインのgrunt-postcssに対する優位性は、<code>peerDependencies</code>によるPostCSSのバージョンの束縛を無視できることだ。</p>

<p>grunt-postcssを使う場合、要求するPostCSSのバージョンが食い違っているもの同士を組み合わせることができなくなる。<code>peerDependencies</code>でそれぞれバージョンを束縛できるが、そうなると食い違うものがそもそもインストール出来なくなる。解決のためにはパッケージ側のアップデートが必須になる。</p>

<p>単体のGruntプラグインの場合はそれぞれが独自にPostCSSをインストールして使うので、ほとんどのケースで組み合わせることが可能になる。その分、無駄が多くなるということでもあるけれども。</p>

<p>この辺りはGruntもPostCSSもプラグイン・システムとして失敗した感がある部分で、もうちょっとなんとかしないとメンテナンスが放棄されているけどまだ動くものが最新版の環境ではうまく動かせなくなってしまう。その点、gulpでは<a href="https://github.com/gulpjs/gulp/blob/master/docs/writing-a-plugin/guidelines.md">gulpパッケージが<code>dependencies</code>にも<code>peerDependencies</code>にも現れないように書くべき</a>としており、柔軟性と将来性で優っている。</p>]]></content:encoded>
    </item>

    <item>
      <title>PostCSS v4と空白</title>
      <link>http://hail2u.net/blog/coding/postcss-v4-and-white-spaces.html</link>
      <description>PostCSSのv4.0.0が年明け早々に出た。互換性のない変更の中では、v3.0.0でchildsと妙なスペルで名付けられたものがnodesに修正されたことが一番大きそうだ。他、便利メソッドの追加に加え、空白の最適化機能が大幅に変更になった。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/postcss-v4-and-white-spaces.html</guid>
      <pubDate>Sun, 11 Jan 2015 14:00:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/postcss/postcss/releases/tag/4.0.0">PostCSSのv4.0.0</a>が年明け早々に出た。互換性のない変更の中では、v3.0.0で<code>childs</code>と妙なスペルで名付けられたものが<code>nodes</code>に修正されたことが一番大きそうだ。他、便利メソッドの追加に加え、空白の最適化機能が大幅に変更になった。</p>

<p>ソースを読んでもよくわからなかったので<a href="https://github.com/postcss/postcss/issues/165">イシューを立てて聞いたところ</a>、思ったよりもかなり複雑そうだった。しかしよく練られてはいる印象は持ったので、これに任せてしまうのが賢そうだ。つまりノードを動かす時には<code>clone()</code>を通すか、新メソッドの<code>moveTo()</code>などを使ってやることで、まずノードの空白関連のプロパティーをリセットする。後はPostCSSに前後のノードを参照するかデフォルトのフォーマットを採用するかを選択させるという形だ。</p>

<p>PostCSS側の変更でテストの期待される結果は書き直さなければならなそうだが、ライブラリー側で余計なことをするよりかはコストが低いと思われる。</p>]]></content:encoded>
    </item>

    <item>
      <title>postcss-single-charset</title>
      <link>http://hail2u.net/blog/webdesign/postcss-single-charset.html</link>
      <description>minifyしてからconcatという手順でCSSをビルドしているため、連結するそれぞれのCSSファイルにある@charsetルールが無意味になる。そこで最初の@charsetを先頭に持ってくるだけのPostCSSプラグインを書き、それをconcatした後に使うことにした。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/postcss-single-charset.html</guid>
      <pubDate>Sat, 10 Jan 2015 01:52:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="http://hail2u.net/blog/webdesign/minify-then-concat.html">minifyしてからconcat</a>という手順でCSSをビルドしているため、連結するそれぞれのCSSファイルにある<code>@charset</code>ルールが無意味になる。そこで最初の<code>@charset</code>を先頭に持ってくるだけのPostCSSプラグインを書き、それをconcatした後に使うことにした。</p>

<p>PostCSSプラグインとして作ったのでパブリックなAPIはない。つまり必ずPostCSSの<code>use()</code>でプロセッサーとして読み込んでやる必要がある。</p>

<pre><code>var fs = require(&#39;fs&#39;);
var postcss = require(&#39;postcss&#39;);

var input = fs.readFileSync(&#39;input.css&#39;, &#39;utf8&#39;);
var output = postcss().use(
  require(&#39;postcss-single-charset&#39;)()
).process(input).css;
fs.writeFileSync(&#39;output.css&#39;, output);
</code></pre>

<p>PostCSSを知らないとよくわからないと思うけど、PostCSS界隈ではこれで普通な感じということになっている。実際には<a href="https://github.com/nDmitry/grunt-postcss">grunt-postcss</a>や<a href="https://github.com/w0rm/gulp-postcss">gulp-postcss</a>経由で使うことになるだろう。</p>

<p>利用サンプルを兼ねてGruntプラグインも同梱しておいた。<code>grunt-</code>プリフィックスが付いていないため、<a href="https://github.com/sindresorhus/load-grunt-tasks">load-grunt-tasks</a>では読み込んでくれない(と思う)ので、READMEにあるように書いてちゃんと読み込む必要がある。他は特に変なことはないが、あまり行儀良くはなさそうなので利用は非推奨ということにしておく。</p>

<hr>

<p>あんまりパッケージ化するつもりはなかったけど、PostCSSプラグインというような形で書いたことがなかったので試しに書いてみた。特に何ということもなかった。</p>]]></content:encoded>
    </item>

    <item>
      <title>ウェブ・フォントの読み込み</title>
      <link>http://hail2u.net/blog/webdesign/loading-web-fonts.html</link>
      <description>ウェブ・フォントも完全に行き渡り、今はどう効率的に配信するかについて多くの時間を割くようになった。Google Fontsの低め安定路線を見限り、TypeKitやFonts.comへ鞍替えする人々も増えた。それと同時に自前でホスティングする人々も徐々にその数を増やしており、どれが最適解なのか一応の結論が出るにはもう少しかかるだろう。まず、ウェブ・フォントの読み込みにおいてどのようなアプローチがあり、どのようなメリット、そしてデメリットがあるのだろうか。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/loading-web-fonts.html</guid>
      <pubDate>Fri, 09 Jan 2015 13:10:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>ウェブ・フォントも完全に行き渡り、今はどう効率的に配信するかについて多くの時間を割くようになった。Google Fontsの低め安定路線を見限り、TypeKitやFonts.comへ鞍替えする人々も増えた。それと同時に自前でホスティングする人々も徐々にその数を増やしており、どれが最適解なのか一応の結論が出るにはもう少しかかるだろう。まず、ウェブ・フォントの読み込みにおいてどのようなアプローチがあり、どのようなメリット、そしてデメリットがあるのだろうか。</p>

<p>TypeKit等に頼るにしろ、自前でホスティングするにしろ、もちろん最終的にはウェブ・フォントをブラウザーに送りつける必要がある。読み込みとはまさにその部分の話だ。話がややこしくなるので、<a href="http://hail2u.net/documents/bulletproof-at-font-face-syntax.html">多様な実装を意識した安全な書き方</a>などについては触れない。</p>

<h2>普通に@font-face定義を利用</h2>

<p><code>@font-face</code>定義をただ普通に書く場合のメリットは、基本的な知識さえあれば書けることと動かなくなる可能性が最小限に抑えられることだ。CSSが単純であることから、書きやすく、組み込みやすく、修正もしやすい。将来的に仕様が大きく変化した場合でも、実装がそれなりにフォローしてくれることも期待できるだろう。</p>

<p>デメリットは読み込みコストの増加と初期描画の遅延だ。</p>

<p>読み込みコストの増加は単純に大きめの画像へのリクエストが常に行われるということでもあるし、メモリーの圧迫ということでもある。機器の進化と環境の発展が解消してくれるであろう問題であるとも言えるが、歴史を振り返ると常に汲々として対策を練らなくてはいけない類いの問題であったので、そうはたやすく解決されないだろう。</p>

<p>初期描画の遅延は、古くからFOUTと呼ばれ問題視されていた現象についてがまず挙げられる。だいたいはFOUTが起こらないように実装が変化した。ウェブ・フォントのリクエストに失敗していそうな時も3秒でフォールバック・フォントで表示されるように統一されつつあるので、あまり問題ではなくなりそうだ。</p>

<p>しかし、3秒間文字がまったく表示されない状態が続く、と考えると致命的な遅延とも言える。実際にはCSSファイルの肥大化による遅延も重なり、空白の状態からやっと表示されたら今度は文字が見えないという状態に変化するため、ユーザーへはなかなかの違和感を与えることになる。</p>

<h2>DataURIを使ったsrc記述子の指定</h2>

<p>メリットはウェブ・フォントが必要な場合には必ず既に読み込み済みになっていることだ。つまりCSSファイルが読み込まれたならウェブ・フォントが適用されるだろうし、何らかの理由でCSSファイルの読み込みに失敗した場合でも文字だけ見えないというような状態には決してならない。またCSSだけで完結するのも大きいだろう。残念ながらツールの助けは必要になるだろうが、特にHTMLやJavaScriptの助けは必要としない。</p>

<p>デメリットはCSSファイルの肥大化だ。英数記号のみの欧文タイプフェイスのウェブ・フォントであったとしてもウェイトごとに30KBほど、和文のそれになると少なくともウェイトごとに300–1000KB前後がCSSファイルに追加されることになる。これは単にCSSファイルの読み込み自体に時間がかかるということだけではなく、そのパースに時間がかかるということでもある。つまりウェブページの描画され始めるまでに時間がかかってしまうということだ。</p>

<p>ウェブ・フォントに限らず巨大なData URIをCSSファイルに混ぜ込むのは悪手と言って良い。せいぜい2KB前後までのSVGファイルくらいなものだろう。</p>

<h2>ウェブ・フォントのCSSの遅延読み込み</h2>

<p>初期描画を遅延させないためには、JavaScriptファイルの非同期読み込みと同じように、ウェブ・フォントの読み込みとウェブページの描画を同時に行わせれば良い。CSSファイルに<code>@font-face</code>定義を書かず、<code>head</code>要素の子としても書かないことによって、遅延読み込みさせることに成功すれば、ウェブ・フォント由来の初期描画の遅延は限りなく少なくなる。</p>

<p>このデメリットはFOUTと呼ばれ、問題視されていた古いFirefoxの挙動と同じになることだ。まずフォールバックとして指定されたローカルのフォントで表示され、ウェブ・フォントの読み込みが完了した後にフォントが変更になるため、その切り変わる時に画面がフラッシュする。読み込みが終わるまで文字がまったく表示されないよりはフラッシュすることの方がまだ良いだろうというネガティブな選択の結果の手段ということになる。</p>

<p>また残念ながらCSSだけでは完結しない。JavaScriptを使うか、文法違反であることに目をつぶって<code>body</code>要素の最後にウェブ・フォントを読み込むための<code>link</code>要素を突っ込む必要がある。</p>

<h2>Web Font Loader</h2>

<p>遅延読み込みを一歩進め、フォントの読み込みを監視することにより、FOUTを制御できるようにしたのが<a href="https://github.com/typekit/webfontloader">Web Font Loader</a>だ。ウェブページの描画をブロックする・しないを選択できるので、好みで柔軟に描画のされ方を調節できる。CSSだけで完結とまではいかないが、制御ロジックそのものはクラス名を通してCSSで行えるので、保守性は高い。</p>

<p>標準化されている<a href="http://www.w3.org/TR/css-font-loading/">CSS Font Loading Module Level 3</a>を利用することになる将来も、これと同じようなアプローチになることが予想される。Polyfillとは言えないが、ウェブ標準と親和性が高いものとは言えるだろう。</p>

<p>デメリットはこれまでに上げた手法の高度なラッパーに過ぎないということだ。柔軟でカスタマイズしやすいことは確かだが、このライブラリーに強く依存することを強いられる。名前を挙げることも憚られる某ライブラリーと似たような立ち位置のものと言うと近い。</p>

<h2>Web Storageを使ったキャッシング</h2>

<p>読み込みをインターネット経由で行うことがウェブ・フォントにおける多くの問題の原因である以上、高速に取り出せるローカルにキャッシュがあれば良いというのが骨子となる。<a href="http://www.w3.org/TR/webstorage/">Web Storage (いわゆる<code>localStorage</code>)</a>を使いウェブ・フォントをキャッシングさせれば、インターネットを経由せずに済む。想定通りうまく動けば初期描画の遅延とFOUTという二つの大きな問題は解決される。</p>

<p>Web Storageの実装を見るに、保守性は非常に悪いといえるだろう。キャッシュのリフレッシュまでも視野に入れると更に厳しい。利用を単純化したライブラリーがあれば一瞬光ることはありそうだが、環境の変化(SPDY)により無に帰してしまいそうな技術とも思える。</p>

<hr>

<p>このウェブサイトでもFOUT強制をやめることにした過程で調べたり考えたりしたことを、読み込みの部分だけに特化してざっとまとめてきた。一長一短であるが、それでもあえて選択するとしたらWeb Font Loaderではないかと僕は考える。現状で最も柔軟であることは、軌道修正をする際に非常に助かる。依存しすぎないこととその挙動をしっかりと知ることを念頭に置いてWeb Font Loaderを使うのが良いだろう。</p>

<p>ウェブ・フォントの利用にあたってはその読み込みが最も重要な部分であることは確かだが、他にも考慮すべき点は色々ある。例えばブランド・ロゴに専用のウェブ・フォントを利用する場合は別のタイプフェイスで表示されるということは許されない。その場合はフォールバックさせず、画像を代わりに表示する必要があることだろう。そういう場合は読み込みについては特に凝ったことをしない方がやりやすい可能性も高い。</p>

<p>ともあれ、ウェブ・フォントの利用はウェブサイトへ大きな変化をもたらす。それは見た目だけではなくパフォーマンスについても、だ。そのことの重要な一柱である読み込みについてはしっかりと考えて実装してやる必要があるだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>2015年の目標</title>
      <link>http://hail2u.net/blog/misc/my-2015-manifest.html</link>
      <description>今年は「夜の歯みがきに10分以上かける」ということに決めた。上に5分、下に5分かけていきたい。できれば15分くらいかける習慣にしたいが、いきなりは難しそうなので徐々に伸ばしていくつもりだ。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/my-2015-manifest.html</guid>
      <pubDate>Thu, 08 Jan 2015 15:27:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>今年は「夜の歯みがきに10分以上かける」ということに決めた。上に5分、下に5分かけていきたい。できれば15分くらいかける習慣にしたいが、いきなりは難しそうなので徐々に伸ばしていくつもりだ。</p>

<p>今はまだ5分くらいしかかけていない。普通の歯ブラシだと洗面所以外でやるのは難しそうなので、電動歯ブラシを買ってだらだらやるのが良さそうな気がする。いずれにしてもまずはゆっくりやることを習慣づけたい。</p>

<hr>

<p><a href="http://hail2u.net/blog/misc/my-2014-manifesto.html">去年の目標</a>の達成率は7割くらいだった。食欲、特に風呂後のそれにはなかなか勝てない。自然と早くに寝て誤魔化すという形になりがちだった。結果として早起きすることが増えたので、これはこれで良かったのかもしれない。</p>

<p>生活習慣のようなものはすっぱり変えるという具合にはいかない。このような感じで一年くらいかけてゆっくり変えていくのは今後も続けていこう。</p>]]></content:encoded>
    </item>

    <item>
      <title>HTTPからHTTPSへ</title>
      <link>http://hail2u.net/blog/internet/http-to-https.html</link>
      <description>HTTPSへの移行が今年は加速するだろうというのは言うまでもないが、それに伴い起こりうる事象については真っ二つな印象がある。僕は特にもうCool URIとか言いたくないので、301すれば良いだろう派だ。HTTPSという記事ではそれはおいておいてブラウザーのデフォルトは変えるべきなのかなど、移行の加速がもたらす環境の変化について指摘している。</description>
      <category>Internet</category>
      <guid isPermaLink="true">http://hail2u.net/blog/internet/http-to-https.html</guid>
      <pubDate>Wed, 07 Jan 2015 08:08:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>HTTPSへの移行が今年は加速するだろうというのは言うまでもないが、それに伴い起こりうる事象については真っ二つな印象がある。僕は特にもうCool URIとか言いたくないので、301すれば良いだろう派だ。<a href="https://adactio.com/journal/8100">HTTPSという記事</a>ではそれはおいておいてブラウザーのデフォルトは変えるべきなのかなど、移行の加速がもたらす環境の変化について指摘している。</p>

<p>ブラウザーのデフォルトは早々にHTTPSに変わるものとそうでないものに分かれるのだろうか。プロトコル・スキームを表示しなくなって久しいし、セキュアではないウェブページで警告を出す方が理に適ってはいる。しかしコストゼロで移行が行えない以上、HTTPのウェブサイトがあたかもフィッシングやスパムのウェブサイトと同列に見られかねない状況が強制されるのはかなり厳しい。</p>

<p>そうなると「この警告は問題ありません！」といったお知らせをすべてのウェブページに突っ込む、というような展開もありえそう。ぞっとしない未来だ。</p>

<p>また、HTTPからHTTPSへリダイレクトを設定し、単純にURLとおぼしきものからすべてプロトコル・スキームを削除するだけでは解決できない部分もある。例えばFacebookなどが利用しているOGPやはてなブックマークのようなHTTPSを厳密に区別するウェブサービスだ。</p>

<p>OGPでは<code>meta</code>要素を使ってURLも表現するので、スキームを省略することはできない。移行の際にはすべてのページの<code>og:url</code>を書き換える必要がある。また移行と同時に既存のいいね！を失う(かもしれない)。はてなブックマークでも似たようなことが起こりうる。それぞれウェブサービス側の慎重な対応(HTTPとHTTPSの同一視ではなく301の解釈？)が必要になる。</p>

<hr>

<p>僕はそれでも今年中にこのウェブサイトはHTTPSに移行させたいな、と考えている。CloudFlareを使って頑張るとどこまでいけるのかみたいな実験でもあるが、小さなウェブサイトをHTTPSで運営するという今までにほとんどなかったケースをもうちょっと詳しく学びたいのが大きい。</p>]]></content:encoded>
    </item>

    <item>
      <title>RUBYOPTを使った外部エンコーディングの指定</title>
      <link>http://hail2u.net/blog/webdesign/setting-rubyopt-for-sass.html</link>
      <description>今年からSassでcontentプロパティーなどでマルチバイトの文字列をエスケープせずにばしばし書くことにしたので、遂にWindowsでもUTF-8をデフォルトにしないとダメそうな感じになった。この場合、環境変数LANGを変えようとか良く書かれているけれど、Ruby以外に影響を及ぼさない真っ当な手段としてはRUBYOPTの方を使うべきなようだ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/setting-rubyopt-for-sass.html</guid>
      <pubDate>Tue, 06 Jan 2015 08:48:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>今年からSassで<code>content</code>プロパティーなどでマルチバイトの文字列をエスケープせずにばしばし書くことにしたので、遂にWindowsでもUTF-8をデフォルトにしないとダメそうな感じになった。この場合、環境変数<code>LANG</code>を変えようとか良く書かれているけれど、Ruby以外に影響を及ぼさない真っ当な手段としては<code>RUBYOPT</code>の方を使うべきなようだ。</p>

<p>特に設定していないとマルチバイト文字列を含むSassファイルをコンパイルしようとすると以下のようなエラーメッセージを吐いて落ちる。</p>

<pre><samp>C:\&gt;<kbd>scss test.scss</kbd>
Error: Invalid Windows-31J character &quot;\xE2&quot;
        on line 2 of test.scss
  Use --trace for backtrace.
</samp></pre>

<p><code>test.scss</code>の2行目には<code>➔</code>が含まれている。このファイルに<code>@charset "UTF-8";</code>を追加することでも正常にコンパイルされるようになるが、Sass(やRuby)はUTF-8で書くので、ユーザーワイドに設定してやった方が省力化を図れる。</p>

<pre><samp>C:\&gt;<kbd>set RUBYOPT=--encoding=UTF-8</kbd>

C:\&gt;<kbd>scss test.scss</kbd>
@charset &quot;UTF-8&quot;;
.test {
  content: &#39;➔&#39;; }
</samp></pre>

<p><code>RUBYOPT</code>環境変数で<code>--encoding</code>オプションを指定してやることで、外部エンコーディングをUTF-8に強制すると動くようになる。動作が確認できたら、あとはシステムのプロパティーからユーザー環境変数に仕込んでやれば良い。</p>

<figure>
  <img alt="システムのプロパティーのダイアログよりユーザー環境変数へRUBYOPTを追加している様子" src="http://hail2u.net/images/blog/setting-rubyopt-environment-variable.png">

  <figcaption>ユーザー環境変数の設定ダイアログ</figcaption>
</figure>

<p>なお、今のSassは非ASCII文字列があると、適切な値の<code>@charset</code>ディレクティブを必ず追加するようになっている。先頭の<code>@charset &quot;UTF-8&quot;;</code>を削除したい場合は何かしら別のツールに頼る必要がある。</p>

<hr>

<p>マルチバイト文字列をそのまま書くことにしたのにはいくつか理由があるが、一番大きいのはエスケープされた文字列は人間が書くべきものではないということだ。<code>\0020</code>とか書いているとバカバカしくなる。それ以外にももちろんわかりやすくなることとか、わざわざコメントでどういう文字のエスケープなのかとか書かなくて済むこととか。ただし見てもなにかわからない非改行スペースのようなものだけはエスケープする、というルールにした。</p>]]></content:encoded>
    </item>

    <item>
      <title>名前を付けることの難しさ</title>
      <link>http://hail2u.net/blog/webdesign/naming-things-is-really-hard.html</link>
      <description>名前をつけることの難しさについて、実際にどうして格闘してやればよいのかについて書かれたNaming Thingsという記事を読み返した。中心となるのはCSSにおけるクラス名で、SUIT CSSの命名規則を取り上げて、わかりやすさ・明白さ・機能性・一貫性・適切さ・拡張性・短さと若干のジョークが許されるゆるさのようなものが重要であるとしている。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/naming-things-is-really-hard.html</guid>
      <pubDate>Mon, 05 Jan 2015 06:14:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>名前をつけることの難しさについて、実際にどうして格闘してやればよいのかについて書かれた<a href="http://24ways.org/2014/naming-things/">Naming Things</a>という記事を読み返した。中心となるのはCSSにおけるクラス名で、<a href="https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md">SUIT CSSの命名規則</a>を取り上げて、わかりやすさ・明白さ・機能性・一貫性・適切さ・拡張性・短さと若干のジョークが許されるゆるさのようなものが重要であるとしている。</p>

<p>BEMから一歩進める(か下がる)時期ではあると思うが、なかなかとっかかりがなかった。この記事をもう一度くらい読んで、今年中にどう変えていくのかをちゃんと考えていきたい。SUIT CSSの命名規則はPascalCaseとcamelCaseが混じるところがあんまり好きじゃないので、別の何かが産み出せれば良いかなと思う。大文字使いたくないというのもちょっとある。</p>

<hr>

<p>僕にはこの記事が今年の<a href="http://24ways.org/">24 ways</a>で最も良かった記事だった。他にも<a href="http://24ways.org/2014/seo-in-2015-and-why-you-should-care/">SEOのようなそうでないような話</a>や<a href="http://24ways.org/2014/taglines-and-truisms/">タグラインの話</a>(これを読んだ後にホームのタグラインを復活させた)も良かったが、実践性と哲学性のバランスでNaming Thingsが一番だったと思う。</p>]]></content:encoded>
    </item>

    <item>
      <title>HTMLHintをSyntasticで使う</title>
      <link>http://hail2u.net/blog/software/htmlhint-in-syntastic.html</link>
      <description>重い腰を上げてVimでSyntasticを使うようにした。となるとHTMLHintを使いたいのだけど、対応してなかったので自分でチェッカー定義を書くところから始めた。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/htmlhint-in-syntastic.html</guid>
      <pubDate>Sun, 04 Jan 2015 08:58:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>重い腰を上げてVimで<a href="https://github.com/scrooloose/syntastic">Syntastic</a>を使うようにした。となると<a href="https://github.com/yaniswang/HTMLHint">HTMLHint</a>を使いたいのだけど、対応してなかったので自分でチェッカー定義を書くところから始めた。</p>

<figure>
  <img src="http://hail2u.net/images/blog/htmlhint-in-syntastic.png" alt="HTMLHintでのチェックの結果がガッターとバルーンヘルプで表示されている">

  <figcaption>Runnnig HTMLHint with Syntastic</figcaption>
</figure>

<p>今のところ<a href="https://github.com/scrooloose/syntastic/pull/1280">チェッカー定義を追加したプルリクエスト</a>が取り込まれる気配はない。</p>

<hr>

<p>Syntasticはそのままだと辛いことが多い気がする。汎用にした弊害か。CSSLintはルールをカスタマイズしづらいし、perlcriticはWindowsで死ぬ。そういったものをひとつひとつ潰すのは難しいし、好みの設定をできるようにすると保守できなくなる。適当なディレクトリーに置いたチェッカー定義を自動で読み込んでくれる(ビルトインのそれとバッティングしたら上書きしてくれる)機能などがあれば良いような気がした。ありそう。</p>

<h2>追記</h2>

<p>他のところにあるチェッカー定義は<a href="https://github.com/scrooloose/syntastic/wiki/Syntax-Checker-Guide#6-external-checkers">external checkers</a>という仕組みで実現できるようだ。こっちでやってみよう。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
