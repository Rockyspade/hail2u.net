<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Fri, 6 Mar 2015 09:23:09 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>Rhodia dotPad</title>
      <link>http://hail2u.net/blog/gadget/rhodia-dotpad.html</link>
      <description>ドット方眼に目覚めてから愛用しはじめたRHODIAのdotPadの二代目をおろした。僕が使っているのは最小サイズのNo.12で270円。もちろんオレンジ。</description>
      <category>Gadget</category>
      <guid isPermaLink="true">http://hail2u.net/blog/gadget/rhodia-dotpad.html</guid>
      <pubDate>Fri, 06 Mar 2015 09:23:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="http://www.amazon.co.jp/gp/product/B00JO1JCKK/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00JO1JCKK&amp;linkCode=as2&amp;tag=hail2unet-22"><img alt="ロディア ドットパッド No.12 オレンジ 2冊セット" height="228" src="/images/blog/rhodia-dotpad.jpg" width="2216"></a>
</figure>

<p><a href="/blog/software/dot-grid-and-line-grid.html">ドット方眼</a>に目覚めてから愛用しはじめた<a href="http://www.amazon.co.jp/gp/product/B00JO1JCKK/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00JO1JCKK&amp;linkCode=as2&amp;tag=hail2unet-22">RHODIAのdotPad</a>の二代目をおろした。僕が使っているのは最小サイズのNo.12で270円。もちろんオレンジ。</p>

<p>書き味はRhodiaらしいやつで、ボールペンや鉛筆に向いてる。万年筆(Lamy)とはちょっと相性悪いような気がする。切りはなしやすさもRhodiaと同じ。ただゆがみはないものの、線方眼のものよりも方眼の位置に個体差があるような気がする。気になる場合は文具店で実物確認して買うのが良さそう。</p>

<p>表紙は耐水性がちょっとある。そのための加工のお陰で手触りもスベスベで、長期間使ってもあまり劣化してこない。。裏表紙も同じ。裏表紙の内側には厚めのボール紙が台紙として更にあって、手で持ってる時も安定して書けるという謳い文句通り、しっかりしてる。</p>

<p>ホッチキス留めだけど裏にホッチキス針の先が出てこないとかそういうあたりもちゃんとRhodiaクオリティー。かなり丈夫な方だとは思うけど、やはり端はヘナヘナになってしまう。カバーが欲しい気もするけど、うーん。</p>]]></content:encoded>
    </item>

    <item>
      <title>モバイル版とデスクトップ版、そしてレスポンシブ・ウェブ・デザイン</title>
      <link>http://hail2u.net/blog/webdesign/mobile-version-desktop-version-and-responsive-web-design.html</link>
      <description>専用バージョンのウェブサイトとレスポンシブ・ウェブ・デザインによるウェブサイトの優劣が語られることは多い。そういった場合、どちらが優れているのか、またはどちらが劣っているのか、を思想的な面でも技術的な面でも比較される。その過程で両者があたかも排他的な関係であるようによく語られるが、両者が解決するもの、したいものは違う。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/mobile-version-desktop-version-and-responsive-web-design.html</guid>
      <pubDate>Thu, 05 Mar 2015 09:05:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>専用バージョンのウェブサイトとレスポンシブ・ウェブ・デザインによるウェブサイトの優劣が語られることは多い。そういった場合、どちらが優れているのか、またはどちらが劣っているのか、を思想的な面でも技術的な面でも比較される。その過程で両者があたかも排他的な関係であるようによく語られるが、両者が解決するもの、したいものは違う。</p>

<p>単一のHTMLやCSSで完結することや、それに伴うテストの簡略化や不可欠なツールの削減あたりが、レスポンシブ・ウェブ・デザインがもたらす主なものだろう。もしかするとバックエンドとのやりとりもシンプルにできるかもしれない。つまりコードやビジュアル・デザインのレベルではなく、ウェブサイトの構築というレベルにおいてシンプルにしてくれるということだ。</p>

<p>レスポンシブ・ウェブ・デザインは主にこういった<em>コンテンツとウェブページの間</em>における問題を解決するために採用するものだ。</p>

<p>その一方でウェブページとユーザーの間にある問題を解決することはレスポンシブ・ウェブ・デザインではできない。あるユーザーが複数の端末で閲覧した場合に、一貫性ある体験を提供できることに留まるだろう。無意味ではないが、それだけでは不十分だ。このようなウェブページとユーザーの間にある問題は、ビジュアル・デザインよりももう少し上流にあるデザインにおいて解決されるものだ。</p>

<p>専用バージョンのウェブサイトは、まさにこのあたりを解決するために設計し、作るものだ。場合によってはウェブサイトではなくモバイル・アプリになるかもしれない。</p>

<hr>

<p>少なくとも<em>複数の</em>専用バージョンのウェブサイトを運用する意味はもはやなく、運用や保守におけるコストという点でも魅力的ではないだろう。であるならレスポンシブ・ウェブ・デザインを採用することで、メイン・ターゲット層以外を漸進的にサポートすることは理に適っているはずだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>単一のvar宣言とセミコロンの自動補完</title>
      <link>http://hail2u.net/blog/coding/single-var-pattern-and-automatic-semicolon-insertion.html</link>
      <description>ESLintできれいに拾えるので、スコープ内でvarの先頭出しをやるようにしようかなという気分になっている。その過程でA criticism of the Single Var Pattern in JavaScript, and a simple alternativeという記事を読んだ。デバッガーでステップ実行しづらいという話はともかく、カンマ忘れでセミコロンの自動補完が起こり、変数のグローバル化をもたらしてしまうというのは印象的だった。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/single-var-pattern-and-automatic-semicolon-insertion.html</guid>
      <pubDate>Wed, 04 Mar 2015 07:18:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>ESLintできれいに拾えるので、スコープ内で<code>var</code>の先頭出しをやるようにしようかなという気分になっている。その過程で<a href="http://danhough.com/blog/single-var-pattern-rant/">A criticism of the Single Var Pattern in JavaScript, and a simple alternative</a>という記事を読んだ。デバッガーでステップ実行しづらいという話はともかく、カンマ忘れでセミコロンの自動補完が起こり、変数のグローバル化をもたらしてしまうというのは印象的だった。</p>

<pre><code>var foo = &#39;Foooo&#39;
  bar = &#39;Barrr&#39;,
  baz = &#39;Bazzz&#39;;
</code></pre>

<p>このように一行目のカンマを忘れてしまうと、意図せず<code>bar</code>と<code>baz</code>がグローバル変数になってしまう。この手のエラーもリンターで拾えるとはいえ、見逃してしまった時のことを考えると、こうは書きたくなくなる。</p>

<hr>

<p>最終行がコメントアウトしづらいというような瑣末な問題があることはなんとなく知ってはいたが、ちょっとしたミスが大きなバグへつながるということは知らなかった。<code>var</code>の先頭出しは単一の<code>var</code>宣言で行うものかと思っていたけれど、このあたりにも色々微妙な点があるようだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>media_query_listのパース</title>
      <link>http://hail2u.net/blog/coding/parsing-media-query-list.html</link>
      <description>Media Queriesの各クエリーは、featureとexpのセットもしくはmedia_typeでexpressionが、expressionをandで繋いでmedia_queryが、media_queryをカンマで繋いでmedia_query_listになり、それで完成する。そこそこ正確にパースしてJavaScriptから扱えるようにするためには、まずカンマで区切り、更にandキーワードまたはスペースで区切り、更に同じfeatureがあることを考慮した多次元配列に変換してやる必要がありそうだ。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/parsing-media-query-list.html</guid>
      <pubDate>Tue, 03 Mar 2015 07:34:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Media Queriesの各クエリーは、<code>feature</code>と<code>exp</code>のセットもしくは<code>media_type</code>で<code>expression</code>が、<code>expression</code>を<code>and</code>で繋いで<code>media_query</code>が、<code>media_query</code>をカンマで繋いで<code>media_query_list</code>になり、それで完成する。そこそこ正確にパースしてJavaScriptから扱えるようにするためには、まずカンマで区切り、更に<code>and</code>キーワードまたはスペースで区切り、更に同じ<code>feature</code>があることを考慮した多次元配列に変換してやる必要がありそうだ。</p>

<p>まず存在しなさそうだが、以下のようなクエリーも理論上はありうる。</p>

<pre>only
  screen and
  (min-width: 1em) and
  (min-width: 2em),
not
  (min-width: 3em) and
  (min-height: 4em) and
  (min-height: 5em)
</pre>

<p>例えばこのようなクエリーを以下のようにできれば良さそうだ。</p>

<pre><code>var mediaQueryList = [
  {
    &#39;min-width&#39;: [&#39;1em&#39;, &#39;2em&#39;],
    &#39;only&#39;: true,
    &#39;screen&#39;: true
  },
  {
    &#39;min-height&#39;: [&#39;4em&#39;, 5em&#39;],
    &#39;min-width&#39;: [&#39;3em&#39;],
    &#39;not&#39;: true
  }
];
</code></pre>

<p>こうするための実装を書いているけどすごい面倒くさくて嫌になってきている。<code>min-width</code>が複数回出てきても良いとか想定していなかった。</p>

<hr>

<p>パースは出来たとしてもどう扱ってソートするかでまた面倒くさい。<code>min-width</code>に絞っていても<code>media_query</code>の中で<em>最大</em>かつその中で<em>最小</em>を基準にソートする必要がありそうだ。他に<code>print, (min-width: 1em)</code>みたいなものの判断も難しい。もうちょっと時間かかりそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>node-feedmix</title>
      <link>http://hail2u.net/blog/coding/node-feedmix.html</link>
      <description>xml2jsを使って複数のRSS 2.0をマージするパッケージ、FeedMixを作った。手元で結構前から使っていたGruntタスクをNode.jsパッケージにして、それを叩くだけのGruntタスクを同梱するという形にした。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/node-feedmix.html</guid>
      <pubDate>Mon, 02 Mar 2015 06:26:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/Leonidas-from-XIV/node-xml2js">xml2js</a>を使って複数のRSS 2.0をマージするパッケージ、<a href="https://github.com/hail2u/node-feedmix">FeedMix</a>を作った。手元で結構前から使っていたGruntタスクをNode.jsパッケージにして、それを叩くだけのGruntタスクを同梱するという形にした。</p>

<p>混ぜたいRSSファイルを配列として<code>merge()</code>の引数に指定する。XMLファイルではない場合はxml2jsが、RSSファイルではなさそうな場合はFeedMixがそれぞれ例外を吐いて落ちる。落ちる。</p>

<pre><code>var feedmix = require(&#39;feedmix&#39;);
var fs = require(&#39;fs&#39;);

var a = f.readFileSync(&#39;a.rss&#39;, &#39;utf8&#39;);
var b = f.readFileSync(&#39;b.rss&#39;, &#39;utf8&#39;);
var c = f.readFileSync(&#39;c.rss&#39;, &#39;utf8&#39;);
var m = feedmix.merge([a, b, c], {
  trim: true
});
</code></pre>

<p>これで<code>m</code>の中身が<code>b.rss</code>と<code>c.rss</code>のすべての<code>item</code>要素を<code>a.rss</code>へ混ぜ込んだJavaScriptオブジェクトになる。<code>item</code>は<code>pubDate</code>要素の値を使ってソートされるが、切り詰められたりはしない。<code>channel</code>要素は<code>a.rss</code>のものが採用されるが、<code>lastBuildDate</code>要素の値のみ最初の<code>item</code>要素の<code>pubDate</code>要素の値がコピーされ書き換えられる。</p>

<pre><code>console.log(feedmix.stringify(m, {
  cdata: true,
  xmldec: {
    encoding: &#39;UTF-8&#39;,
    version: &#39;1.0&#39;
  }
}));
</code></pre>

<p>XMLへの変換は<code>stringify()</code>へパース結果のオブジェクトを渡して行う。xml2jsのビルダーの単なるラッパーで、特に何もしない。</p>

<p>また<code>merge()</code>では第二引数にxmljsのパーサーのオプションが、<code>strigify()</code>ではxml2jsのビルダーのオプションがそれぞれ指定できる。ただしパーサーの<code>explicitArray</code>オプションはパース後のオブジェクトの構造を変えてしまうので、強制的に<code>true</code>にしているため指定しても効果はない。他にも指定するとおかしくなるオプションがあるかもしれない。</p>

<hr>

<p>同梱されているGruntタスクも凝ってはいない。</p>

<pre><code>feedmix: {
  main: {
    options: {
      builder: {
        cdata: true,
        xmldec: {
          encoding: &#39;UTF-8&#39;,
          version: &#39;1.0&#39;
        }
      },

      parser: {
        trim: true
      }
    },

    dest: &#39;build/feed&#39;,
    src: [
      &#39;src/feed/index.rss&#39;,
      &#39;build/blog/feed&#39;
    ]
  }
}
</code></pre>

<p>こちらは<code>src</code>でファイルを指定してやると<code>dest</code>にマージした結果を吐いてくれる。動的マッピングだと配列の順序が思ったようにいかない可能性があるので、普通に指定したほうが良いだろう。<code>options.builder</code>と<code>options.parser</code>経由で<code>stringify()</code>と<code>merge()</code>に渡すオプションを指定することはできるので、入出力もモジュールと同等に制御することができる。</p>

<hr>

<p>RSS 1.0とかAtomとかもうよく知らないので無視した。RSS 0.9xなどは通ってしまいそうな気がする。</p>]]></content:encoded>
    </item>

    <item>
      <title>indexのマークアップとpermalinkのマークアップ</title>
      <link>http://hail2u.net/blog/webdesign/index-markup-and-permalink-markup.html</link>
      <description>何らかのツールでテンプレートを元にページを生成する昨今、あまりページごとに大きくアウトラインの構造(変な表現だ)が変わることはない。枠を作って流し込む、枠を作って流し込む、というわけだ。ウェブではコンテンツは主に文章であるので、流動性はそれなりに高く、流しこむこと自体は多くの場合は問題にならないが、もうちょっと考えても良い所ではある。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/index-markup-and-permalink-markup.html</guid>
      <pubDate>Sun, 01 Mar 2015 03:49:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>何らかのツールでテンプレートを元にページを生成する昨今、あまりページごとに大きくアウトラインの構造(変な表現だ)が変わることはない。枠を作って流し込む、枠を作って流し込む、というわけだ。ウェブではコンテンツは主に文章であるので、流動性はそれなりに高く、<em>流しこむこと</em>自体は多くの場合は問題にならないが、もうちょっと考えても良い所ではある。</p>

<p>典型的なウェブログのindexのページは以下のような構造になっていることだろう。</p>

<ul>
<li><code>header</code></li>
<li><code>main</code><ul>
<li><code>article</code></li>
<li><code>article</code></li>
<li><code>article</code></li>
</ul>
</li>
<li><code>footer</code></li>
</ul>

<p>これから自身以外の<code>article</code>要素を取り除いたものがpermalinkのページ構造になる。</p>

<ul>
<li><code>header</code></li>
<li><code>main</code><ul>
<li><code>article</code></li>
</ul>
</li>
<li><code>footer</code></li>
</ul>

<p>この時点で<code>main</code>要素でグルーピングする意味はほとんどなくなる。合わせてpermalinkでは文書のプライマリ・コンテンツはこの<code>article</code>要素の中身であり、それが唯一であることを考えると<code>article</code>要素を使うのは冗長だ。<a href="http://www.w3.org/TR/html5/sections.html#the-article-element">仕様の<code>article</code>要素の項</a>でもこのことは触れられている。</p>

<p>かといってコード・レベルでの階層構造をフラットに変更するのはコスト(主にスタイリングにおいて)が高い。そこで論理構造を持ついくつかの要素を<code>div</code>要素に変更してやるのはどうだろうか。</p>

<ul>
<li><code>div[role=&quot;banner&quot;]</code></li>
<li><code>div</code><ul>
<li><code>div[role=&quot;main&quot;]</code></li>
</ul>
</li>
<li><code>footer</code></li>
</ul>

<p><code>article</code>要素というセクションを作る要素がなくなるため<code>header</code>要素も変更してやる必要がある。HTMLコードそのものとしてはほとんど変わりがなく、かつHTML5らしくなく見えるため、なんとなく美しくない気もするが、アウトライン構造はすっきりとする。</p>

<hr>

<p>こうしてやるとロゴで<code>h1</code>要素を使っていなくてもUntitled Sectionとみなされなくなるのもポイントが高い。むしろそのためにひねり出した感がある。悪い解ではないはずなので、しばらくはこれで行ってみよう。</p>]]></content:encoded>
    </item>

    <item>
      <title>JavaScriptをビルドするJavaScript</title>
      <link>http://hail2u.net/blog/coding/javascript-for-building-javascript.html</link>
      <description>たまには素でJavaScriptファイルをビルドすることも考えないと頭がダメになりそう。他にgulpとかでかすぎるし、npm run-scriptだけでいけるいけるみたいな話を先行者以外からも聞くようになったので、そっちに比重を移すことも視野に入れたいとか。僕はビルド・ツールをnpm run-scriptで薄くラップする手法というのが現実的だと考えてて、それを確認したいというのもあった。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/javascript-for-building-javascript.html</guid>
      <pubDate>Sat, 28 Feb 2015 12:52:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>たまには素でJavaScriptファイルをビルドすることも考えないと頭がダメになりそう。他にgulpとかでかすぎるし、<code>npm run-script</code><em>だけ</em>でいけるいけるみたいな話を先行者以外からも聞くようになったので、そっちに比重を移すことも視野に入れたいとか。僕は<a href="http://qiita.com/Jxck_/items/efaff21b977ddc782971">ビルド・ツールを<code>npm run-script</code>で薄くラップする手法</a>というのが現実的だと考えてて、それを確認したいというのもあった。</p>

<p>依存はnpmやBowerで解決している前提で、自前で書いたものを最小化し、依存と連結するようなものを想定しておく。つまり、</p>

<ul>
<li>node_modules/foo/dist/foo.min.js</li>
<li>src/js/bar.js</li>
<li>src/js/baz.js</li>
</ul>

<p>を<code>build/js/main.min.js</code>へとビルドするくらいにしておく。</p>

<pre><code>#!/usr/bin/env node

&#39;use strict&#39;;

var async = require(&#39;async&#39;);
var fs = require(&#39;fs-extra&#39;);
var path = require(&#39;path&#39;);
var uglifyjs = require(&#39;uglify-js&#39;);

async.waterfall([
  function (next) {
    fs.remove(&#39;tmp/&#39;, function (err) {
      next(err);
    });
  },

  function (next) {
    fs.remove(&#39;build/&#39;, function (err) {
      next(err);
    });
  },

  function (next) {
    fs.ensureDir(&#39;tmp/&#39;, function (err) {
      next(err);
    });
  },

  function (next) {
    fs.ensureDir(&#39;tmp/js/&#39;, function (err) {
      next(err);
    });
  },

  function (next) {
    fs.readFile(&#39;src/js/bar.js&#39;, &#39;utf8&#39;, function (err, data) {
      next(err, data);
    });
  },

  function (js, next) {
    fs.readFile(&#39;src/js/baz.js&#39;, &#39;utf8&#39;, function (err, data) {
      next(err, js + &#39;;&#39; + data);
    });
  },

  function (js, next) {
    try {
      next(null, uglifyjs.minify(js, {
        fromString: true
      }).code);
    } catch (err) {
      next(err);
    }
  },

  function (js, next) {
    fs.readFile(
      path.join(
        __dirname,
        &#39;node_modules&#39;,
        &#39;foo&#39;,
        &#39;dist&#39;,
        &#39;foo.min.js&#39;
      ),
      &#39;utf8&#39;,
      function (err, data) {
        next(err, data + &#39;;&#39; + js);
      }
    );
  },

  function (js, next) {
    fs.writeFile(&#39;tmp/js/main.min.js&#39;, js, function (err) {
      next(err);
    });
  },

  function (next) {
    fs.move(&#39;tmp/&#39;, &#39;build/&#39;, function (err) {
      next(err);
    });
  }
],

function (err) {
  if (err) {
    throw err;
  }
});
</code></pre>

<p>コード自体は簡単でわかりやすい。手軽なので<code>asyn.waterfall()</code>でフローを制御。Streamじゃないけど、中間ファイルを吐かないのでGruntよりは速い。テキトーに書かれたモジュールも<code>try...catch</code>しつつ流せるとか気軽に書ける。ファイルの保証やディレクトリの削除などは<code>fs-extra</code>パッケージに頼ればこんなもので済んだ。</p>

<p>……でも長い。これでも<code>fs-extra</code>パッケージのおかげで短くなってる。読み込みと連結をまとめたりとかでもっと短くできるけど、そこを抽象化するとストレートに書けるという長所が無くなっちゃう。<code>async</code>の代わりに<a href="https://github.com/petkaantonov/bluebird">Promisify</a>するともうちょっと楽だけど、それほど劇的でもない。</p>

<p>ビルド・ツールのキモはやはりグロブを使った抽象化を提供してくれるあたりにあり、そこを毎回自前でどうにかするのは面倒すぎる。Gruntやgulpのような巨大な依存を減らせることは確かだけど、その代わりに小さな依存が増えるので、あんまり変わらない。こういうのを書くためのパッケージをセットにしたメタ・パッケージみたいなのがあればまた少し話が変わる……かなー？</p>

<p>こういうのを抽象化して引数で入力と出力を指定して終わりというパッケージがあっても面白そうだけど、それだとGruntとあんまり変わらないっぽい。<code>Gruntfile.js</code>を書く代わりに<code>package.json</code>で複雑な引数を書くわけだし。</p>

<hr>

<p>つまり<code>make</code>はありだけど、<code>npm run-script</code>はなしかなーという感じになった。引数取れるようになったので<code>npm run-script</code>でいけるいけるとか言ってる人の話はじっくりと聞いて、本気でそれだけで済むと言っていたら聞き流した方が良さそう。</p>]]></content:encoded>
    </item>

    <item>
      <title>min-widthを含むクエリーをソート</title>
      <link>http://hail2u.net/blog/coding/pack-and-sort-min-width.html</link>
      <description>CSS MQPackerにmin-widthを使ったクエリーのみ(なんとなく)ソートしてやる機能を付けている。あまり付けるつもりはなかったけれど、ユーザー層が広がったっぽいこともあり、たまにメールで聞かれたりもしていたので、まぁやるかという感じになった。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/pack-and-sort-min-width.html</guid>
      <pubDate>Fri, 27 Feb 2015 05:40:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/hail2u/node-css-mqpacker">CSS MQPacker</a>に<code>min-width</code>を使ったクエリーのみ(なんとなく)ソートしてやる機能を付けている。あまり付けるつもりはなかったけれど、ユーザー層が広がったっぽいこともあり、たまにメールで聞かれたりもしていたので、まぁやるかという感じになった。</p>

<p>色々面倒なのがあるので、多くの人が必要なのは<code>min-width</code>だけだろうと決めつけて実装している。その上で以下の条件にマッチするクエリーを<em>後ろ</em>に回して、その中でソートするようにした。</p>

<ul>
<li><code>min-width</code>をどこかに含む</li>
<li>対応している単位である</li>
<li><code>calc()</code>は使っていない</li>
</ul>

<p>クエリーはまずカンマで分割されて、その中で更に空白文字で分割し、クエリーをなんとなく多次元配列へ変換する。ここで<code>min-width</code>が見つかったら後ろに回すようになっている。対応した単位は<code>px</code>を基準に<code>ch</code>、<code>em</code>、<code>ex</code>、<code>pc</code>、<code>pt</code>、そして<code>rem</code>までだ。どうやっても描画領域を基準にした<code>v*</code>単位には対応できない。<code>cm</code>や<code>in</code>は対応しても良いけれどさほど意味はなさそうだ。ソートは<code>px</code>単位に変換されて行われる。</p>

<pre><code>@media (min-width: 48px) {}
@media (min-width: 2em) {}
@media (min-width: 1rem) {}
</code></pre>

<p>このように単位系が混在している場合は以下のように良い感じ(私見)にソートされる。それぞれの単位系ごとにソートとしても良いのだけど、それはそれで面倒そうなので一気にソートしてしまうことにした。</p>

<pre><code>@media (min-width: 1rem) {}
@media (min-width: 2em) {}
@media (min-width: 48px) {}
</code></pre>

<p><code>1rem</code>は<code>16px</code>、<code>2em</code>は<code>32px</code>とみなされ<code>48px</code>より前に来るようになるわけだ。</p>

<p>式自体の書き換えはもちろん行わない。<code>calc()</code>にも対応したい気はすごくあるのだけど、フルスクラッチで書くのはなかなか厳しそうだ。<a href="https://www.npmjs.com/package/reduce-css-calc">reduce-css-calc</a>を使おうかなと考えている。</p>

<p>CSSの書き方自体は普通にメディア・クエリーを書いてくれればなんとかなるはずだ。気をつけるのはなるべく単位を揃えることくらいだろう。気取って<code>screen</code>とか書いていても、Retina対応の<code>resolution</code>が混ざっていたりとかも大丈夫だと思うのだけど、もっと色々テスト書かないと不安だ。</p>

<hr>

<p>メディア・クエリーは<em>後方互換性を維持して</em>今度更に強化されていく。実装の方も進みつつある上、<code>calc()</code>の存在や憎むべきCSS Variablesも控えているので、やはり一時的なソリューションにしかならないと思う。<code>min-width</code>だけにしたのもその辺りが理由だ。でもソリューションとして機能しなくなった頃にはHTTP/2やらWeb Componentsやらで大量の細かいCSSファイルを気軽に投げつけられる時代になっているはずなので、きっとメディア・クエリーをまとめなくても良くなっているのではないかとも思う。</p>

<p><code>not</code>キーワードの扱いをどうしようか悩んでいて、それが解決したらリリースするつもりだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>Semantic Versioningにおける破壊的な変更</title>
      <link>http://hail2u.net/blog/software/breaking-changes-on-semver.html</link>
      <description>io.jsがv1.3.0になり、ビルトインのURLモジュールでresolve(&#39;/foo/bar&#39;, &#39;.&#39;)が/foo/とスラッシュ付きで返されるようになった。今までは/fooとスラッシュなしで返っていたので、これは破壊的な変更であり、Semantic Versioningに従うならばメジャー・バージョンを上げるべきではないのかという議論がなされていたようだ。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/breaking-changes-on-semver.html</guid>
      <pubDate>Thu, 26 Feb 2015 06:49:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://iojs.org/">io.js</a>がv1.3.0になり、ビルトインのURLモジュールで<code>resolve(&#39;/foo/bar&#39;, &#39;.&#39;)</code>が<code>/foo/</code>とスラッシュ付きで返されるようになった。今までは<code>/foo</code>とスラッシュなしで返っていたので、これは破壊的な変更であり、Semantic Versioningに従うならばメジャー・バージョンを上げるべきではないのかという議論がなされていたようだ。</p>

<p>仮にこういった実装ミスの修正が破壊的な変更だとすると、ほとんどすべてのバグ・フィックスは破壊的な変更になってしまう。バグ・フィックスは必ずどこかで何か(モンキーパッチとか)を破壊するし、破壊しないことを保証することは不可能だ。Semverにおいては変更の仕分けはユーザーの利用ではなく、仕様という観点での話になる。つまり仕様に変更があったかどうかが焦点になる。</p>

<p>このURLモジュールのケースでは、仕様が外部(ドキュメントのブラウザーの実装のように～という一文)にあり、それに従った結果になっていなかったということになる。この間違った実装に依存したコードにおいては破壊的な変更となるが、それはそのコードが悪いだけで、メジャー・バージョンを上げる理由にはならない。</p>

<p>概ねこう解釈したが、ユーザーに優しくはない。特にこのモジュールのこの挙動は長らく放置されていたバグで、こういうものだと思って利用していた人も多かったはずだ。stableと明記されていたこともその判断を後押ししたことだろう。そこを考慮するとメジャー・バージョンを上げてやり、ユーザーに周知する必要があったんじゃないだろうか。</p>

<p>Semverのこのあたりの微妙な判断を求められる点が、v1.0.0をリリースする気配がないパッケージでnpmリポジトリーが溢れかえっている原因なのかなと感じる。メジャー・バージョンを上げることの抵抗感をなくすか、Semverを諦めるかの二択になりそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>VimでGitで衝突したところにジャンプ</title>
      <link>http://hail2u.net/blog/software/jump-git-conflict-in-vim.html</link>
      <description>Gitでマージやリベースで衝突が起きた場合、その解消のために該当ファイルを開き、移動する……前に自動的に&lt;&lt;&lt;&lt;&lt;&lt;&lt;にジャンプするだけみたいなのがちょっと欲しくなった。VimだとBufReadPostでsearch()を呼べば良さそうだ。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/jump-git-conflict-in-vim.html</guid>
      <pubDate>Wed, 25 Feb 2015 21:37:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Gitでマージやリベースで衝突が起きた場合、その解消のために該当ファイルを開き、移動する……前に自動的に<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>にジャンプするだけみたいなのがちょっと欲しくなった。Vimだと<code>BufReadPost</code>で<code>search()</code>を呼べば良さそうだ。</p>

<pre><code>augroup LtLtLtLtLtLtLt
  autocmd!

  &quot; Jump to first conflict position if find
  autocmd BufReadPost * call search(&#39;^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#39;, &#39;sw&#39;, 0, 1000)
augroup END
</code></pre>

<p>検索を一周させるようにフラグを立てておくついでに戻れるようにもフラグを立てたつもりだけど、発火するタイミング的に常に先頭で意味が無いような気がしないでもない。あと大きなファイルで死にそうなので1000ミリ秒に制限しておいたけど、もっと短くても良さそう。カーソル位置の復帰など、同じようにファイルを開いた時にカーソル位置を動かすプラグインと相性は悪いけど、なんとかなる。</p>

<p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>は大体は文法エラーなので、Syntasticを使っている人は、</p>

<ul>
<li>開いた時にチェック(<code>let g:syntastic_check_on_open = 1</code>)</li>
<li>最初のエラーにジャンプ(<code>let g:syntastic_auto_jump = 1</code>)</li>
<li>位置リストを自動的に開く(<code>let g:syntastic_auto_loc_list = 1</code>)</li>
</ul>

<p>の設定を有効にするとだいたい実現できそうな気がする。最初のエラーじゃなかった時の保険として、位置リストを自動的に開くようにしておくといける。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
