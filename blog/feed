<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja-JP"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja-JP</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Sun, 18 Jan 2015 01:44:15 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="http://hail2u.net/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>厚いレイヤー</title>
      <link>http://hail2u.net/blog/webdesign/thick-layer.html</link>
      <description>Sitepointに書かれたBEMやSMACSSを使っている開発者たちからのアドバイスを読んでいた。僕は今いかにして命名規則をなくすかといったことを考えている最中のため否定的に読んだが、それでもここに書かれたアドバイスは正しいとは感じた。BEMやSMACSSが概ね想定以上に機能することは確かだし、スケールするし、指揮もとりやすい。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/thick-layer.html</guid>
      <pubDate>Sun, 18 Jan 2015 01:44:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Sitepointに書かれた<a href="http://www.sitepoint.com/bem-smacss-advice-from-developers/">BEMやSMACSSを使っている開発者たちからのアドバイス</a>を読んでいた。僕は今いかにして命名規則をなくすかといったことを考えている最中のため否定的に読んだが、それでもここに書かれたアドバイスは正しいとは感じた。BEMやSMACSSが概ね想定以上に機能することは確かだし、スケールするし、指揮もとりやすい。</p>

<p>僕が避けたいのは<em>何かしらへの強い依存</em>だ。薄いレイヤーならともかく、厚いレイヤーの場合は重度の依存をもたらす。その依存はこれからもそのまま通用するのかというと、不安が大きい。厚いレイヤーとは心中する覚悟が必要というのは正しいが、多くの場合心中する羽目になるのは導入した人ではなかったりもする。もっと薄いレイヤーでウェブ標準(など)に寄せた形の解があれば安心できるはずだ。</p>

<p>HTML 4.01に対するHTML5を始めとして、CSS 2.1に対するCSS 3、いわゆるJavaScriptに対するECMAScript 6は比較的薄い(技術的な点ではなく、アプローチとして)レイヤーと言える。こういったものなら移行もスムーズだし、受け入れられやすいし、学びやすいし、将来への不安も少ない。ウェブ標準外でそのようなものを実現できた・実現しているものを挙げるとすると、HTMLに対するMarkdownやMustache、CSSに対するSassのSCSS記法、JavaScriptに対するTypeScriptや6to5だろうか。</p>

<p>厚いレイヤーとして作られているものは多い。例えばHTMLに対するTextileやHAML、Jade、Slimであったり、CSSに対するSassのインデント記法やStylusの省略記法であったり、JavaScriptに対するCoffeeScriptであったり、だ。筋が悪いわけでもなく、現在の選択肢としては適当で、むしろ現時点では厚いレイヤーのこれらの方が評価されることも多い。これらはウェブ標準のしがらみから飛び出してその枝を延ばし、開発者に生産性を始めとした多くの果実を与えるからだ。</p>

<p>BEMやSMACSSがどちらに属すかというと、それは微妙なところだ。ウェブ標準とは特に干渉するわけではないのでそういう点では薄いが、命名規則なるものがウェブ標準にはないことを考えると、分厚く新たなレイヤーを追加してしまうものとも言える。その習得難易度や複雑化しつづける規則に鑑みると、厚いレイヤーになりつつあるのかなと感じる。</p>

<hr>

<p>と言いつつ<a href="https://github.com/hail2u/hail2u.net-styles">このウェブサイトのCSS</a>は<a href="http://hail2u.net/blog/webdesign/sass-and-bem.html">BEMをベースにしたアプローチ</a>でプレースホルダー・セレクターとネストに意味を持たせて制作していたりする。この方法はかなり複雑なので汎用的ではないが、BEMのブロック・エレメント・モディファイアーという概念を継承したCSSの構造化というのは悪い解ではない。しかしそこに本来構造化されている(はず)のHTMLがあるのにも関わらず、その更に上に命名規則による構造化を行うレイヤーを設けることに疑問を持ち始めた。</p>

<p>そんなわけでOOCSSを絶対として生まれたBEMやSMACSSといった命名規則に基づくCSSアーキテクチャーという代物を廃棄するため、<a href="http://hail2u.net/blog/webdesign/oocss-drawbacks-and-gifts-of-every-declaration-just-once.html">同じ定義を二度書かないアプローチ</a>を試行錯誤しているわけだ。BEMが嫌いになったとかそういうわけではなく、CSSアーキテクチャーなる代物が本当に必要なのかという疑問に対する答えを探すためだ。しっかりと構造化されたHTMLへ完全に従属させる形でCSSを書いても、昨今の高機能ないわゆる開発者ツールの助けがあればうまく機能するのではないか、というような思いつきを証明できるかというような話でもある。</p>]]></content:encoded>
    </item>

    <item>
      <title>CSSWring v3.0.0とCSS MQPacker v3.0.0のリリース</title>
      <link>http://hail2u.net/blog/webdesign/csswring-and-css-mqpacker-v3.0.0.html</link>
      <description>CSSWringとCSS MQPackerのメジャー・バージョンをそれぞれ更新した。中身としてはPostCSSをv4.0.0に更新しただけと言って良い。PostCSS v3でしか動作しないツールやプラグインと組み合わせたい場合は引き続き古いバージョンを利用する必要がある。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/csswring-and-css-mqpacker-v3.0.0.html</guid>
      <pubDate>Sat, 17 Jan 2015 01:13:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://www.npmjs.org/package/csswring">CSSWring</a>と<a href="https://www.npmjs.com/package/css-mqpacker">CSS MQPacker</a>のメジャー・バージョンをそれぞれ更新した。中身としてはPostCSSをv4.0.0に更新しただけと言って良い。PostCSS v3でしか動作しないツールやプラグインと組み合わせたい場合は引き続き古いバージョンを利用する必要がある。</p>

<p>実際には結構簡単に対応はできたのだけど、CSS MQPackerでの空白の取り扱いでどうしようかなという感じだった。具体的に言うと<code>@charset</code>ルールだけのような<code>between</code>プロパティー(<code>@charset</code>ルールの場合はその値と<code>;</code>の間の空白)のないCSSに普通のルールセットを突っ込むとその<code>between</code>プロパティー(ルールセットの場合はセレクターと定義群を括る<code>{</code>の間の空白)が消えてしまう問題についてだ。</p>

<p>例えばこのようなCSSをCSS MQPackerで処理すると、想定外の結果になる。</p>

<pre><code>@charset &#39;UTF-8&#39;;

@media (min-width: 1px) {
  .foo {
    display: block;
  }
}
</code></pre>

<p><code>@media</code>ルールをまとめながら退避させていくと、このCSSは<code>@charset</code>ルールのみになる。そのため改めてまとめた<code>@media</code>ルールを追加しなおすと、以下のように改行とインデント、セミコロンがPostCSSのデフォルトへと修正された上で、クエリーや<code>.foo</code>と<code>{</code>の間の空白が消えてしまう。</p>

<pre><code>@charset &#39;UTF-8&#39;;
@media <mark>(min-width: 1px){</mark>
    <mark>.foo{</mark>
        display: block
    }
}
</code></pre>

<p>内部の細かい挙動を理解すれば納得できる結果ではあるが、直感的ではない。<code>between</code>プロパティーだけ<a href="https://github.com/postcss/postcss/blob/5b86e6a94de9309cb354fcadd23f23249c174854/lib/node.js#L404-L417">デフォルトのスタイル</a>が定められておらず、ところどころで<a href="https://github.com/postcss/postcss/blob/5b86e6a94de9309cb354fcadd23f23249c174854/lib/node.js#L379-L390">特別視</a>されていることから、うまくコピーできてしまってこうなるようだ。同じ<code>between</code>という名前で違うものを扱おうとしていることが原因なのではないかと想像している。</p>

<p>ちょっと実装として気になるので、このあたりは今後変わりそうではある。もしこの<code>between</code>プロパティーをいじるようなツールやプラグインを作っている場合は注意した方が良さそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>node-edjo</title>
      <link>http://hail2u.net/blog/webdesign/node-edjo.html</link>
      <description>Every Declaration Just Onceのスタイルに既存のCSSを変換し、どのような感じになるのかを確認するためのツールを書いてた。node-edjoとしてGitHubに公開しておいたので、Node.js互換の何かがあればnpmでインストールして誰でも使える。ただしnpmリポジトリーには公開されることはないので、READMEに書いてあるようにユーザー名とリポジトリー名を使ってインストールする。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/node-edjo.html</guid>
      <pubDate>Fri, 16 Jan 2015 00:03:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Every Declaration Just Onceのスタイルに既存のCSSを変換し、どのような感じになるのかを確認するためのツールを書いてた。<a href="https://github.com/hail2u/node-edjo">node-edjo</a>としてGitHubに公開しておいたので、Node.js互換の何かがあればnpmでインストールして誰でも使える。ただしnpmリポジトリーには公開されることはないので、READMEに書いてあるようにユーザー名とリポジトリー名を使ってインストールする。</p>

<p>完全な変換ツールではないので、これを使って移行とかは無理。ルールセットの順序が入れ替わっているので、CSSとしてちゃんと機能するかも未知数なものに変換されちゃう。あくまでもCSSがどのような感じになるのかがわかるだけのツールで、どれくらいのセレクターが集まってくるのかとか、定義はDRYだけどセレクターがDRYじゃないのはどの程度わかりづらそうなのかとかそういうものを感じるとっかかりという程度のツール。</p>

<p>実際にこのウェブサイトのCSSを変換すると、<a href="https://github.com/hail2u/node-edjo/blob/4f38d140b7080bd0e55a53d9beb8fad0035c20ff/test.edjo.css">まぁまぁ想定通りの形</a>に変換され(てホッとし)た。もっとアバンギャルドな感じになるかもしれないとヒヤヒヤしていたので、これくらいなら「とんでもない！」という程でもない気がする。ひいき目だけど。ところどころ変なところに改行が入っているのはSassのせいで、PostCSSでもこのツールのせいでもない。</p>

<p>EDJOのダメそうなところは改めてちゃんと書きたい。このツールを使いつつ色々考える。</p>]]></content:encoded>
    </item>

    <item>
      <title>OOCSSの欠点とEvery Declaration Just Onceのもたらすもの</title>
      <link>http://hail2u.net/blog/webdesign/oocss-drawbacks-and-gifts-of-every-declaration-just-once.html</link>
      <description>昨日も少し書いたEvery Declaration Just Onceアプローチ(以下EDJOと略す)について、皆が目を瞑っているOOCSSの欠点、CSSが持つ特徴、HTMLとの兼ね合いという点からもう少し書いてみたい。これについては未だ誰ともちゃんと議論していない。機会があったらこの記事をベースにでも誰かと話してみたい。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/oocss-drawbacks-and-gifts-of-every-declaration-just-once.html</guid>
      <pubDate>Thu, 15 Jan 2015 11:29:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>昨日も少し書いた<a href="https://developers.google.com/speed/articles/optimizing-css">Every Declaration Just Onceアプローチ</a>(以下EDJOと略す)について、皆が目を瞑っているOOCSSの欠点、CSSが持つ特徴、HTMLとの兼ね合いという点からもう少し書いてみたい。これについては未だ誰ともちゃんと議論していない。機会があったらこの記事をベースにでも誰かと話してみたい。</p>

<p>上記Googleの文書は、主にパフォーマンスの観点で書かれている。どうしても長くなりがちな定義を分散して書くよりも、能動的に短くすることができるセレクターを分散して書いた方が、プロダクションにおいてリリースされるCSSファイルのサイズを小さくすることが可能だろうというものだ。同時にこの文書の筆者は自身のブログで、<a href="http://meiert.com/en/blog/20141009/css-dry-and-optimization/">より自然にCSSを書くための手法(原文: <q>The Natural Way of Writing CSS</q>)</a>としてこのEDJOという手法について述べている。</p>

<p>僕は主にそういったCSSの書き方という観点からEDJOに注目した。この記事もそれに従って書かれている上、パフォーマンスについてはGoogleの文書で十分に書かれているので、以下では特に触れない。</p>

<h2>OOCSSとは</h2>

<p>まずはOOCSSについてざっと触れておく。OOCSSではいくつかの<a href="http://www.w3.org/TR/CSS2/syndata.html#rule-sets">定義</a>(プロパティーとその値のセット)を組み合わせることにより再現できる見た目をオブジェクトとみなし、それを継承・拡張していく。オブジェクトは一定の意味を持つ単位で作成され、それを組み合わせることで振る舞いベースで、ウェブサイトのビジュアル・デザインを完成させていくことができるというわけだ。</p>

<p>実際に継承と拡張を行う手段は、オブジェクトとして定義されたクラスを複数組み合わせていく手法、いわゆる<em>マルチ・クラス</em>による。今ではCSSプリプロセッサーなどもあるが、例えばSassの<code>@extend</code>を使ったロジカルな継承は開発者間での濃いコミュニケーションによる意識の摺り合わせが必須とも言えるので、まだまだマルチ・クラスで行われている、行われるだろうと言って良い。</p>

<p>もし仮に後で書かれたセレクターの方が必ず強いというようなシンプルな仕組みであったら、マルチ・クラスはその想定通りうまく機能しただろう。しかしそうはいかない。</p>

<h2>セレクターの詳細度</h2>

<p>CSSでは<a href="http://www.w3.org/TR/CSS2/cascade.html#specificity">セレクターの詳細度</a>というものがある。例えば<code>.foo</code>より<code>.bar .foo</code>が強いというような、セレクターの書かれた順序を越えて定義が適用される仕組みだ。</p>

<pre><code>body h1 {
  font-family: serif;
}

h1 {
  font-family: sans-serif;
}
</code></pre>

<p>このCSSの場合<a href="http://hail2u.net/pub/test/606.html"><code>h1</code>は<code>serif</code>で表示されること</a>だろう。OOCSSにおいてマルチ・クラスを利用する場合、このセレクターの詳細度というものと格闘する必要が出てくる。なぜかと言えばオブジェクトとして定義された<a href="http://www.w3.org/TR/CSS2/syndata.html#rule-sets">ルールセット</a>の順序通りにビジュアル・デザインが適用されていくとは限らないからだ。</p>

<p>詳細度の仕組みは仕様を読むと簡単に書かれているが、実際にはそこそこ複雑だ。自然、その理解度が人によりまちまちであることも頭に入れておく必要がある(僕も正直8割強くらいしか理解している自信はない)。そうなるといかにしてこのような仕組みが発動しないようにCSSを書くか、ということになる。</p>

<h2>クラスの命名規則</h2>

<p>つまりセレクターでクラス名を二つ以上使わないようにし、すべてのセレクターの詳細度を等しくするわけだ。もちろん要素名やIDなどはこの世に存在しないものとみなして忘れ去ってしまえば良い。そうすることですべてのオブジェクト(=ルールセットに書かれた定義たち)はひとつのクラス名で表現されたセレクターにより割り当てられていくため、その書かれた順番に従ってその定義が上書きされていくようになる。</p>

<p>問題はクラス名の付け方だ。詳細度の仕組みの都合上、クラス名を複数組み合わせることはできない。つまり以下のようなセレクターは書くことが出来ない。</p>

<pre><code>.global-header .nav .item .icon {
  ...
}
</code></pre>

<p>従ってこのようなクラス名を付けることになる。</p>

<pre><code>.global-header-nav-item-icon {
  ...
}
</code></pre>

<p>HTMLは当然のようにこうなる。</p>

<pre><code>&lt;header class=&quot;global-header&quot;&gt;
  ...
  &lt;nav class=&quot;global-header-nav&quot;&gt;
    &lt;li class=&quot;global-header-nav-item&quot;&gt;
      &lt;span class=&quot;global-header-nav-item-icon&quot;&gt;&lt;/span&gt;
      &lt;span class=&quot;global-header-nav-item-title&quot;&gt;Blog&lt;/span&gt;
    &lt;/li&gt;
    ...
  &lt;/nav&gt;
&lt;/header&gt;
</code></pre>

<p>おおっと。</p>

<p>マルチ・クラスによる割り当てになるので、実際にはもう少しシンプルな値にはなる。が、それと同時に短いとはいえ別のクラス名が追加されていくので、<code>class</code>属性の値は概ねこのような複雑なものになっていく。更にこういった単純に連結したり組み合わせたりするだけの命名規則では表現できない概念を補足するように鍛えていくと、<a href="https://smacss.com/">SMACSS</a>や<a href="http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/">MindBEMding</a>、そして今最も注目度が高い<a href="https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md">SUIT CSSの命名規則</a>へと進化することになる。</p>

<p>かくしてHTMLでは各要素に<code>class</code>属性として20–50文字くらいの値がちょくちょく割り当てられていくようになった。CMSやビルド・ツールを前提にしないと保守できない状態だといえるだろう。</p>

<h2>Every Declaration Just Once</h2>

<p>すべての定義を一度だけしか書かないこのアプローチ、EDJOではOOCSSとはCSSを書く手順が逆になる。</p>

<p>OOCSSではオブジェクトといういくつかの定義の組み合わせであるルールセットをまず書き、それにクラス名を使って名付ける。そしてHTMLに戻り、そのオブジェクトを割り当てたい要素に対し、クラス名を振っていく。</p>

<p>EDJOではまずHTMLで適切なクラス名(IDでも良いだろう)を振っておく。誤解を恐れずに言うのならば、セマンティックなクラス名とかそのようなもので、ウェブページにおいてその要素がどのようなものかを表現するクラス名だ。IDでも良いだろうし、HTML5の強い意味付けを持つ要素をきちんと使い分けているならクラス名やIDを付けなくても良いこともあるかもしれない。またクラス名は再利用しないので、抽象化した名称(例えば<code>.clearfix</code>であったり<code>.column-wrapper</code>など)である必要もない。</p>

<p>そしてCSSではビジュアル・デザインを決定する定義をまず書き、それを適用するセレクターを割り当て、ひとつの定義ごとにルールセットを作っていく。例えばこのような形だ。わかりやすいように様々なパターンでセレクターを書いてみたが、実際には開発者やプロジェクトごとにパターン化されてくるだろう。とりあえず一意に確定する形で書いておけば、後で置換をかけることでそのフォーマットを統一することも容易いはずだ。</p>

<pre><code>body &gt; header,
main,
.searchbox,
[role=&quot;contentinfo&quot;] {
  margin: 0 auto;
}

body &gt; header,
[role=&quot;contentinfo&quot;] {
  background-color: #333;
}

main {
  background-color: #fff;
}

.searchbox {
  background-color: #999;
}
</code></pre>

<p>EDJOではセレクターの詳細度はほとんど無視することができる。なぜならある要素を表現するセレクターは常に同じで良いからだ。つまりある要素に複数のクラス名が割り当てられることはないし、同じ要素を違うセレクターで参照することもないということで、それゆえに値の上書きがそもそも起こらないということになる。状態を表すようなクラスは別途追加する必要が出てくるが、例外はそれくらいだろう。</p>

<p>このようにEDJOでは、セレクターの詳細度という<em>あまり理解されていない仕組み</em>とクラスの命名規則という<em>守らせることはおろかまず作ることからして難しい仕組み</em>を共に意識せずにCSSとHTMLを書いていくことができるということだ。それはつまりHTMLはHTMLで書くことができ、CSSはCSSで書くことができ、更にその両者の結びつけを同じ定義を二度書かないという単純明快なルールのみで行うことができるということでもある。</p>

<hr>

<p>OOCSSの欠点はその思想や哲学、ベースとなった技術の問題ではない。ツリー構造を持つHTMLやカスケーディングという独自の継承の仕組みを持つCSSとは根本的に相性が悪く、命名規則というような運用におけるルール付けでカバーしなくてはならないところだ。もしHTMLやCSSがもう少し違うものだったら、OOCSSは間違いなく論理的で明確な方向性をウェブデザインに与える唯一無二の手法であった、そしてありつづけるものだったろう。しかし現実は違うし、未来もそうなりそうもない(セレクターのネストが可能になるとわからないけれども)。</p>

<p>そこでCSSにおいてその力不足を補い、OOCSSのような論理的なアプローチを可能にしようとするために生まれたのがCSSプリプロセッサーだった。しかしこれもOOCSSの欠点を完全にはカバーすることは出来てはいない。そのため既に名前だけは何回か出したSUIT CSSの命名規則のようなものが、ここに至っても生まれた(生まれてしまった)というわけだ。</p>

<p>EDJOがCSSを本来あるような形に戻したものだと捉えると、もはやCSSプリプロセッサーはCSSを無闇に複雑にしてしまっただけにも感じられてしまう。EDJOならCSS Variableのみのプリプロセッサーで十分機能しそうだ。</p>

<hr>

<p>ひとつ、声を大きくして謝りたいのは、フロントエンド側じゃない人たちのCSSの書き方にダメ出しをしていたことだ。過去の僕はOOCSSをいかにして再現するかを重要視しており、OOCSSへの理解に欠ける人たちによるEDJO的な書き方(定義があるところに雑にセレクターを追加していく書き方)に対してかなり厳しく反論していたように思う。OOCSSを採用している以上、そういったEDJO的な書き方を否定することは間違っていたわけではないのだけど、その時の論理は「OOCSSだから～」というような、今思うと曖昧な、当時も理由としては弱いと薄々気付いていた言葉で押し通していた。</p>

<p>その頃にもう少しOOCSSの欠点について掘り下げていればそういった書き方にも一理以上の何かがあったことに気づけたはずだ。広く受け入れられているアプローチだからというような理由で盲信するのは良くないが、それを実践するのはなかなか難しい。もちろんこのEDJOというアプローチにも言えることだ。気をつけながらEDJOの世界をもうちょっと掘り起こしていこうと思う。</p>

<p>もしMindBEMdingのようなBEMライクな命名規則から、よりわかりやすく強力なSUIT CSSの命名規則に移行しようかなと考えている人がいたら、ちょっとだけEvery Declaration Just Onceというアプローチを試してみて欲しい。僕はこのアプローチを試した結果、OOCSSの実装の難しさにより嫌いになりかけたCSS(Sassでかろうじて理性を保ってやり過ごしてきていたが)を本気でもう一度好きになれそうな気がしてきている。HTMLとCSSが疎結合する未来を夢見ていた人達なら、OOCSSが唯一無二の解ではないという前提だと、このアプローチに未来を見出すことができるのではないだろうか。</p>

<h2>追記</h2>

<p>参照したGoogleのEDJOに関する文書とこの記事の内容が乖離していたことに気づいていなかったので、本来的に参照するべきJens Oliver Meiertのブログ記事へのリンクを追加した。両文書は同じ筆者による記事ではあるが、違う観点によって書かれているので、両方参照するべきだった。</p>]]></content:encoded>
    </item>

    <item>
      <title>Every Declaration Just Onceの例</title>
      <link>http://hail2u.net/blog/webdesign/every-declaration-just-once-example.html</link>
      <description>同じ定義は書かないCSSの簡単な例とその書き方に対する覚え書きを残しておく。同じ定義を書かないようにしていくと、CSSプリプロセッサーはおろか、セレクターのネストもなくて良いのかと感じてくる。もしかするとCSSの着地点はここなのかと洗脳されつつある。もはや第三者の目で見ることができなくなったので、他の人の意見も聞いてみたい。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/every-declaration-just-once-example.html</guid>
      <pubDate>Wed, 14 Jan 2015 10:02:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://developers.google.com/speed/articles/optimizing-css">同じ定義は書かないCSS</a>の簡単な例とその書き方に対する覚え書きを残しておく。同じ定義を書かないようにしていくと、CSSプリプロセッサーはおろか、セレクターのネストもなくて良いのかと感じてくる。もしかするとCSSの着地点はここなのかと洗脳されつつある。もはや第三者の目で見ることができなくなったので、他の人の意見も聞いてみたい。</p>

<pre><code>.foo {
  border: 1px solid red;
  margin: 0 auto;
  width: 40rem;
}

.bar {
  border: 1px solid green;
  margin: 0 auto;
  width: 40rem;
}

.baz {
  border: 1px solid blue;
  margin: 0 auto;
  width: 40rem;
}
</code></pre>

<p>このような共通する定義を持つセレクターは以下のように書かれる。</p>

<pre><code>.foo,
.bar,
.baz {
  margin: 0 auto;
}

.foo,
.bar,
.baz {
  width: 40rem;
}

.foo {
  border: 1px solid red;
}

.bar {
  border: 1px solid green;
}

.baz {
  border: 1px solid blue;
}
</code></pre>

<p>まずは定義ごとというのがポイントだ。</p>

<pre><code>.foo,
.bar,
.baz {
  margin: 0 auto;
}

.foo,
.bar,
.baz {
  width: 40rem;
}
</code></pre>

<p>このようにまとめられそうなブロックでもあえて分割する。そうしておくことによって、後に<code>margin: 0 auto</code>だけ使うクラスを追加したい時に分割し直す手間が省ける。こういった後のメンテナンス性を考えた場合、先頭に定義をわかりやすくしたクラスを追加するのも悪くなかった。</p>

<pre><code>.centering,
.foo,
.bar,
.baz {
  margin: 0 auto;
}
</code></pre>

<p>こうしておくと<code>,\n\.foo</code>で置換を行えるようになる。しかし使いもしないセレクターが書かれているのは無駄が多い気がしたのでやめてしまった。ただし、そのブロックがどういう定義のためのブロックなのかをわかりやすくできるので、すこし規模が大きくなると助かるかもしれない。その場合は後にツールで削除してやると良さそうだ。</p>

<p>またどこまで定義を分けるかというのもちょっと悩む。例えば<code>border</code>ショートカット・プロパティーなどだ。上記例だと以下のようにも書くことができ、定義をなるべく重複しないようにとするとこのように書くべきようにも思える。</p>

<pre><code>.foo,
.bar,
.baz {
  border-style: solid;
}

.foo,
.bar,
.baz {
  border-width: 1px;
}

.foo {
  border-color: red;
}

.bar {
  border-color: green;
}

.baz {
  border-color: blue;
}
</code></pre>

<p>さすがに冗長すぎる印象だ。どこまで分割するかの線引きはもうちょっと考える必要があるだろう。</p>

<hr>

<p>この書き方は、今まで良い解とされていたOOCSSのようなアプローチとは真逆で、悪いアプローチとされていた物理的な装飾を基準としたアプローチに近い。そのためOOCSSどっぷりだった人達には違和感しかない。</p>

<p>作業としては、どのような装飾を加えるか決まったら、そのプロパティー等で検索し、既にあったらそこにセレクターを追加、なかったらブロックを追加と、非常に単純化されたものだけで済む。ルールそのものが単純なこと、書き方の説明としても簡単で済むこと、<em>間違えて重複する定義を追加しても致命的ではないこと</em>、差分がわかりやすいことなど開発中の利点は多い。</p>

<p>一方でコンポーネント単位での確認というような地道な作業、つまりテストとは相性が悪い。逆に言うと定義ごとに分けることによってコード上で確認できるようにしたとも言えるかもしれない。ブラウザーの実装の不行き届きやバグへの対処に確認が必要な現状だと絵空事に近いので、ワークフローが大幅に省力化するわけではなさそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>白Tシャツ</title>
      <link>http://hail2u.net/blog/misc/white-t-shirt.html</link>
      <description>良さそうな白いTシャツがなかなか見つからず、結局HanesのJapan FitなるもののBEAMSのロゴ入りのバージョンを買った。着丈がもうちょっと短めのを探すとなると大変なようなので、もうインナーでしか着ないと決め、これにした。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/white-t-shirt.html</guid>
      <pubDate>Tue, 13 Jan 2015 13:22:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="http://www.amazon.co.jp/gp/product/B00KQ4CAWG/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00KQ4CAWG&amp;linkCode=as2&amp;tag=hail2unet-22"><img src="http://ecx.images-amazon.com/images/I/31FHI7XxhAL.jpg" alt="(ビームス) BEAMS HANES / T-SHIRTS Japan Fit"></a>
</figure>

<p>良さそうな白いTシャツがなかなか見つからず、結局<a href="http://www.amazon.co.jp/gp/product/B00KQ4CAWG/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00KQ4CAWG&amp;linkCode=as2&amp;tag=hail2unet-22">HanesのJapan FitなるもののBEAMSのロゴ入りのバージョン</a>を買った。着丈がもうちょっと短めのを探すとなると大変なようなので、もうインナーでしか着ないと決め、これにした。</p>

<p>最初はちょっとへなへなすぎて頼りなかったけど、数回洗うとちょっとしまってきた。若干ゆるめな襟もびろんびろんにヘタったりはしなそうだ。一枚で着るのは無理があるけど、肌触りは良くインナーとしては優秀。難点は裾にあるタグ。肌に当たらないようにとあの位置なのはわかるんだけど、どうせなら外しやすく別に縫い付けてくれるか、ロゴと同じ位置に印刷だと良かった。</p>

<hr>

<p>この秋冬は<a href="http://www.pinterest.com/hail2u/bought/">ブーツ買ったりジーンズ買ったりセーター買ったり帽子買ったり財布買ったりコート買ったり</a>してた。あと袖を破いてしまったジャケットの代替と、場つなぎで買ったら1ヶ月で壊れ始めたスニーカーを諦めてちゃんとしたのも買いたい。こうしてどんどん新しいパソコン買うのが先延ばしになっていく……。Broadwell出たらとかWindows 10出たらとか理由を付けて誤魔化している。</p>]]></content:encoded>
    </item>

    <item>
      <title>Gruntプラグインの同梱</title>
      <link>http://hail2u.net/blog/coding/with-grunt-plugin.html</link>
      <description>遂に別々に管理するのが面倒になったので、PostCSSを使ったツールにGruntプラグインも同梱するようにした。grunt-postcssなどから使う方が効率的なので、もはや単体のGruntプラグインはメンテナンスが放棄されがちだ。CSSWring v2.1.0とCSS MQPacker v2.1.0には既に同梱されている(まだPostCSS v4.0.0にはなっていない)。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/with-grunt-plugin.html</guid>
      <pubDate>Mon, 12 Jan 2015 01:36:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>遂に別々に管理するのが面倒になったので、PostCSSを使ったツールにGruntプラグインも同梱するようにした。<a href="https://github.com/nDmitry/grunt-postcss">grunt-postcss</a>などから使う方が効率的なので、もはや単体のGruntプラグインはメンテナンスが放棄されがちだ。<a href="https://github.com/hail2u/node-csswring/tree/ba3642d9d94149e3519de5db2993ca5232752d2b">CSSWring v2.1.0</a>と<a href="https://github.com/hail2u/node-css-mqpacker/tree/e234fdb3d7565740f68450b5f33b81c9d777dddf">CSS MQPacker v2.1.0</a>には既に同梱されている(まだPostCSS v4.0.0にはなっていない)。</p>

<p><a href="https://github.com/sindresorhus/load-grunt-tasks">load-grunt-tasks</a>などのGruntプラグイン読み込み自動化パッケージの恩恵には預かれないため、<code>Gruntfile.js</code>で自前で読み込んでやる必要がある。</p>

<pre><code>module.exports = function (grunt) {
  grunt.loadNpmTasks(&#39;css-mqpacker&#39;);
  grunt.loadNpmTasks(&#39;csswring&#39;);
};
</code></pre>

<p>両者とも設定はないが、PostCSSの<code>process()</code>の第二引数にしていするオプションを<code>options</code>を使って指定できるようにはなっている。のでSource Mapsも自在に吐ける。継承したい場合は<code>map: true</code>を指定してやるだけで、PostCSSが賢いのでだいたい動く。</p>

<hr>

<p>PostCSSを利用する単体のGruntプラグインのgrunt-postcssに対する優位性は、<code>peerDependencies</code>によるPostCSSのバージョンの束縛を無視できることだ。</p>

<p>grunt-postcssを使う場合、要求するPostCSSのバージョンが食い違っているもの同士を組み合わせることができなくなる。<code>peerDependencies</code>でそれぞれバージョンを束縛できるが、そうなると食い違うものがそもそもインストール出来なくなる。解決のためにはパッケージ側のアップデートが必須になる。</p>

<p>単体のGruntプラグインの場合はそれぞれが独自にPostCSSをインストールして使うので、ほとんどのケースで組み合わせることが可能になる。その分、無駄が多くなるということでもあるけれども。</p>

<p>この辺りはGruntもPostCSSもプラグイン・システムとして失敗した感がある部分で、もうちょっとなんとかしないとメンテナンスが放棄されているけどまだ動くものが最新版の環境ではうまく動かせなくなってしまう。その点、gulpでは<a href="https://github.com/gulpjs/gulp/blob/master/docs/writing-a-plugin/guidelines.md">gulpパッケージが<code>dependencies</code>にも<code>peerDependencies</code>にも現れないように書くべき</a>としており、柔軟性と将来性で優っている。</p>]]></content:encoded>
    </item>

    <item>
      <title>PostCSS v4と空白</title>
      <link>http://hail2u.net/blog/coding/postcss-v4-and-white-spaces.html</link>
      <description>PostCSSのv4.0.0が年明け早々に出た。互換性のない変更の中では、v3.0.0でchildsと妙なスペルで名付けられたものがnodesに修正されたことが一番大きそうだ。他、便利メソッドの追加に加え、空白の最適化機能が大幅に変更になった。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/postcss-v4-and-white-spaces.html</guid>
      <pubDate>Sun, 11 Jan 2015 14:00:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/postcss/postcss/releases/tag/4.0.0">PostCSSのv4.0.0</a>が年明け早々に出た。互換性のない変更の中では、v3.0.0で<code>childs</code>と妙なスペルで名付けられたものが<code>nodes</code>に修正されたことが一番大きそうだ。他、便利メソッドの追加に加え、空白の最適化機能が大幅に変更になった。</p>

<p>ソースを読んでもよくわからなかったので<a href="https://github.com/postcss/postcss/issues/165">イシューを立てて聞いたところ</a>、思ったよりもかなり複雑そうだった。しかしよく練られてはいる印象は持ったので、これに任せてしまうのが賢そうだ。つまりノードを動かす時には<code>clone()</code>を通すか、新メソッドの<code>moveTo()</code>などを使ってやることで、まずノードの空白関連のプロパティーをリセットする。後はPostCSSに前後のノードを参照するかデフォルトのフォーマットを採用するかを選択させるという形だ。</p>

<p>PostCSS側の変更でテストの期待される結果は書き直さなければならなそうだが、ライブラリー側で余計なことをするよりかはコストが低いと思われる。</p>]]></content:encoded>
    </item>

    <item>
      <title>postcss-single-charset</title>
      <link>http://hail2u.net/blog/webdesign/postcss-single-charset.html</link>
      <description>minifyしてからconcatという手順でCSSをビルドしているため、連結するそれぞれのCSSファイルにある@charsetルールが無意味になる。そこで最初の@charsetを先頭に持ってくるだけのPostCSSプラグインを書き、それをconcatした後に使うことにした。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/postcss-single-charset.html</guid>
      <pubDate>Sat, 10 Jan 2015 01:52:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="http://hail2u.net/blog/webdesign/minify-then-concat.html">minifyしてからconcat</a>という手順でCSSをビルドしているため、連結するそれぞれのCSSファイルにある<code>@charset</code>ルールが無意味になる。そこで最初の<code>@charset</code>を先頭に持ってくるだけのPostCSSプラグインを書き、それをconcatした後に使うことにした。</p>

<p>PostCSSプラグインとして作ったのでパブリックなAPIはない。つまり必ずPostCSSの<code>use()</code>でプロセッサーとして読み込んでやる必要がある。</p>

<pre><code>var fs = require(&#39;fs&#39;);
var postcss = require(&#39;postcss&#39;);

var input = fs.readFileSync(&#39;input.css&#39;, &#39;utf8&#39;);
var output = postcss().use(
  require(&#39;postcss-single-charset&#39;)()
).process(input).css;
fs.writeFileSync(&#39;output.css&#39;, output);
</code></pre>

<p>PostCSSを知らないとよくわからないと思うけど、PostCSS界隈ではこれで普通な感じということになっている。実際には<a href="https://github.com/nDmitry/grunt-postcss">grunt-postcss</a>や<a href="https://github.com/w0rm/gulp-postcss">gulp-postcss</a>経由で使うことになるだろう。</p>

<p>利用サンプルを兼ねてGruntプラグインも同梱しておいた。<code>grunt-</code>プリフィックスが付いていないため、<a href="https://github.com/sindresorhus/load-grunt-tasks">load-grunt-tasks</a>では読み込んでくれない(と思う)ので、READMEにあるように書いてちゃんと読み込む必要がある。他は特に変なことはないが、あまり行儀良くはなさそうなので利用は非推奨ということにしておく。</p>

<hr>

<p>あんまりパッケージ化するつもりはなかったけど、PostCSSプラグインというような形で書いたことがなかったので試しに書いてみた。特に何ということもなかった。</p>]]></content:encoded>
    </item>

    <item>
      <title>ウェブ・フォントの読み込み</title>
      <link>http://hail2u.net/blog/webdesign/loading-web-fonts.html</link>
      <description>ウェブ・フォントも完全に行き渡り、今はどう効率的に配信するかについて多くの時間を割くようになった。Google Fontsの低め安定路線を見限り、TypeKitやFonts.comへ鞍替えする人々も増えた。それと同時に自前でホスティングする人々も徐々にその数を増やしており、どれが最適解なのか一応の結論が出るにはもう少しかかるだろう。まず、ウェブ・フォントの読み込みにおいてどのようなアプローチがあり、どのようなメリット、そしてデメリットがあるのだろうか。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/loading-web-fonts.html</guid>
      <pubDate>Fri, 09 Jan 2015 13:10:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>ウェブ・フォントも完全に行き渡り、今はどう効率的に配信するかについて多くの時間を割くようになった。Google Fontsの低め安定路線を見限り、TypeKitやFonts.comへ鞍替えする人々も増えた。それと同時に自前でホスティングする人々も徐々にその数を増やしており、どれが最適解なのか一応の結論が出るにはもう少しかかるだろう。まず、ウェブ・フォントの読み込みにおいてどのようなアプローチがあり、どのようなメリット、そしてデメリットがあるのだろうか。</p>

<p>TypeKit等に頼るにしろ、自前でホスティングするにしろ、もちろん最終的にはウェブ・フォントをブラウザーに送りつける必要がある。読み込みとはまさにその部分の話だ。話がややこしくなるので、<a href="http://hail2u.net/documents/bulletproof-at-font-face-syntax.html">多様な実装を意識した安全な書き方</a>などについては触れない。</p>

<h2>普通に@font-face定義を利用</h2>

<p><code>@font-face</code>定義をただ普通に書く場合のメリットは、基本的な知識さえあれば書けることと動かなくなる可能性が最小限に抑えられることだ。CSSが単純であることから、書きやすく、組み込みやすく、修正もしやすい。将来的に仕様が大きく変化した場合でも、実装がそれなりにフォローしてくれることも期待できるだろう。</p>

<p>デメリットは読み込みコストの増加と初期描画の遅延だ。</p>

<p>読み込みコストの増加は単純に大きめの画像へのリクエストが常に行われるということでもあるし、メモリーの圧迫ということでもある。機器の進化と環境の発展が解消してくれるであろう問題であるとも言えるが、歴史を振り返ると常に汲々として対策を練らなくてはいけない類いの問題であったので、そうはたやすく解決されないだろう。</p>

<p>初期描画の遅延は、古くからFOUTと呼ばれ問題視されていた現象についてがまず挙げられる。だいたいはFOUTが起こらないように実装が変化した。ウェブ・フォントのリクエストに失敗していそうな時も3秒でフォールバック・フォントで表示されるように統一されつつあるので、あまり問題ではなくなりそうだ。</p>

<p>しかし、3秒間文字がまったく表示されない状態が続く、と考えると致命的な遅延とも言える。実際にはCSSファイルの肥大化による遅延も重なり、空白の状態からやっと表示されたら今度は文字が見えないという状態に変化するため、ユーザーへはなかなかの違和感を与えることになる。</p>

<h2>DataURIを使ったsrc記述子の指定</h2>

<p>メリットはウェブ・フォントが必要な場合には必ず既に読み込み済みになっていることだ。つまりCSSファイルが読み込まれたならウェブ・フォントが適用されるだろうし、何らかの理由でCSSファイルの読み込みに失敗した場合でも文字だけ見えないというような状態には決してならない。またCSSだけで完結するのも大きいだろう。残念ながらツールの助けは必要になるだろうが、特にHTMLやJavaScriptの助けは必要としない。</p>

<p>デメリットはCSSファイルの肥大化だ。英数記号のみの欧文タイプフェイスのウェブ・フォントであったとしてもウェイトごとに30KBほど、和文のそれになると少なくともウェイトごとに300–1000KB前後がCSSファイルに追加されることになる。これは単にCSSファイルの読み込み自体に時間がかかるということだけではなく、そのパースに時間がかかるということでもある。つまりウェブページの描画され始めるまでに時間がかかってしまうということだ。</p>

<p>ウェブ・フォントに限らず巨大なData URIをCSSファイルに混ぜ込むのは悪手と言って良い。せいぜい2KB前後までのSVGファイルくらいなものだろう。</p>

<h2>ウェブ・フォントのCSSの遅延読み込み</h2>

<p>初期描画を遅延させないためには、JavaScriptファイルの非同期読み込みと同じように、ウェブ・フォントの読み込みとウェブページの描画を同時に行わせれば良い。CSSファイルに<code>@font-face</code>定義を書かず、<code>head</code>要素の子としても書かないことによって、遅延読み込みさせることに成功すれば、ウェブ・フォント由来の初期描画の遅延は限りなく少なくなる。</p>

<p>このデメリットはFOUTと呼ばれ、問題視されていた古いFirefoxの挙動と同じになることだ。まずフォールバックとして指定されたローカルのフォントで表示され、ウェブ・フォントの読み込みが完了した後にフォントが変更になるため、その切り変わる時に画面がフラッシュする。読み込みが終わるまで文字がまったく表示されないよりはフラッシュすることの方がまだ良いだろうというネガティブな選択の結果の手段ということになる。</p>

<p>また残念ながらCSSだけでは完結しない。JavaScriptを使うか、文法違反であることに目をつぶって<code>body</code>要素の最後にウェブ・フォントを読み込むための<code>link</code>要素を突っ込む必要がある。</p>

<h2>Web Font Loader</h2>

<p>遅延読み込みを一歩進め、フォントの読み込みを監視することにより、FOUTを制御できるようにしたのが<a href="https://github.com/typekit/webfontloader">Web Font Loader</a>だ。ウェブページの描画をブロックする・しないを選択できるので、好みで柔軟に描画のされ方を調節できる。CSSだけで完結とまではいかないが、制御ロジックそのものはクラス名を通してCSSで行えるので、保守性は高い。</p>

<p>標準化されている<a href="http://www.w3.org/TR/css-font-loading/">CSS Font Loading Module Level 3</a>を利用することになる将来も、これと同じようなアプローチになることが予想される。Polyfillとは言えないが、ウェブ標準と親和性が高いものとは言えるだろう。</p>

<p>デメリットはこれまでに上げた手法の高度なラッパーに過ぎないということだ。柔軟でカスタマイズしやすいことは確かだが、このライブラリーに強く依存することを強いられる。名前を挙げることも憚られる某ライブラリーと似たような立ち位置のものと言うと近い。</p>

<h2>Web Storageを使ったキャッシング</h2>

<p>読み込みをインターネット経由で行うことがウェブ・フォントにおける多くの問題の原因である以上、高速に取り出せるローカルにキャッシュがあれば良いというのが骨子となる。<a href="http://www.w3.org/TR/webstorage/">Web Storage (いわゆる<code>localStorage</code>)</a>を使いウェブ・フォントをキャッシングさせれば、インターネットを経由せずに済む。想定通りうまく動けば初期描画の遅延とFOUTという二つの大きな問題は解決される。</p>

<p>Web Storageの実装を見るに、保守性は非常に悪いといえるだろう。キャッシュのリフレッシュまでも視野に入れると更に厳しい。利用を単純化したライブラリーがあれば一瞬光ることはありそうだが、環境の変化(SPDY)により無に帰してしまいそうな技術とも思える。</p>

<hr>

<p>このウェブサイトでもFOUT強制をやめることにした過程で調べたり考えたりしたことを、読み込みの部分だけに特化してざっとまとめてきた。一長一短であるが、それでもあえて選択するとしたらWeb Font Loaderではないかと僕は考える。現状で最も柔軟であることは、軌道修正をする際に非常に助かる。依存しすぎないこととその挙動をしっかりと知ることを念頭に置いてWeb Font Loaderを使うのが良いだろう。</p>

<p>ウェブ・フォントの利用にあたってはその読み込みが最も重要な部分であることは確かだが、他にも考慮すべき点は色々ある。例えばブランド・ロゴに専用のウェブ・フォントを利用する場合は別のタイプフェイスで表示されるということは許されない。その場合はフォールバックさせず、画像を代わりに表示する必要があることだろう。そういう場合は読み込みについては特に凝ったことをしない方がやりやすい可能性も高い。</p>

<p>ともあれ、ウェブ・フォントの利用はウェブサイトへ大きな変化をもたらす。それは見た目だけではなくパフォーマンスについても、だ。そのことの重要な一柱である読み込みについてはしっかりと考えて実装してやる必要があるだろう。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
