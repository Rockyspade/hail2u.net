<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja-JP"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja-JP</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Sat, 24 Jan 2015 01:24:36 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="http://hail2u.net/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>CloudFlareにおけるメール・ソリューションとしてのMailgun</title>
      <link>http://hail2u.net/blog/internet/mailgun-as-an-email-solution-for-cloudflare.html</link>
      <description>Value Domainで取得したドメインをCloudFlareの提供するネームサーバーでGitHub Pagesに向けてやるのは、低コストでウェブサイトをホスティングする優れた手段だ。問題はメールだ。CloudFlareではメール関係の機能はまったく用意されていない。またValue Domainで無料で取得できるXREAのアカウントはメールだけの利用は禁止されている。本道としては別にメール・サーバーを用意するわけだが、転送だけで良いのなら無料枠内で利用することができるMailgunを使うのが良さそうだ。</description>
      <category>Internet</category>
      <guid isPermaLink="true">http://hail2u.net/blog/internet/mailgun-as-an-email-solution-for-cloudflare.html</guid>
      <pubDate>Sat, 24 Jan 2015 01:24:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://www.value-domain.com/">Value Domain</a>で取得したドメインを<a href="https://www.cloudflare.com/">CloudFlare</a>の提供するネームサーバーで<a href="https://pages.github.com/">GitHub Pages</a>に向けてやるのは、低コストでウェブサイトをホスティングする優れた手段だ。問題はメールだ。CloudFlareではメール関係の機能はまったく用意されていない。またValue Domainで無料で取得できるXREAのアカウントはメールだけの利用は禁止されている。本道としては別にメール・サーバーを用意するわけだが、転送だけで良いのなら無料枠内で利用することができる<a href="https://mailgun.com/">Mailgun</a>を使うのが良さそうだ。</p>

<p>Mailgunではアカウントを取得後、まずドメインを追加する。すると計5つのDNSレコードが提供される。</p>

<ul>
<li>認証用のTXTレコードが2つ</li>
<li>送信メールでのトラッキングに使われるリソースのためのCNAMEレコードが1つ</li>
<li>受信用のMXレコードが2つ</li>
</ul>

<p>これらDNSレコードをCloudFlareのコントロール・パネルから設定する。転送のみの場合はトラッキングのためのCNAMEレコードは必要ないが、素直に設定しておくべきだろう。ただしOff CloudFlareにし、トラフィックをバイパスさせておくのは忘れないようにしたい。</p>

<figure>
  <a href="http://hail2u.net/images/blog/mailgun-as-an-email-solution-for-cloudflare-1.png"><img alt="Mailgunで提供される5つのDNSレコードをCloudFlareのコントロールパネルから設定した様子" src="http://hail2u.net/images/blog/mailgun-as-an-email-solution-for-cloudflare-1.png"></a>

  <figcaption>DNS Settings on CloudFlare</figcaption>
</figure>

<p>次にMailgun側でドメインの照合を行うわけだが、その前にMailgunで設定しようとしているドメインのDomain SettingsでInbound Spam FilterをBlock Detected Spamに変更しておくと良い。こうしないとスパムメールをちょくちょく受信するようなメールアドレスをMailgunで処理しようとする場合、即座にDisabledにされてしまう。もしDisabledにされた場合は、まだメールの送信はしていないことなどを添えてサポートから連絡すれば簡単に復活させてはくれる。</p>

<p>続いて改めてドメインの照合を行う。Domain Settingsと同じページにあるCheck DNS Record Nowというボタンを押して照合させる(待っていても自動で照合してはくれない)。うまくいくと各DNSレコードのアイコンが緑の四角に白でチェックマークが描かれたものに変わる。</p>

<figure>
  <a href="http://hail2u.net/images/blog/mailgun-as-an-email-solution-for-cloudflare-2.png"><img alt="Mailgunでドメインの認証用TXTレコードの照合に成功した様子" src="http://hail2u.net/images/blog/mailgun-as-an-email-solution-for-cloudflare-2.png"></a>

  <figcaption>Domain Verification on Mailgun</figcaption>
</figure>

<p>次に受信メールの転送を設定する。これはMailgunのRoutesという機能を使って行う。</p>

<figure>
  <a href="http://hail2u.net/images/blog/mailgun-as-an-email-solution-for-cloudflare-3.png"><img alt="Mailgunで独自ドメインのアドレスからGmailへのメール転送を設定している様子" src="http://hail2u.net/images/blog/mailgun-as-an-email-solution-for-cloudflare-3.png"></a>

  <figcaption>Mail Forwarding Setting on Mailgun</figcaption>
</figure>

<p>Filter Expressionで<code>match_recipient()</code>を使って利用したいメールアドレスを指定し、Actionsで<code>forward()</code>を使って自分のGmailのメールアドレスを指定する。Priorityは他に何もしないのなら0のままで良い。Descriptionはわかりやすい名前を付けておくべきだろう。Filter Expressionで<code>catch_all()</code>を使うといわゆるキャッチオール的な転送も可能だ。</p>

<p>ネームサーバーの切り替えが終了済みなら直ぐに転送が可能になっている。適当なメール・クライアントから実験してみると良い。うまくいっているとメールが転送された上、MailgunではLogsで転送の様子が確認できる。</p>

<figure>
  <a href="http://hail2u.net/images/blog/mailgun-as-an-email-solution-for-cloudflare-4.png"><img alt="Mailgunで正常にメールが転送されていることを確認している様子" src="http://hail2u.net/images/blog/mailgun-as-an-email-solution-for-cloudflare-4.png"></a>

  <figcaption>Viewing Logs on Mailgun</figcaption>
</figure>

<p>Mailgunはクレジットカード情報を登録しない場合、常にFreeアカウントでの運営になる。その場合、<a href="http://documentation.mailgun.com/faqs.html#what-are-the-differences-between-free-and-paid-accounts">いくつかの制限</a>があるが、送信せず転送のみならば問題ない制限だろう。</p>

<hr>

<p>今のところは動いているようだが、何回かDisabledになったので継続運営にはまだかなり不安がある。サポートといろいろ話したところ、既存のメールアドレスをそのまま運用するのはなかなか難しいという話なので、僕は別の手段を探した方が良さそうだ。</p>

<p>日頃からスパムが来ないように注意を払っている人達には十分に機能する手段ではあるだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>Muspy</title>
      <link>http://hail2u.net/blog/internet/muspy.html</link>
      <description>よく聞くアーティストの新譜がリリースされた時にプッシュ通知させるために長らくSoundamusのカレンダーを使っていたんだけど、2014年12月を最後に完全に停止してしまった。Last.fmからアーティストをインポートできて、カレンダーが提供されているサービスという条件で替りになりそうなものを探したが全然ない。しかし簡単に見つかったもののメールとRSSだけか……と試していなかったMuspyが実はiCalでカレンダーを提供していることがわかったので、これに乗り換えることに決めた。</description>
      <category>Internet</category>
      <guid isPermaLink="true">http://hail2u.net/blog/internet/muspy.html</guid>
      <pubDate>Fri, 23 Jan 2015 03:38:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>よく聞くアーティストの新譜がリリースされた時にプッシュ通知させるために長らく<a href="http://www.soundamus.net/">Soundamus</a>のカレンダーを使っていたんだけど、2014年12月を最後に完全に停止してしまった。Last.fmからアーティストをインポートできて、カレンダーが提供されているサービスという条件で替りになりそうなものを探したが全然ない。しかし簡単に見つかったもののメールとRSSだけか……と試していなかった<a href="https://muspy.com/">Muspy</a>が実はiCalでカレンダーを提供していることがわかったので、これに乗り換えることに決めた。</p>

<p>バックエンドは<a href="http://musicbrainz.org/">MusicBrainz</a>のようなので、日本人アーティストにも対応しているんじゃないかと思う。残念な点は未来のリリース予定が見えないところ。カレンダーには1ヶ月先のリリース予定くらいまで含めて欲しい気がする。</p>

<p>ということで<a href="http://en.wikipedia.org/wiki/The_Beautiful_People_(song)">The Beautiful People</a>からもうすぐ20年(！)かと思うと感慨深い人の新譜が出ていることを知ったりした。買わないけど。</p>]]></content:encoded>
    </item>

    <item>
      <title>Sassの変数の仕組みとOOCSS</title>
      <link>http://hail2u.net/blog/webdesign/sass-s-variable-system-and-oocss.html</link>
      <description>A List Apartに掲載されたA Vision for Our Sassという記事を読んでいた。ここに書かれていることが正しいとすると、やはりOOCSSあってのSassなのかなという思いを強くした。でも、今のSassの変数の仕組みとCSSのフラットな構造を考えると、Sassを使ったOOCSSの実現は既に詰みかけている局面だと考えることが多い。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/sass-s-variable-system-and-oocss.html</guid>
      <pubDate>Thu, 22 Jan 2015 02:00:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="http://alistapart.com/article/a-vision-for-our-sass">A List Apartに掲載されたA Vision for Our Sass</a>という記事を読んでいた。ここに書かれていることが正しいとすると、やはりOOCSSあってのSassなのかなという思いを強くした。でも、今のSassの変数の仕組みとCSSのフラットな構造を考えると、Sassを使ったOOCSSの実現は既に詰みかけている局面だと考えることが多い。</p>

<p>例えば<a href="http://alistapart.com/article/a-vision-for-our-sass#section9">Function over Presentation</a>の例を見てみよう。</p>

<pre><code>$primary-color: #b32293; //magenta
$secondary-color: #2f6b49; //green
</code></pre>

<p>これは確かに機能すると思う。しかし大体においてカラーパレットは最低でもあと5色くらいは必要になることが多いだろう。もちろん<code>$primary-color</code>のバリエーションであったりするわけだが、それらの名前付けはどうするのだろうか。例えば名前付けをせずに実際に使われる場所でSassの様々な色関数を利用するという手段がある。</p>

<pre><code>a {
  color: $primary-color;

  &amp;:hover {
    color: darken($primary-color, 20%);
  }
}
</code></pre>

<p>これもうまく機能することだろう。だが今度はこの微調整した色の再利用性は失われる。とするとやはり名前付けを行う必要があるということになるだろう。</p>

<pre><code>$primary-color-dark: darken($primary-color, 20%);
</code></pre>

<p>こうして変数を定義していくとどんどん変数の名前付けが苦しくなっていく。BEMを利用して変数でも頑張って命名規則を細かく規定しても良いだろうが、今度は複数のBEMを取り扱う必要が出てくるかもしれない。カラーパレット用のBEM、ウェブサイト用のBEM、下手をするとプレースホルダー・セレクター用のBEMなどだ。</p>

<p>別のアプローチとしては変数をさらに挟むという手法もある。</p>

<pre><code>$primary-color: #b32293;

$color-a: $primary-color;
$color-a-hover: darken($primary-color, 20%);

a {
  color: $color-a;

  &amp;:hover {
    color: $color-a-hover;
  }
}
</code></pre>

<p>カラーパレットの定義をまず行い、それを参照する形で要素やコンポーネントに応じた変数を作成していく。変数名は元々存在する要素名やクラス名にプリフィックスを加えたものなので、HTML側でクラス名さえちゃんと付ければあんまり困らない。実際にスタイルを当てるパーシャルでもどのような変数を参照するかまったく迷う必要がなくなる。グローバル変数が前提な今のSassだとこのようにして変数を挟むか、再利用性を一部で捨てるかのどちらかに決断しないとならない印象だ。</p>

<p>つまりOOCSSのキモとも言える小さい単位でのスタイルの管理が、今のSassのグローバル変数を強いる仕組みと極端に食い合せが悪いということだ。もう少しするとこの辺りは変化していくわけだが、大幅な概念の変化をもたらす変数の局所化へとスムーズに移行ができるわけもなく、破綻して一から作りなおされるという未来はかなり現実味がある。</p>

<hr>

<p>ではその時にSassを選択する意味・価値はあるのか、というのが今の僕が最も興味を持っている部分だ。結局は厳しい命名規則に縛られた管理を行わざるをえないSassを使ったOOCSSの実現の代わりに、ウェブ標準に寄せたHTML/CSSの書き方で対抗できる可能性があったら面白いなというわけだ。そのためにはHTMLに完全に従属する形でCSSを取り扱う必要があると思うので、構造化されたHTMLを設計するところをスタート地点として、Every Declaration Just OnceのようなCSSでは何も抽象化したりする必要のない書き方を採用すると実現しやすそうかなと考え、色々試し始めたということになる。</p>]]></content:encoded>
    </item>

    <item>
      <title>無印良品のジーンズのラベル素材シリーズ</title>
      <link>http://hail2u.net/blog/gadget/muji-jeans-lable-stationaries.html</link>
      <description>当初のブラウンのものはかなり前に消え、黒のもののみが細々と展開されてたけど、遂に最後の一種類になってた。このシリーズの商品はいくつか買ったけど、中でも文庫本カバーはストックも含め10個くらい買った。昨日、ついに最後のストックをおろした。</description>
      <category>Gadget</category>
      <guid isPermaLink="true">http://hail2u.net/blog/gadget/muji-jeans-lable-stationaries.html</guid>
      <pubDate>Wed, 21 Jan 2015 03:02:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>当初のブラウンのものはかなり前に消え、黒のもののみが細々と展開されてたけど、遂に<a href="http://www.muji.net/store/cmdty/section/S107013804">最後の一種類</a>になってた。このシリーズの商品はいくつか買ったけど、中でも文庫本カバーはストックも含め10個くらい買った。昨日、ついに最後のストックをおろした。</p>

<p>無印良品では同じ名前で提供され続ける商品はある。しかし、継続的に<em>同じ</em>商品が提供されることはあんまりない。同じ名前でもマイナー・チェンジではないような変更がされちゃう。ふと気づくと綿100%ではなくなっていた足なり靴下やチクチクしないバージョンのみになったタートルネックセーターなどがその例。また再販するまでにかなりの間があったりもするので、その間に乗り換えて悲しい思いをしたりもする。PET詰替えボトルのトリガー・スプレーの奴とか。</p>

<p>気に入るものはちょくちょくあるんだけれどもそのうち手に入らなくなるのが怖くて、ここ数年は無印良品のものはなるべく避けようと意識してる。でも他に良いものが見つからなくて結局買ってしまう。そしてなくなり、悲しい思いをする。</p>

<p>文庫本カバー探そう。</p>]]></content:encoded>
    </item>

    <item>
      <title>grunt.util.spawn()のリプレース</title>
      <link>http://hail2u.net/blog/coding/replacing-grunt-util-spawn.html</link>
      <description>Gruntのタスクで実行ファイルなど別プロセスを立ちあげたい場合、通常はうまくラップされたgrunt.util.spawn()を使う。今のところ非推奨というわけではないが、最近の感じだと別パッケージを利用すれば簡単にリプレースできるものはなるべくリプレースした方が良い。例えばgrunt.file.write()はfs-extraパッケージが良い。grunt.util.spawn()はというとio.jsかNode.jsのUnstableが入っている環境ならばspawnSync()とwhich.sync()を組み合わせてリプレースすると良さそうだ。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/replacing-grunt-util-spawn.html</guid>
      <pubDate>Tue, 20 Jan 2015 15:30:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Gruntのタスクで実行ファイルなど別プロセスを立ちあげたい場合、通常はうまくラップされた<a href="http://gruntjs.com/api/grunt.util#grunt.util.spawn"><code>grunt.util.spawn()</code></a>を使う。今のところ非推奨というわけではないが、最近の感じだと別パッケージを利用すれば簡単にリプレースできるものはなるべくリプレースした方が良い。例えば<code>grunt.file.write()</code>は<a href="https://www.npmjs.com/package/fs-extra">fs-extra</a>パッケージが良い。<code>grunt.util.spawn()</code>はというとio.jsかNode.jsのUnstableが入っている環境ならば<code>spawnSync()</code>と<code>which.sync()</code>を組み合わせてリプレースすると良さそうだ。</p>

<p>別プロセスを立ち上げる辺りはだいたい以下のような形になっていることと思う。</p>

<pre><code>var done = this.async();

grunt.util.spawn({
  cmd: &#39;foo&#39;,
  args: [&#39;--bar&#39;],
  opts: {
    stdio: &#39;inherit&#39;
  }
}, function (error, result, code) {
  if (error) {
    return done(error);
  }

  done();
});
</code></pre>

<p>ストレートに書き換えると、以下のようになるだろう。</p>

<pre><code>var spawn = require(&#39;child_process&#39;).<mark>spawnSync</mark>;
var which = require(&#39;which&#39;).sync;
var child = spawn(<mark>which(&#39;foo&#39;)</mark>, [&#39;--bar&#39;], {
  stdio: &#39;inherit&#39;
});

if (child.error) {
  grunt.fail.warn(child.error);
}
</code></pre>

<p>まず必要なパッケージを読み込む。コールバックがなくなるので<code>this.async()</code>を呼ぶ必要はない。<code>child_process.spawnSync()</code>はエラーが起きたら返り値のオブジェクトの<code>error</code>プロパティーにErrorオブジェクトを格納するので、それをチェックしてエラーを返してやるのみ。</p>

<p>コマンドを<code>which.sync()</code>でラップしてやっているのは、<code>child_process.spawnSync()</code> (<code>child_process.spawn()</code>も)がWindowsで<code>PATHEXT</code>環境変数を考慮してくれないことへ対策するためだ。ラップしてやらないと.batや.cmdで定義されているコマンドの場合、見つけることが出来ずENOENTで落ちてしまう。</p>

<p>別プロセスに何かをしてもらうだけのタスクの場合はこれで良いが、標準出力を受け取って……という場合は<code>stdout</code>プロパティーを拾ってやれば良い。ただしデフォルトではBufferオブジェクトなので、<code>child_process.spawnSync()</code>の第三引数であるオプションで<code>encoding</code>を指定してやりStringオブジェクトになるようにして、後に受け取るのが簡単だろう。</p>

<pre><code>var child = spawn(which(&#39;foo&#39;), [&#39;--bar&#39;], {
  encoding: &#39;utf8&#39;
});
</code></pre>

<p>エラーチェックはもうちょっと厳密な必要がありそうだ。そうしないとゾンビプロセスが残ったり、タスクがうまく終了しなくなる可能性がある。でもまだ<code>child_process.spawnSync()</code>の知見がなくてよくわからない。</p>

<hr>

<p>なぜリプレースするかというと、後にNode.js製の別の何か向けに書きなおす時にまずは書きなおしやすくするためだ。最終的にはフルスクラッチで書きなおした方が良いことが多いだろうが、まず簡単に書きなおせるようにしておくと移行コストが大きく下がる。依存を大きくする(Gruntべったり)か依存を増やす(Node.jsパッケージいっぱい)かという選択で、後者を取るというわけだ。</p>

<p>もちろん今はまだ公開するGruntタスクは書きかえるべきではない。io.jsのインストールを要求するのは馬鹿げている。そのうちNode.js v0.12系などが出て安心版でサポートされるようになったら書きかえてやっても良いかもしれない。まずは手元のオレオレタスクを書きかえてみるくらいが良い。</p>]]></content:encoded>
    </item>

    <item>
      <title>チーズ・スコーン</title>
      <link>http://hail2u.net/blog/misc/cheese-scones.html</link>
      <description>TLにちょくちょくスコーン焼いた写真が飛んでくるので、我慢できなくなって夕飯後に焼いてた。慣れると30分くらいで作れてちょっとした遊びっぽくて楽しい。ドライフルーツみたいなのが何もなかったので、チーズを入れた。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/cheese-scones.html</guid>
      <pubDate>Mon, 19 Jan 2015 03:10:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <img alt="焼きたてのスコーン、ところどころ濃く焦げているところはチーズ" src="http://hail2u.net/images/blog/cheese-scones.jpg">
</figure>

<p>TLにちょくちょくスコーン焼いた写真が飛んでくるので、我慢できなくなって夕飯後に焼いてた。慣れると30分くらいで作れてちょっとした遊びっぽくて楽しい。ドライフルーツみたいなのが何もなかったので、チーズを入れた。</p>

<p>レシピは<a href="http://www.e-gohan.com/recipe/830.html">いいごはんにあったチーズスコーンのレシピ</a>を1.5倍にし、塩をなくして、チーズを減らしたもの。作り方は同じ。</p>

<table>
<thead>
<tr>
<th>材料</th>
<th style="text-align:right">分量</th>
</tr>
</thead>
<tbody>
<tr>
<td>小麦粉</td>
<td style="text-align:right">150g</td>
</tr>
<tr>
<td>ベーキングパウダー</td>
<td style="text-align:right">小さじ 2</td>
</tr>
<tr>
<td>砂糖</td>
<td style="text-align:right">小さじ 4</td>
</tr>
<tr>
<td>バター</td>
<td style="text-align:right">50g</td>
</tr>
<tr>
<td>チーズ</td>
<td style="text-align:right">40g</td>
</tr>
<tr>
<td>牛乳</td>
<td style="text-align:right">75ml</td>
</tr>
</tbody>
</table>

<p>この分量で直径5cmくらいに膨らむ。バーミックスのスライシーがあると、粉ふるうのから、牛乳を入れて生地をまとめるとこまで一つの容器で完結する。このレシピの場合、型抜きせずに手で丸めて焼くのも片付けが楽で良い。</p>

<p>味見だけはしたけど、夜に食べない誓いがあるのでまだ食べてない……。</p>]]></content:encoded>
    </item>

    <item>
      <title>厚いレイヤー</title>
      <link>http://hail2u.net/blog/webdesign/thick-layer.html</link>
      <description>Sitepointに書かれたBEMやSMACSSを使っている開発者たちからのアドバイスを読んでいた。僕は今いかにして命名規則をなくすかといったことを考えている最中のため否定的に読んだが、それでもここに書かれたアドバイスは正しいとは感じた。BEMやSMACSSが概ね想定以上に機能することは確かだし、スケールするし、指揮もとりやすい。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/thick-layer.html</guid>
      <pubDate>Sun, 18 Jan 2015 01:44:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Sitepointに書かれた<a href="http://www.sitepoint.com/bem-smacss-advice-from-developers/">BEMやSMACSSを使っている開発者たちからのアドバイス</a>を読んでいた。僕は今いかにして命名規則をなくすかといったことを考えている最中のため否定的に読んだが、それでもここに書かれたアドバイスは正しいとは感じた。BEMやSMACSSが概ね想定以上に機能することは確かだし、スケールするし、指揮もとりやすい。</p>

<p>僕が避けたいのは<em>何かしらへの強い依存</em>だ。薄いレイヤーならともかく、厚いレイヤーの場合は重度の依存をもたらす。その依存はこれからもそのまま通用するのかというと、不安が大きい。厚いレイヤーとは心中する覚悟が必要というのは正しいが、多くの場合心中する羽目になるのは導入した人ではなかったりもする。もっと薄いレイヤーでウェブ標準(など)に寄せた形の解があれば安心できるはずだ。</p>

<p>HTML 4.01に対するHTML5を始めとして、CSS 2.1に対するCSS 3、いわゆるJavaScriptに対するECMAScript 6は比較的薄い(技術的な点ではなく、アプローチとして)レイヤーと言える。こういったものなら移行もスムーズだし、受け入れられやすいし、学びやすいし、将来への不安も少ない。ウェブ標準外でそのようなものを実現できた・実現しているものを挙げるとすると、HTMLに対するMarkdownやMustache、CSSに対するSassのSCSS記法、JavaScriptに対するTypeScriptや6to5だろうか。</p>

<p>厚いレイヤーとして作られているものは多い。例えばHTMLに対するTextileやHAML、Jade、Slimであったり、CSSに対するSassのインデント記法やStylusの省略記法であったり、JavaScriptに対するCoffeeScriptであったり、だ。筋が悪いわけでもなく、現在の選択肢としては適当で、むしろ現時点では厚いレイヤーのこれらの方が評価されることも多い。これらはウェブ標準のしがらみから飛び出してその枝を延ばし、開発者に生産性を始めとした多くの果実を与えるからだ。</p>

<p>BEMやSMACSSがどちらに属すかというと、それは微妙なところだ。ウェブ標準とは特に干渉するわけではないのでそういう点では薄いが、命名規則なるものがウェブ標準にはないことを考えると、分厚く新たなレイヤーを追加してしまうものとも言える。その習得難易度や複雑化しつづける規則に鑑みると、厚いレイヤーになりつつあるのかなと感じる。</p>

<hr>

<p>と言いつつ<a href="https://github.com/hail2u/hail2u.net-styles">このウェブサイトのCSS</a>は<a href="http://hail2u.net/blog/webdesign/sass-and-bem.html">BEMをベースにしたアプローチ</a>でプレースホルダー・セレクターとネストに意味を持たせて制作していたりする。この方法はかなり複雑なので汎用的ではないが、BEMのブロック・エレメント・モディファイアーという概念を継承したCSSの構造化というのは悪い解ではない。しかしそこに本来構造化されている(はず)のHTMLがあるのにも関わらず、その更に上に命名規則による構造化を行うレイヤーを設けることに疑問を持ち始めた。</p>

<p>そんなわけでOOCSSを絶対として生まれたBEMやSMACSSといった命名規則に基づくCSSアーキテクチャーという代物を廃棄するため、<a href="http://hail2u.net/blog/webdesign/oocss-drawbacks-and-gifts-of-every-declaration-just-once.html">同じ定義を二度書かないアプローチ</a>を試行錯誤しているわけだ。BEMが嫌いになったとかそういうわけではなく、CSSアーキテクチャーなる代物が本当に必要なのかという疑問に対する答えを探すためだ。しっかりと構造化されたHTMLへ完全に従属させる形でCSSを書いても、昨今の高機能ないわゆる開発者ツールの助けがあればうまく機能するのではないか、というような思いつきを証明できるかというような話でもある。</p>]]></content:encoded>
    </item>

    <item>
      <title>CSSWring v3.0.0とCSS MQPacker v3.0.0のリリース</title>
      <link>http://hail2u.net/blog/webdesign/csswring-and-css-mqpacker-v3.0.0.html</link>
      <description>CSSWringとCSS MQPackerのメジャー・バージョンをそれぞれ更新した。中身としてはPostCSSをv4.0.0に更新しただけと言って良い。PostCSS v3でしか動作しないツールやプラグインと組み合わせたい場合は引き続き古いバージョンを利用する必要がある。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/csswring-and-css-mqpacker-v3.0.0.html</guid>
      <pubDate>Sat, 17 Jan 2015 01:13:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://www.npmjs.org/package/csswring">CSSWring</a>と<a href="https://www.npmjs.com/package/css-mqpacker">CSS MQPacker</a>のメジャー・バージョンをそれぞれ更新した。中身としてはPostCSSをv4.0.0に更新しただけと言って良い。PostCSS v3でしか動作しないツールやプラグインと組み合わせたい場合は引き続き古いバージョンを利用する必要がある。</p>

<p>実際には結構簡単に対応はできたのだけど、CSS MQPackerでの空白の取り扱いでどうしようかなという感じだった。具体的に言うと<code>@charset</code>ルールだけのような<code>between</code>プロパティー(<code>@charset</code>ルールの場合はその値と<code>;</code>の間の空白)のないCSSに普通のルールセットを突っ込むとその<code>between</code>プロパティー(ルールセットの場合はセレクターと定義群を括る<code>{</code>の間の空白)が消えてしまう問題についてだ。</p>

<p>例えばこのようなCSSをCSS MQPackerで処理すると、想定外の結果になる。</p>

<pre><code>@charset &#39;UTF-8&#39;;

@media (min-width: 1px) {
  .foo {
    display: block;
  }
}
</code></pre>

<p><code>@media</code>ルールをまとめながら退避させていくと、このCSSは<code>@charset</code>ルールのみになる。そのため改めてまとめた<code>@media</code>ルールを追加しなおすと、以下のように改行とインデント、セミコロンがPostCSSのデフォルトへと修正された上で、クエリーや<code>.foo</code>と<code>{</code>の間の空白が消えてしまう。</p>

<pre><code>@charset &#39;UTF-8&#39;;
@media <mark>(min-width: 1px){</mark>
    <mark>.foo{</mark>
        display: block
    }
}
</code></pre>

<p>内部の細かい挙動を理解すれば納得できる結果ではあるが、直感的ではない。<code>between</code>プロパティーだけ<a href="https://github.com/postcss/postcss/blob/5b86e6a94de9309cb354fcadd23f23249c174854/lib/node.js#L404-L417">デフォルトのスタイル</a>が定められておらず、ところどころで<a href="https://github.com/postcss/postcss/blob/5b86e6a94de9309cb354fcadd23f23249c174854/lib/node.js#L379-L390">特別視</a>されていることから、うまくコピーできてしまってこうなるようだ。同じ<code>between</code>という名前で違うものを扱おうとしていることが原因なのではないかと想像している。</p>

<p>ちょっと実装として気になるので、このあたりは今後変わりそうではある。もしこの<code>between</code>プロパティーをいじるようなツールやプラグインを作っている場合は注意した方が良さそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>node-edjo</title>
      <link>http://hail2u.net/blog/webdesign/node-edjo.html</link>
      <description>Every Declaration Just Onceのスタイルに既存のCSSを変換し、どのような感じになるのかを確認するためのツールを書いてた。node-edjoとしてGitHubに公開しておいたので、Node.js互換の何かがあればnpmでインストールして誰でも使える。ただしnpmリポジトリーには公開されることはないので、READMEに書いてあるようにユーザー名とリポジトリー名を使ってインストールする。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/node-edjo.html</guid>
      <pubDate>Fri, 16 Jan 2015 00:03:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Every Declaration Just Onceのスタイルに既存のCSSを変換し、どのような感じになるのかを確認するためのツールを書いてた。<a href="https://github.com/hail2u/node-edjo">node-edjo</a>としてGitHubに公開しておいたので、Node.js互換の何かがあればnpmでインストールして誰でも使える。ただしnpmリポジトリーには公開されることはないので、READMEに書いてあるようにユーザー名とリポジトリー名を使ってインストールする。</p>

<p>完全な変換ツールではないので、これを使って移行とかは無理。ルールセットの順序が入れ替わっているので、CSSとしてちゃんと機能するかも未知数なものに変換されちゃう。あくまでもCSSがどのような感じになるのかがわかるだけのツールで、どれくらいのセレクターが集まってくるのかとか、定義はDRYだけどセレクターがDRYじゃないのはどの程度わかりづらそうなのかとかそういうものを感じるとっかかりという程度のツール。</p>

<p>実際にこのウェブサイトのCSSを変換すると、<a href="https://github.com/hail2u/node-edjo/blob/4f38d140b7080bd0e55a53d9beb8fad0035c20ff/test.edjo.css">まぁまぁ想定通りの形</a>に変換され(てホッとし)た。もっとアバンギャルドな感じになるかもしれないとヒヤヒヤしていたので、これくらいなら「とんでもない！」という程でもない気がする。ひいき目だけど。ところどころ変なところに改行が入っているのはSassのせいで、PostCSSでもこのツールのせいでもない。</p>

<p>EDJOのダメそうなところは改めてちゃんと書きたい。このツールを使いつつ色々考える。</p>]]></content:encoded>
    </item>

    <item>
      <title>OOCSSの欠点とEvery Declaration Just Onceのもたらすもの</title>
      <link>http://hail2u.net/blog/webdesign/oocss-drawbacks-and-gifts-of-every-declaration-just-once.html</link>
      <description>昨日も少し書いたEvery Declaration Just Onceアプローチ(以下EDJOと略す)について、皆が目を瞑っているOOCSSの欠点、CSSが持つ特徴、HTMLとの兼ね合いという点からもう少し書いてみたい。これについては未だ誰ともちゃんと議論していない。機会があったらこの記事をベースにでも誰かと話してみたい。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/oocss-drawbacks-and-gifts-of-every-declaration-just-once.html</guid>
      <pubDate>Thu, 15 Jan 2015 11:29:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>昨日も少し書いた<a href="https://developers.google.com/speed/articles/optimizing-css">Every Declaration Just Onceアプローチ</a>(以下EDJOと略す)について、皆が目を瞑っているOOCSSの欠点、CSSが持つ特徴、HTMLとの兼ね合いという点からもう少し書いてみたい。これについては未だ誰ともちゃんと議論していない。機会があったらこの記事をベースにでも誰かと話してみたい。</p>

<p>上記Googleの文書は、主にパフォーマンスの観点で書かれている。どうしても長くなりがちな定義を分散して書くよりも、能動的に短くすることができるセレクターを分散して書いた方が、プロダクションにおいてリリースされるCSSファイルのサイズを小さくすることが可能だろうというものだ。同時にこの文書の筆者は自身のブログで、<a href="http://meiert.com/en/blog/20141009/css-dry-and-optimization/">より自然にCSSを書くための手法(原文: <q>The Natural Way of Writing CSS</q>)</a>としてこのEDJOという手法について述べている。</p>

<p>僕は主にそういったCSSの書き方という観点からEDJOに注目した。この記事もそれに従って書かれている上、パフォーマンスについてはGoogleの文書で十分に書かれているので、以下では特に触れない。</p>

<h2>OOCSSとは</h2>

<p>まずはOOCSSについてざっと触れておく。OOCSSではいくつかの<a href="http://www.w3.org/TR/CSS2/syndata.html#rule-sets">定義</a>(プロパティーとその値のセット)を組み合わせることにより再現できる見た目をオブジェクトとみなし、それを継承・拡張していく。オブジェクトは一定の意味を持つ単位で作成され、それを組み合わせることで振る舞いベースで、ウェブサイトのビジュアル・デザインを完成させていくことができるというわけだ。</p>

<p>実際に継承と拡張を行う手段は、オブジェクトとして定義されたクラスを複数組み合わせていく手法、いわゆる<em>マルチ・クラス</em>による。今ではCSSプリプロセッサーなどもあるが、例えばSassの<code>@extend</code>を使ったロジカルな継承は開発者間での濃いコミュニケーションによる意識の摺り合わせが必須とも言えるので、まだまだマルチ・クラスで行われている、行われるだろうと言って良い。</p>

<p>もし仮に後で書かれたセレクターの方が必ず強いというようなシンプルな仕組みであったら、マルチ・クラスはその想定通りうまく機能しただろう。しかしそうはいかない。</p>

<h2>セレクターの詳細度</h2>

<p>CSSでは<a href="http://www.w3.org/TR/CSS2/cascade.html#specificity">セレクターの詳細度</a>というものがある。例えば<code>.foo</code>より<code>.bar .foo</code>が強いというような、セレクターの書かれた順序を越えて定義が適用される仕組みだ。</p>

<pre><code>body h1 {
  font-family: serif;
}

h1 {
  font-family: sans-serif;
}
</code></pre>

<p>このCSSの場合<a href="http://hail2u.net/pub/test/606.html"><code>h1</code>は<code>serif</code>で表示されること</a>だろう。OOCSSにおいてマルチ・クラスを利用する場合、このセレクターの詳細度というものと格闘する必要が出てくる。なぜかと言えばオブジェクトとして定義された<a href="http://www.w3.org/TR/CSS2/syndata.html#rule-sets">ルールセット</a>の順序通りにビジュアル・デザインが適用されていくとは限らないからだ。</p>

<p>詳細度の仕組みは仕様を読むと簡単に書かれているが、実際にはそこそこ複雑だ。自然、その理解度が人によりまちまちであることも頭に入れておく必要がある(僕も正直8割強くらいしか理解している自信はない)。そうなるといかにしてこのような仕組みが発動しないようにCSSを書くか、ということになる。</p>

<h2>クラスの命名規則</h2>

<p>つまりセレクターでクラス名を二つ以上使わないようにし、すべてのセレクターの詳細度を等しくするわけだ。もちろん要素名やIDなどはこの世に存在しないものとみなして忘れ去ってしまえば良い。そうすることですべてのオブジェクト(=ルールセットに書かれた定義たち)はひとつのクラス名で表現されたセレクターにより割り当てられていくため、その書かれた順番に従ってその定義が上書きされていくようになる。</p>

<p>問題はクラス名の付け方だ。詳細度の仕組みの都合上、クラス名を複数組み合わせることはできない。つまり以下のようなセレクターは書くことが出来ない。</p>

<pre><code>.global-header .nav .item .icon {
  ...
}
</code></pre>

<p>従ってこのようなクラス名を付けることになる。</p>

<pre><code>.global-header-nav-item-icon {
  ...
}
</code></pre>

<p>HTMLは当然のようにこうなる。</p>

<pre><code>&lt;header class=&quot;global-header&quot;&gt;
  ...
  &lt;nav class=&quot;global-header-nav&quot;&gt;
    &lt;li class=&quot;global-header-nav-item&quot;&gt;
      &lt;span class=&quot;global-header-nav-item-icon&quot;&gt;&lt;/span&gt;
      &lt;span class=&quot;global-header-nav-item-title&quot;&gt;Blog&lt;/span&gt;
    &lt;/li&gt;
    ...
  &lt;/nav&gt;
&lt;/header&gt;
</code></pre>

<p>おおっと。</p>

<p>マルチ・クラスによる割り当てになるので、実際にはもう少しシンプルな値にはなる。が、それと同時に短いとはいえ別のクラス名が追加されていくので、<code>class</code>属性の値は概ねこのような複雑なものになっていく。更にこういった単純に連結したり組み合わせたりするだけの命名規則では表現できない概念を補足するように鍛えていくと、<a href="https://smacss.com/">SMACSS</a>や<a href="http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/">MindBEMding</a>、そして今最も注目度が高い<a href="https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md">SUIT CSSの命名規則</a>へと進化することになる。</p>

<p>かくしてHTMLでは各要素に<code>class</code>属性として20–50文字くらいの値がちょくちょく割り当てられていくようになった。CMSやビルド・ツールを前提にしないと保守できない状態だといえるだろう。</p>

<h2>Every Declaration Just Once</h2>

<p>すべての定義を一度だけしか書かないこのアプローチ、EDJOではOOCSSとはCSSを書く手順が逆になる。</p>

<p>OOCSSではオブジェクトといういくつかの定義の組み合わせであるルールセットをまず書き、それにクラス名を使って名付ける。そしてHTMLに戻り、そのオブジェクトを割り当てたい要素に対し、クラス名を振っていく。</p>

<p>EDJOではまずHTMLで適切なクラス名(IDでも良いだろう)を振っておく。誤解を恐れずに言うのならば、セマンティックなクラス名とかそのようなもので、ウェブページにおいてその要素がどのようなものかを表現するクラス名だ。IDでも良いだろうし、HTML5の強い意味付けを持つ要素をきちんと使い分けているならクラス名やIDを付けなくても良いこともあるかもしれない。またクラス名は再利用しないので、抽象化した名称(例えば<code>.clearfix</code>であったり<code>.column-wrapper</code>など)である必要もない。</p>

<p>そしてCSSではビジュアル・デザインを決定する定義をまず書き、それを適用するセレクターを割り当て、ひとつの定義ごとにルールセットを作っていく。例えばこのような形だ。わかりやすいように様々なパターンでセレクターを書いてみたが、実際には開発者やプロジェクトごとにパターン化されてくるだろう。とりあえず一意に確定する形で書いておけば、後で置換をかけることでそのフォーマットを統一することも容易いはずだ。</p>

<pre><code>body &gt; header,
main,
.searchbox,
[role=&quot;contentinfo&quot;] {
  margin: 0 auto;
}

body &gt; header,
[role=&quot;contentinfo&quot;] {
  background-color: #333;
}

main {
  background-color: #fff;
}

.searchbox {
  background-color: #999;
}
</code></pre>

<p>EDJOではセレクターの詳細度はほとんど無視することができる。なぜならある要素を表現するセレクターは常に同じで良いからだ。つまりある要素に複数のクラス名が割り当てられることはないし、同じ要素を違うセレクターで参照することもないということで、それゆえに値の上書きがそもそも起こらないということになる。状態を表すようなクラスは別途追加する必要が出てくるが、例外はそれくらいだろう。</p>

<p>このようにEDJOでは、セレクターの詳細度という<em>あまり理解されていない仕組み</em>とクラスの命名規則という<em>守らせることはおろかまず作ることからして難しい仕組み</em>を共に意識せずにCSSとHTMLを書いていくことができるということだ。それはつまりHTMLはHTMLで書くことができ、CSSはCSSで書くことができ、更にその両者の結びつけを同じ定義を二度書かないという単純明快なルールのみで行うことができるということでもある。</p>

<hr>

<p>OOCSSの欠点はその思想や哲学、ベースとなった技術の問題ではない。ツリー構造を持つHTMLやカスケーディングという独自の継承の仕組みを持つCSSとは根本的に相性が悪く、命名規則というような運用におけるルール付けでカバーしなくてはならないところだ。もしHTMLやCSSがもう少し違うものだったら、OOCSSは間違いなく論理的で明確な方向性をウェブデザインに与える唯一無二の手法であった、そしてありつづけるものだったろう。しかし現実は違うし、未来もそうなりそうもない(セレクターのネストが可能になるとわからないけれども)。</p>

<p>そこでCSSにおいてその力不足を補い、OOCSSのような論理的なアプローチを可能にしようとするために生まれたのがCSSプリプロセッサーだった。しかしこれもOOCSSの欠点を完全にはカバーすることは出来てはいない。そのため既に名前だけは何回か出したSUIT CSSの命名規則のようなものが、ここに至っても生まれた(生まれてしまった)というわけだ。</p>

<p>EDJOがCSSを本来あるような形に戻したものだと捉えると、もはやCSSプリプロセッサーはCSSを無闇に複雑にしてしまっただけにも感じられてしまう。EDJOならCSS Variableのみのプリプロセッサーで十分機能しそうだ。</p>

<hr>

<p>ひとつ、声を大きくして謝りたいのは、フロントエンド側じゃない人たちのCSSの書き方にダメ出しをしていたことだ。過去の僕はOOCSSをいかにして再現するかを重要視しており、OOCSSへの理解に欠ける人たちによるEDJO的な書き方(定義があるところに雑にセレクターを追加していく書き方)に対してかなり厳しく反論していたように思う。OOCSSを採用している以上、そういったEDJO的な書き方を否定することは間違っていたわけではないのだけど、その時の論理は「OOCSSだから～」というような、今思うと曖昧な、当時も理由としては弱いと薄々気付いていた言葉で押し通していた。</p>

<p>その頃にもう少しOOCSSの欠点について掘り下げていればそういった書き方にも一理以上の何かがあったことに気づけたはずだ。広く受け入れられているアプローチだからというような理由で盲信するのは良くないが、それを実践するのはなかなか難しい。もちろんこのEDJOというアプローチにも言えることだ。気をつけながらEDJOの世界をもうちょっと掘り起こしていこうと思う。</p>

<p>もしMindBEMdingのようなBEMライクな命名規則から、よりわかりやすく強力なSUIT CSSの命名規則に移行しようかなと考えている人がいたら、ちょっとだけEvery Declaration Just Onceというアプローチを試してみて欲しい。僕はこのアプローチを試した結果、OOCSSの実装の難しさにより嫌いになりかけたCSS(Sassでかろうじて理性を保ってやり過ごしてきていたが)を本気でもう一度好きになれそうな気がしてきている。HTMLとCSSが疎結合する未来を夢見ていた人達なら、OOCSSが唯一無二の解ではないという前提だと、このアプローチに未来を見出すことができるのではないだろうか。</p>

<h2>追記</h2>

<p>参照したGoogleのEDJOに関する文書とこの記事の内容が乖離していたことに気づいていなかったので、本来的に参照するべきJens Oliver Meiertのブログ記事へのリンクを追加した。両文書は同じ筆者による記事ではあるが、違う観点によって書かれているので、両方参照するべきだった。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
