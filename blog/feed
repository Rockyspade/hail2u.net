<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Tue, 3 Mar 2015 07:34:24 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>media_query_listのパース</title>
      <link>http://hail2u.net/blog/coding/parsing-media-query-list.html</link>
      <description>Media Queriesの各クエリーは、featureとexpのセットもしくはmedia_typeでexpressionが、expressionをandで繋いでmedia_queryが、media_queryをカンマで繋いでmedia_query_listになり、それで完成する。そこそこ正確にパースしてJavaScriptから扱えるようにするためには、まずカンマで区切り、更にandキーワードまたはスペースで区切り、更に同じfeatureがあることを考慮した多次元配列に変換してやる必要がありそうだ。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/parsing-media-query-list.html</guid>
      <pubDate>Tue, 03 Mar 2015 07:34:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Media Queriesの各クエリーは、<code>feature</code>と<code>exp</code>のセットもしくは<code>media_type</code>で<code>expression</code>が、<code>expression</code>を<code>and</code>で繋いで<code>media_query</code>が、<code>media_query</code>をカンマで繋いで<code>media_query_list</code>になり、それで完成する。そこそこ正確にパースしてJavaScriptから扱えるようにするためには、まずカンマで区切り、更に<code>and</code>キーワードまたはスペースで区切り、更に同じ<code>feature</code>があることを考慮した多次元配列に変換してやる必要がありそうだ。</p>

<p>まず存在しなさそうだが、以下のようなクエリーも理論上はありうる。</p>

<pre>only
  screen and
  (min-width: 1em) and
  (min-width: 2em),
not
  (min-width: 3em) and
  (min-height: 4em) and
  (min-height: 5em)
</pre>

<p>例えばこのようなクエリーを以下のようにできれば良さそうだ。</p>

<pre><code>var mediaQueryList = [
  {
    &#39;min-width&#39;: [&#39;1em&#39;, &#39;2em&#39;],
    &#39;only&#39;: true,
    &#39;screen&#39;: true
  },
  {
    &#39;min-height&#39;: [&#39;4em&#39;, 5em&#39;],
    &#39;min-width&#39;: [&#39;3em&#39;],
    &#39;not&#39;: true
  }
];
</code></pre>

<p>こうするための実装を書いているけどすごい面倒くさくて嫌になってきている。<code>min-width</code>が複数回出てきても良いとか想定していなかった。</p>

<hr>

<p>パースは出来たとしてもどう扱ってソートするかでまた面倒くさい。<code>min-width</code>に絞っていても<code>media_query</code>の中で<em>最大</em>かつその中で<em>最小</em>を基準にソートする必要がありそうだ。他に<code>print, (min-width: 1em)</code>みたいなものの判断も難しい。もうちょっと時間かかりそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>node-feedmix</title>
      <link>http://hail2u.net/blog/coding/node-feedmix.html</link>
      <description>xml2jsを使って複数のRSS 2.0をマージするパッケージ、FeedMixを作った。手元で結構前から使っていたGruntタスクをNode.jsパッケージにして、それを叩くだけのGruntタスクを同梱するという形にした。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/node-feedmix.html</guid>
      <pubDate>Mon, 02 Mar 2015 06:26:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/Leonidas-from-XIV/node-xml2js">xml2js</a>を使って複数のRSS 2.0をマージするパッケージ、<a href="https://github.com/hail2u/node-feedmix">FeedMix</a>を作った。手元で結構前から使っていたGruntタスクをNode.jsパッケージにして、それを叩くだけのGruntタスクを同梱するという形にした。</p>

<p>混ぜたいRSSファイルを配列として<code>merge()</code>の引数に指定する。XMLファイルではない場合はxml2jsが、RSSファイルではなさそうな場合はFeedMixがそれぞれ例外を吐いて落ちる。落ちる。</p>

<pre><code>var feedmix = require(&#39;feedmix&#39;);
var fs = require(&#39;fs&#39;);

var a = f.readFileSync(&#39;a.rss&#39;, &#39;utf8&#39;);
var b = f.readFileSync(&#39;b.rss&#39;, &#39;utf8&#39;);
var c = f.readFileSync(&#39;c.rss&#39;, &#39;utf8&#39;);
var m = feedmix.merge([a, b, c], {
  trim: true
});
</code></pre>

<p>これで<code>m</code>の中身が<code>b.rss</code>と<code>c.rss</code>のすべての<code>item</code>要素を<code>a.rss</code>へ混ぜ込んだJavaScriptオブジェクトになる。<code>item</code>は<code>pubDate</code>要素の値を使ってソートされるが、切り詰められたりはしない。<code>channel</code>要素は<code>a.rss</code>のものが採用されるが、<code>lastBuildDate</code>要素の値のみ最初の<code>item</code>要素の<code>pubDate</code>要素の値がコピーされ書き換えられる。</p>

<pre><code>console.log(feedmix.stringify(m, {
  cdata: true,
  xmldec: {
    encoding: &#39;UTF-8&#39;,
    version: &#39;1.0&#39;
  }
}));
</code></pre>

<p>XMLへの変換は<code>stringify()</code>へパース結果のオブジェクトを渡して行う。xml2jsのビルダーの単なるラッパーで、特に何もしない。</p>

<p>また<code>merge()</code>では第二引数にxmljsのパーサーのオプションが、<code>strigify()</code>ではxml2jsのビルダーのオプションがそれぞれ指定できる。ただしパーサーの<code>explicitArray</code>オプションはパース後のオブジェクトの構造を変えてしまうので、強制的に<code>true</code>にしているため指定しても効果はない。他にも指定するとおかしくなるオプションがあるかもしれない。</p>

<hr>

<p>同梱されているGruntタスクも凝ってはいない。</p>

<pre><code>feedmix: {
  main: {
    options: {
      builder: {
        cdata: true,
        xmldec: {
          encoding: &#39;UTF-8&#39;,
          version: &#39;1.0&#39;
        }
      },

      parser: {
        trim: true
      }
    },

    dest: &#39;build/feed&#39;,
    src: [
      &#39;src/feed/index.rss&#39;,
      &#39;build/blog/feed&#39;
    ]
  }
}
</code></pre>

<p>こちらは<code>src</code>でファイルを指定してやると<code>dest</code>にマージした結果を吐いてくれる。動的マッピングだと配列の順序が思ったようにいかない可能性があるので、普通に指定したほうが良いだろう。<code>options.builder</code>と<code>options.parser</code>経由で<code>stringify()</code>と<code>merge()</code>に渡すオプションを指定することはできるので、入出力もモジュールと同等に制御することができる。</p>

<hr>

<p>RSS 1.0とかAtomとかもうよく知らないので無視した。RSS 0.9xなどは通ってしまいそうな気がする。</p>]]></content:encoded>
    </item>

    <item>
      <title>indexのマークアップとpermalinkのマークアップ</title>
      <link>http://hail2u.net/blog/webdesign/index-markup-and-permalink-markup.html</link>
      <description>何らかのツールでテンプレートを元にページを生成する昨今、あまりページごとに大きくアウトラインの構造(変な表現だ)が変わることはない。枠を作って流し込む、枠を作って流し込む、というわけだ。ウェブではコンテンツは主に文章であるので、流動性はそれなりに高く、流しこむこと自体は多くの場合は問題にならないが、もうちょっと考えても良い所ではある。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/index-markup-and-permalink-markup.html</guid>
      <pubDate>Sun, 01 Mar 2015 03:49:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>何らかのツールでテンプレートを元にページを生成する昨今、あまりページごとに大きくアウトラインの構造(変な表現だ)が変わることはない。枠を作って流し込む、枠を作って流し込む、というわけだ。ウェブではコンテンツは主に文章であるので、流動性はそれなりに高く、<em>流しこむこと</em>自体は多くの場合は問題にならないが、もうちょっと考えても良い所ではある。</p>

<p>典型的なウェブログのindexのページは以下のような構造になっていることだろう。</p>

<ul>
<li><code>header</code></li>
<li><code>main</code><ul>
<li><code>article</code></li>
<li><code>article</code></li>
<li><code>article</code></li>
</ul>
</li>
<li><code>footer</code></li>
</ul>

<p>これから自身以外の<code>article</code>要素を取り除いたものがpermalinkのページ構造になる。</p>

<ul>
<li><code>header</code></li>
<li><code>main</code><ul>
<li><code>article</code></li>
</ul>
</li>
<li><code>footer</code></li>
</ul>

<p>この時点で<code>main</code>要素でグルーピングする意味はほとんどなくなる。合わせてpermalinkでは文書のプライマリ・コンテンツはこの<code>article</code>要素の中身であり、それが唯一であることを考えると<code>article</code>要素を使うのは冗長だ。<a href="http://www.w3.org/TR/html5/sections.html#the-article-element">仕様の<code>article</code>要素の項</a>でもこのことは触れられている。</p>

<p>かといってコード・レベルでの階層構造をフラットに変更するのはコスト(主にスタイリングにおいて)が高い。そこで論理構造を持ついくつかの要素を<code>div</code>要素に変更してやるのはどうだろうか。</p>

<ul>
<li><code>div[role=&quot;banner&quot;]</code></li>
<li><code>div</code><ul>
<li><code>div[role=&quot;main&quot;]</code></li>
</ul>
</li>
<li><code>footer</code></li>
</ul>

<p><code>article</code>要素というセクションを作る要素がなくなるため<code>header</code>要素も変更してやる必要がある。HTMLコードそのものとしてはほとんど変わりがなく、かつHTML5らしくなく見えるため、なんとなく美しくない気もするが、アウトライン構造はすっきりとする。</p>

<hr>

<p>こうしてやるとロゴで<code>h1</code>要素を使っていなくてもUntitled Sectionとみなされなくなるのもポイントが高い。むしろそのためにひねり出した感がある。悪い解ではないはずなので、しばらくはこれで行ってみよう。</p>]]></content:encoded>
    </item>

    <item>
      <title>JavaScriptをビルドするJavaScript</title>
      <link>http://hail2u.net/blog/coding/javascript-for-building-javascript.html</link>
      <description>たまには素でJavaScriptファイルをビルドすることも考えないと頭がダメになりそう。他にgulpとかでかすぎるし、npm run-scriptだけでいけるいけるみたいな話を先行者以外からも聞くようになったので、そっちに比重を移すことも視野に入れたいとか。僕はビルド・ツールをnpm run-scriptで薄くラップする手法というのが現実的だと考えてて、それを確認したいというのもあった。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/javascript-for-building-javascript.html</guid>
      <pubDate>Sat, 28 Feb 2015 12:52:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>たまには素でJavaScriptファイルをビルドすることも考えないと頭がダメになりそう。他にgulpとかでかすぎるし、<code>npm run-script</code><em>だけ</em>でいけるいけるみたいな話を先行者以外からも聞くようになったので、そっちに比重を移すことも視野に入れたいとか。僕は<a href="http://qiita.com/Jxck_/items/efaff21b977ddc782971">ビルド・ツールを<code>npm run-script</code>で薄くラップする手法</a>というのが現実的だと考えてて、それを確認したいというのもあった。</p>

<p>依存はnpmやBowerで解決している前提で、自前で書いたものを最小化し、依存と連結するようなものを想定しておく。つまり、</p>

<ul>
<li>node_modules/foo/dist/foo.min.js</li>
<li>src/js/bar.js</li>
<li>src/js/baz.js</li>
</ul>

<p>を<code>build/js/main.min.js</code>へとビルドするくらいにしておく。</p>

<pre><code>#!/usr/bin/env node

&#39;use strict&#39;;

var async = require(&#39;async&#39;);
var fs = require(&#39;fs-extra&#39;);
var path = require(&#39;path&#39;);
var uglifyjs = require(&#39;uglify-js&#39;);

async.waterfall([
  function (next) {
    fs.remove(&#39;tmp/&#39;, function (err) {
      next(err);
    });
  },

  function (next) {
    fs.remove(&#39;build/&#39;, function (err) {
      next(err);
    });
  },

  function (next) {
    fs.ensureDir(&#39;tmp/&#39;, function (err) {
      next(err);
    });
  },

  function (next) {
    fs.ensureDir(&#39;tmp/js/&#39;, function (err) {
      next(err);
    });
  },

  function (next) {
    fs.readFile(&#39;src/js/bar.js&#39;, &#39;utf8&#39;, function (err, data) {
      next(err, data);
    });
  },

  function (js, next) {
    fs.readFile(&#39;src/js/baz.js&#39;, &#39;utf8&#39;, function (err, data) {
      next(err, js + &#39;;&#39; + data);
    });
  },

  function (js, next) {
    try {
      next(null, uglifyjs.minify(js, {
        fromString: true
      }).code);
    } catch (err) {
      next(err);
    }
  },

  function (js, next) {
    fs.readFile(
      path.join(
        __dirname,
        &#39;node_modules&#39;,
        &#39;foo&#39;,
        &#39;dist&#39;,
        &#39;foo.min.js&#39;
      ),
      &#39;utf8&#39;,
      function (err, data) {
        next(err, data + &#39;;&#39; + js);
      }
    );
  },

  function (js, next) {
    fs.writeFile(&#39;tmp/js/main.min.js&#39;, js, function (err) {
      next(err);
    });
  },

  function (next) {
    fs.move(&#39;tmp/&#39;, &#39;build/&#39;, function (err) {
      next(err);
    });
  }
],

function (err) {
  if (err) {
    throw err;
  }
});
</code></pre>

<p>コード自体は簡単でわかりやすい。手軽なので<code>asyn.waterfall()</code>でフローを制御。Streamじゃないけど、中間ファイルを吐かないのでGruntよりは速い。テキトーに書かれたモジュールも<code>try...catch</code>しつつ流せるとか気軽に書ける。ファイルの保証やディレクトリの削除などは<code>fs-extra</code>パッケージに頼ればこんなもので済んだ。</p>

<p>……でも長い。これでも<code>fs-extra</code>パッケージのおかげで短くなってる。読み込みと連結をまとめたりとかでもっと短くできるけど、そこを抽象化するとストレートに書けるという長所が無くなっちゃう。<code>async</code>の代わりに<a href="https://github.com/petkaantonov/bluebird">Promisify</a>するともうちょっと楽だけど、それほど劇的でもない。</p>

<p>ビルド・ツールのキモはやはりグロブを使った抽象化を提供してくれるあたりにあり、そこを毎回自前でどうにかするのは面倒すぎる。Gruntやgulpのような巨大な依存を減らせることは確かだけど、その代わりに小さな依存が増えるので、あんまり変わらない。こういうのを書くためのパッケージをセットにしたメタ・パッケージみたいなのがあればまた少し話が変わる……かなー？</p>

<p>こういうのを抽象化して引数で入力と出力を指定して終わりというパッケージがあっても面白そうだけど、それだとGruntとあんまり変わらないっぽい。<code>Gruntfile.js</code>を書く代わりに<code>package.json</code>で複雑な引数を書くわけだし。</p>

<hr>

<p>つまり<code>make</code>はありだけど、<code>npm run-script</code>はなしかなーという感じになった。引数取れるようになったので<code>npm run-script</code>でいけるいけるとか言ってる人の話はじっくりと聞いて、本気でそれだけで済むと言っていたら聞き流した方が良さそう。</p>]]></content:encoded>
    </item>

    <item>
      <title>min-widthを含むクエリーをソート</title>
      <link>http://hail2u.net/blog/coding/pack-and-sort-min-width.html</link>
      <description>CSS MQPackerにmin-widthを使ったクエリーのみ(なんとなく)ソートしてやる機能を付けている。あまり付けるつもりはなかったけれど、ユーザー層が広がったっぽいこともあり、たまにメールで聞かれたりもしていたので、まぁやるかという感じになった。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/pack-and-sort-min-width.html</guid>
      <pubDate>Fri, 27 Feb 2015 05:40:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/hail2u/node-css-mqpacker">CSS MQPacker</a>に<code>min-width</code>を使ったクエリーのみ(なんとなく)ソートしてやる機能を付けている。あまり付けるつもりはなかったけれど、ユーザー層が広がったっぽいこともあり、たまにメールで聞かれたりもしていたので、まぁやるかという感じになった。</p>

<p>色々面倒なのがあるので、多くの人が必要なのは<code>min-width</code>だけだろうと決めつけて実装している。その上で以下の条件にマッチするクエリーを<em>後ろ</em>に回して、その中でソートするようにした。</p>

<ul>
<li><code>min-width</code>をどこかに含む</li>
<li>対応している単位である</li>
<li><code>calc()</code>は使っていない</li>
</ul>

<p>クエリーはまずカンマで分割されて、その中で更に空白文字で分割し、クエリーをなんとなく多次元配列へ変換する。ここで<code>min-width</code>が見つかったら後ろに回すようになっている。対応した単位は<code>px</code>を基準に<code>ch</code>、<code>em</code>、<code>ex</code>、<code>pc</code>、<code>pt</code>、そして<code>rem</code>までだ。どうやっても描画領域を基準にした<code>v*</code>単位には対応できない。<code>cm</code>や<code>in</code>は対応しても良いけれどさほど意味はなさそうだ。ソートは<code>px</code>単位に変換されて行われる。</p>

<pre><code>@media (min-width: 48px) {}
@media (min-width: 2em) {}
@media (min-width: 1rem) {}
</code></pre>

<p>このように単位系が混在している場合は以下のように良い感じ(私見)にソートされる。それぞれの単位系ごとにソートとしても良いのだけど、それはそれで面倒そうなので一気にソートしてしまうことにした。</p>

<pre><code>@media (min-width: 1rem) {}
@media (min-width: 2em) {}
@media (min-width: 48px) {}
</code></pre>

<p><code>1rem</code>は<code>16px</code>、<code>2em</code>は<code>32px</code>とみなされ<code>48px</code>より前に来るようになるわけだ。</p>

<p>式自体の書き換えはもちろん行わない。<code>calc()</code>にも対応したい気はすごくあるのだけど、フルスクラッチで書くのはなかなか厳しそうだ。<a href="https://www.npmjs.com/package/reduce-css-calc">reduce-css-calc</a>を使おうかなと考えている。</p>

<p>CSSの書き方自体は普通にメディア・クエリーを書いてくれればなんとかなるはずだ。気をつけるのはなるべく単位を揃えることくらいだろう。気取って<code>screen</code>とか書いていても、Retina対応の<code>resolution</code>が混ざっていたりとかも大丈夫だと思うのだけど、もっと色々テスト書かないと不安だ。</p>

<hr>

<p>メディア・クエリーは<em>後方互換性を維持して</em>今度更に強化されていく。実装の方も進みつつある上、<code>calc()</code>の存在や憎むべきCSS Variablesも控えているので、やはり一時的なソリューションにしかならないと思う。<code>min-width</code>だけにしたのもその辺りが理由だ。でもソリューションとして機能しなくなった頃にはHTTP/2やらWeb Componentsやらで大量の細かいCSSファイルを気軽に投げつけられる時代になっているはずなので、きっとメディア・クエリーをまとめなくても良くなっているのではないかとも思う。</p>

<p><code>not</code>キーワードの扱いをどうしようか悩んでいて、それが解決したらリリースするつもりだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>Semantic Versioningにおける破壊的な変更</title>
      <link>http://hail2u.net/blog/software/breaking-changes-on-semver.html</link>
      <description>io.jsがv1.3.0になり、ビルトインのURLモジュールでresolve(&#39;/foo/bar&#39;, &#39;.&#39;)が/foo/とスラッシュ付きで返されるようになった。今までは/fooとスラッシュなしで返っていたので、これは破壊的な変更であり、Semantic Versioningに従うならばメジャー・バージョンを上げるべきではないのかという議論がなされていたようだ。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/breaking-changes-on-semver.html</guid>
      <pubDate>Thu, 26 Feb 2015 06:49:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://iojs.org/">io.js</a>がv1.3.0になり、ビルトインのURLモジュールで<code>resolve(&#39;/foo/bar&#39;, &#39;.&#39;)</code>が<code>/foo/</code>とスラッシュ付きで返されるようになった。今までは<code>/foo</code>とスラッシュなしで返っていたので、これは破壊的な変更であり、Semantic Versioningに従うならばメジャー・バージョンを上げるべきではないのかという議論がなされていたようだ。</p>

<p>仮にこういった実装ミスの修正が破壊的な変更だとすると、ほとんどすべてのバグ・フィックスは破壊的な変更になってしまう。バグ・フィックスは必ずどこかで何か(モンキーパッチとか)を破壊するし、破壊しないことを保証することは不可能だ。Semverにおいては変更の仕分けはユーザーの利用ではなく、仕様という観点での話になる。つまり仕様に変更があったかどうかが焦点になる。</p>

<p>このURLモジュールのケースでは、仕様が外部(ドキュメントのブラウザーの実装のように～という一文)にあり、それに従った結果になっていなかったということになる。この間違った実装に依存したコードにおいては破壊的な変更となるが、それはそのコードが悪いだけで、メジャー・バージョンを上げる理由にはならない。</p>

<p>概ねこう解釈したが、ユーザーに優しくはない。特にこのモジュールのこの挙動は長らく放置されていたバグで、こういうものだと思って利用していた人も多かったはずだ。stableと明記されていたこともその判断を後押ししたことだろう。そこを考慮するとメジャー・バージョンを上げてやり、ユーザーに周知する必要があったんじゃないだろうか。</p>

<p>Semverのこのあたりの微妙な判断を求められる点が、v1.0.0をリリースする気配がないパッケージでnpmリポジトリーが溢れかえっている原因なのかなと感じる。メジャー・バージョンを上げることの抵抗感をなくすか、Semverを諦めるかの二択になりそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>VimでGitで衝突したところにジャンプ</title>
      <link>http://hail2u.net/blog/software/jump-git-conflict-in-vim.html</link>
      <description>Gitでマージやリベースで衝突が起きた場合、その解消のために該当ファイルを開き、移動する……前に自動的に&lt;&lt;&lt;&lt;&lt;&lt;&lt;にジャンプするだけみたいなのがちょっと欲しくなった。VimだとBufReadPostでsearch()を呼べば良さそうだ。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/jump-git-conflict-in-vim.html</guid>
      <pubDate>Wed, 25 Feb 2015 21:37:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Gitでマージやリベースで衝突が起きた場合、その解消のために該当ファイルを開き、移動する……前に自動的に<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>にジャンプするだけみたいなのがちょっと欲しくなった。Vimだと<code>BufReadPost</code>で<code>search()</code>を呼べば良さそうだ。</p>

<pre><code>augroup LtLtLtLtLtLtLt
  autocmd!

  &quot; Jump to first conflict position if find
  autocmd BufReadPost * call search(&#39;^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#39;, &#39;sw&#39;, 0, 1000)
augroup END
</code></pre>

<p>検索を一周させるようにフラグを立てておくついでに戻れるようにもフラグを立てたつもりだけど、発火するタイミング的に常に先頭で意味が無いような気がしないでもない。あと大きなファイルで死にそうなので1000ミリ秒に制限しておいたけど、もっと短くても良さそう。カーソル位置の復帰など、同じようにファイルを開いた時にカーソル位置を動かすプラグインと相性は悪いけど、なんとかなる。</p>

<p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>は大体は文法エラーなので、Syntasticを使っている人は、</p>

<ul>
<li>開いた時にチェック(<code>let g:syntastic_check_on_open = 1</code>)</li>
<li>最初のエラーにジャンプ(<code>let g:syntastic_auto_jump = 1</code>)</li>
<li>位置リストを自動的に開く(<code>let g:syntastic_auto_loc_list = 1</code>)</li>
</ul>

<p>の設定を有効にするとだいたい実現できそうな気がする。最初のエラーじゃなかった時の保険として、位置リストを自動的に開くようにしておくといける。</p>]]></content:encoded>
    </item>

    <item>
      <title>よろしくESLint</title>
      <link>http://hail2u.net/blog/coding/come-into-eslint.html</link>
      <description>重い腰を上げてESLintを使い始めた。そろそろv1.0.0になるらしい。これは良いなと思ったところを簡単にまとめておく。ついでに引っかかって対処にちょっと悩んだところも。既にすごく好感触なので、このまま素直に乗り換えられると良いな。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/come-into-eslint.html</guid>
      <pubDate>Tue, 24 Feb 2015 05:14:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>重い腰を上げて<a href="http://eslint.org/">ESLint</a>を使い始めた。そろそろv1.0.0になるらしい。これは良いなと思ったところを簡単にまとめておく。ついでに引っかかって対処にちょっと悩んだところも。既にすごく好感触なので、このまま素直に乗り換えられると良いな。</p>

<h2>package.jsonに設定が書ける</h2>

<p>外部設定ファイルとしては<code>.eslinrc</code>の他にも<code>package.json</code>に混ぜ込むこともできる。フィールド名は<code>eslintConfig</code>で、それ以下は同じ。</p>

<pre><code>{
  &quot;eslintConfig&quot;: {
    &quot;env&quot;: {
      &quot;node&quot;: true
    }
  }
}
</code></pre>

<p>通常のnpmパッケージでは別にした方が良さそうだが、依存解決にnpmを使うだけとかコマンド作るためだけのようなプライベートなケースでは特に気にせず混ぜてしまって良さそう。</p>

<h2>no-multi-spaces</h2>

<p>複数の連続した空白が検出できる。</p>

<pre><code>var a =  1;
</code></pre>

<p>これで警告出るのはかなり助かる。ソロエルノスキーさんには厳しそう。</p>

<h2>no-comma-dangle</h2>

<p><a href="http://jshint.com/">JSHint</a>では<code>es3</code>オプションを有効にしないと検出できない不必要なカンマを検出できる。とにかくあのカンマを消したい人なのですごくうれしい。</p>

<h2>curly</h2>

<p>中括弧なしの制御構文を検出できる。一行<code>if</code>とか書くなやみたいな感じで、僕はそっち派なのですごい助かる。</p>

<h2>出現順の検出</h2>

<p>先に<code>var</code>などで定義されているかや定義される前に関数が使われていないかなどを検出できる。他、定義済みで使われていないというケースも検出できる。メンテナンスのお供に。</p>

<hr>

<p>あまり気にしたことがなくて対処に困ったものも挙げておく。</p>

<h2>quotes</h2>

<p>JSHintで一重引用符を強制されて以降、そっちを使っていたが、ESlintではデフォルトは二重引用符になっていた。書き直すのがとても面倒な気がするので、<code>~/.eslintrc</code>で以下のようにして一重引用符をデフォルトにしてしまった。</p>

<pre><code>{
  &quot;rules&quot;: {
    &quot;quotes&quot;: [
      1,
      &quot;single&quot;
    ]
  }
}
</code></pre>

<h2>camelcase</h2>

<p>変数名などにアンダースコアを使えなくなり、キャメルケースで書くことを要求される。厳しいのはGruntの設定ファイルなどでアンダースコアがばんばん出てくるあたり。グローバルやファイルごとに無効にしたいところだけど、素直に引用符で括ってパスさせるのが良さそう。</p>

<h2>no-underscore-dangle</h2>

<p>アンダースコアで始まるまたは終わる変数やプロパティーへアクセスするだけで怒られる。ライブラリー側で使っていることもあるので、そういったファイルでのみ無効にするのが良さそう。</p>

<pre><code>var _ = require(&#39;underscore&#39;);
</code></pre>

<p>だけは特別視されてて、現実的。</p>

<h2>no-process-exit</h2>

<p>Node.js (つまり<code>&quot;node&quot;: true</code>)で<code>process.exit()</code>を使ってプログラムを終了しようとしていると怒られる。とりあえずは以下のようにして逃げるのも可能だが、完全に悪手っぽい。</p>

<pre><code>var exit = process.exit;

if (process.argv[3] === &#39;--version&#39;) {
  console.log(&#39;Foo v0.1.0&#39;);
  exit();
}
</code></pre>

<p>CLIプログラムのような完全に最上流であることを保証できるファイルのみで無効にするなら悪くはなさそう。だけど埋め込みコメントでの設定はなるべく避けた方が良いという経験則があるので、<code>switch</code>構文などをうまく使って書き直すのが良さそう。</p>

<p>他に<code>ecmaFeatures</code>フィールドで<code>globalReturn</code>を許可してやり、<code>process.exit()</code>の代わりに<code>return</code>を使うという手もなくはないみたいだけど、どうなんだろう。</p>

<hr>

<p>凶悪なルール(one-varとか)がデフォルトで無効なことが多いので、JSLintほどイラッとすることはない。しかしコード・スタイル的な面で様々なチェックが入るので、JSHintほどこれ拾えやみたいな辛さもない。肌にあっているのか快適に気持ちよく修正していけた。</p>

<p>無効になっているルールも機会があったら有効にしてみたいと感じるものが多い。例えば以下のルールは気になる。</p>

<ul>
<li>valid-jsdoc - JSDocのバリデーション</li>
<li>block-scoped-var - <code>var</code>をなんとなく<code>let</code>扱いするぞ</li>
<li>no-process-env - <code>process.env</code>いじっちゃダメ</li>
<li>no-warning-comments - コメントにTODOとか書くなや</li>
<li>vars-on-top - <code>var</code>はスコープの先頭にまとめてね</li>
<li>no-undefined - その<code>undefined</code>は<code>undefined</code>なの</li>
<li>no-sync - 同期とかウケる</li>
<li>brace-style - 中括弧の前後の改行スタイルは統一してくれ</li>
<li>sort-vars - 変数はソートするとわかりやすいぞ</li>
</ul>

<p>歴史的な事情により今すぐJSHintを投げ捨てるということは難しい。まずは手元でESLintを使ってJSHintよりのルール(一重引用符だとか半角空白二つによるインデントだとか)でチェックし、JSHintはタスク・ランナーなどからのみ実行するようにしておくようにするのが良さそう。そうしておけばうまく機会を捉えて切り替えを断行することができるはず。</p>]]></content:encoded>
    </item>

    <item>
      <title>Failswatch</title>
      <link>http://hail2u.net/blog/internet/failswatch.html</link>
      <description>ウェブサイトの死活監視をしつつ、もし落ちたら事前に保存しておいたキャッシュを自動的に返してくれる、Failswatchはそういう機能を提供する。CloudFlareや他のCDNにも同じ機能があるが、こちらはCDN的な機能はなく特化型で有料プランのみ。構成がシンプルな分、トラブルは少なそうだ。</description>
      <category>Internet</category>
      <guid isPermaLink="true">http://hail2u.net/blog/internet/failswatch.html</guid>
      <pubDate>Mon, 23 Feb 2015 06:54:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>ウェブサイトの死活監視をしつつ、もし落ちたら事前に保存しておいたキャッシュを自動的に返してくれる、<a href="https://failswitch.com/">Failswatch</a>はそういう機能を提供する。<a href="https://www.cloudflare.com/">CloudFlare</a>や他のCDNにも同じ機能があるが、こちらはCDN的な機能はなく特化型で有料プランのみ。構成がシンプルな分、トラブルは少なそうだ。</p>

<p>ウェブサイトの死活監視は必要なのだけど、中小規模のウェブサイトにおいてその対策までは練られない印象がある。実際に問題が起こるのはもっと上流であったりして、手が出せないからだ。せいぜい落ちた時にすばやくアナウンスをTwitterなどで出すくらいだろう。</p>

<p>このFailswatchのような、対策までをセットにしたソリューションというのは需要はかなりある。導入に成功すればほぼ全自動で対策が完了という点もスケールにマッチしている。しかし小規模なウェブサイトで継続的に使うには月15ドルはちょっと高いか。立ちあげ直後のトラフィックが読めない時期だけ保険として使うなどという一時的な利用に留めるのが良さそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>CSSできれいな斜め線</title>
      <link>http://hail2u.net/blog/webdesign/antialiased-diagonal-line-with-css.html</link>
      <description>CSSで斜めに線を引くようなことをするには多少なりとも工夫が必要だった。つまりCSSで作る吹き出し(もう5年前の記事だ)のようにborderプロパティーを使って頑張るしかなかったわけだ。今はlinear-gradient()があるので直感的に作ることができるようになった。しかしきれいに引くとなるとまだ工夫が必要そうだ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/antialiased-diagonal-line-with-css.html</guid>
      <pubDate>Sun, 22 Feb 2015 01:39:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="/images/blog/antialiased-diagonal-line-with-css.png"><img alt="斜め" height="627" src="/images/blog/antialiased-diagonal-line-with-css.png" width="1200"></a>
</figure>

<p>CSSで斜めに線を引くようなことをするには多少なりとも工夫が必要だった。つまり<a href="/blog/webdesign/pure-css-speech-bubble.html">CSSで作る吹き出し</a>(もう5年前の記事だ)のように<code>border</code>プロパティーを使って頑張るしかなかったわけだ。今は<code>linear-gradient()</code>があるので直感的に作ることができるようになった。しかしきれいに引くとなるとまだ工夫が必要そうだ。</p>

<p>View Demo: <a href="/pub/test/614.html">CSS Diagonal Line</a></p>

<p><code>border</code>プロパティーを使ったもの、<code>linear-gradient()</code>を背景で使ったもの、Data URI化したSVGを背景に使ったもの、以上の計3つのデモを作った。</p>

<pre><code>.lg {
  background-image: linear-gradient(
    <mark>to right bottom</mark>,
    transparent 50%,
    #f0f 50%
  );
  background-repeat: no-repeat;
  background-size: cover;
  height: 3rem;
  width: 16rem;
}
</code></pre>

<p>2番目の<code>linear-gradient()</code>を背景に使ったものが最も直感的に書けるが、Chrome 40ではぎざぎざになってしまう。Chromeはトップシェアで安定しだしたと考えられるので、今この方法で実装するのはかなり勇気がいる。</p>

<pre><code>.border {
  border-bottom: 3rem solid #f0f;
  border-left: 16rem solid <mark>transparent</mark>;
  box-sizing: border-box;
  height: 0;
  width: 16rem;
}
</code></pre>

<p>1番目の<code>border</code>プロパティーによる実装は安定の結果だ。以前はハードウェア・アクセラレーションを有効化するハックが必要だったが、今はいらない。とはいえ相変わらず意味のわからないCSSコードになる。加えて<code>border</code>プロパティーで<code>%</code>を使えないため、不明な幅の要素に対してはうまく作ることができない。</p>

<pre><code>.svg {
  background-image: url(&#39;data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%221%22%20height%3D%221%22%20preserveAspectRatio%3D%22none%22%3E%3Cpath%20d%3D%22M0%201l1-1v1z%22%20fill%3D%22%23f0f%22%2F%3E%3C%2Fsvg%3E&#39;);
  background-repeat: no-repeat;
  background-size: 100% 100%;
  height: 3rem;
  width: 16rem;
}
</code></pre>

<p>しょうがないのでSVGをData URI化して埋め込むという奥の手を使った。斜めの画像があるという前提だと、概ね直感的なCSSだとは言える。Data URIも長いが、それでも226バイト程度なので、多少複雑なCSSグラデーションだと思えば許容範囲だろう。見逃しがちなのは<code>background-size</code>プロパティーで明示的にいっぱいいっぱいにリサイズしてやることくらいだ。</p>

<pre><code>&lt;svg
  xmlns=&quot;http://www.w3.org/2000/svg&quot;
  width=&quot;1&quot;
  height=&quot;1&quot;
  preserveAspectRatio=&quot;none&quot;&gt;
  &lt;path
    d=&quot;M0 1l1-1v1z&quot;
    fill=&quot;#f0f&quot;/&gt;
&lt;/svg&gt;
</code></pre>

<p>SVGもこの程度の簡単なものだ。Chromeにかなり古くからある<a href="/pub/test/613.html">リサイズ・バグ</a>へ対応するために<code>preserveAspectRatio</code>属性を指定することに注意が必要なくらいだ(これで30分くらいハマった)。</p>

<hr>

<p>こういった斜めの線やブロックを作る場合にはCSS Transformを使って回転させる(<code>rotate()</code>する)というアプローチも可能だ。少し足りなかったりはみ出たりする部分は、<code>width</code>プロパティーで大きく作り、<code>overflow</code>プロパティーで隠せば良い。中身も回ってしまうのは、回転軸に注意して子の要素で逆方向に回転させれば戻せるだろう。CSSは煩雑だが傾けたいから傾けるわけで、概ね直感的とも言えそうだ。</p>

<p>ただ<a href="http://kyonagashima.com/">必要としたページ</a>では、斜めにしたいブロックの高さが一定ではないこと、斜めの角度ではなく高さを一定にしたかったことなどの条件があった。CSS Transformでも頑張って計算すれば可能そうだったが、面倒すぎるかと思い、背景画像によるアプローチに絞って考えていた。</p>

<hr>

<p>安定なのは<code>border</code>プロパティーで行う実装だが、不明な幅の要素で使いたい場合はSVGによる実装というのが現時点での妥当な選択だろう。Firefox 35で若干アンチエイリアスが甘いことも考慮すると、SVGで統一という選択も悪くはない。とにかくChromeでも早いところ<code>linear-gradient()</code>へきれいにアンチエイリアスかかるようになって欲しい。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
