<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Wed, 11 Mar 2015 00:11:50 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>Eau Douce</title>
      <link>http://hail2u.net/blog/webdesign/eau-douce.html</link>
      <description>Source Sans Proに飽きてきたので、あまり使われてなさそうな、はっきり言えばGoogle Fontsには置いていない、あまり主張のないサンセリフのタイプフェイスを物色していた。最終的に前にも使おうかなと考えたことのあるEau Douceにした。おーどぅーす。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/eau-douce.html</guid>
      <pubDate>Wed, 11 Mar 2015 00:11:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="/images/blog/eau-douce.png"><img alt="Eau Douce" height="627" src="/images/blog/eau-douce.png" width="1200"></a>
</figure>

<p>Source Sans Proに飽きてきたので、あまり使われてなさそうな、はっきり言えばGoogle Fontsには置いていない、あまり主張のないサンセリフのタイプフェイスを物色していた。最終的に前にも使おうかなと考えたことのある<a href="http://www.yoworks.com/eau_douce/">Eau Douce</a>にした。おーどぅーす。</p>

<p>字形については無個性という謳い文句の通り、主張は少なくどんな文章にも悪くなさそうな印象だ。ウェイトも6つあり、このタイプフェイスひとつで幅広い要望に答えることができそうだ。残念ながら斜体はないが、日本語のウェブサイトの欧文に使うことを前提にするのなら致命的な欠点ではない。</p>

<hr>

<pre><code>@font-face {
  font-family: &#39;Eau Douce&#39;;
  font-style: normal;
  font-weight: 400;
  src: local(&#39;Eau Douce&#39;),
    <mark>url(&#39;assets/fonts/eau-douce/r.woff2&#39;) format(&#39;woff2&#39;),</mark>
    url(&#39;assets/fonts/eau-douce/r.woff&#39;) format(&#39;woff&#39;);
}
</code></pre>

<p>フォントの読み込みは少し前に変えた通り、続けてCSSのみで行うことにした。OpenTypeフォーマットやSVGフォントのファイルを用意してまで幅広い環境サポートするのは馬鹿らしいと考えているが、WOFF2での配信は試してみたかったので、WOFFをメインに据えつつ、WOFF2を優先するようにもした。</p>

<table>
<thead>
<tr>
<th style="text-align:right">オリジナル</th>
<th style="text-align:right">WOFF</th>
<th style="text-align:right">WOFF2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">17.768 バイト</td>
<td style="text-align:right">23,824 バイト</td>
<td style="text-align:right">18,084 バイト</td>
</tr>
</tbody>
</table>

<p>WOFFに比べてWOFF2ではファイルサイズがちゃんと減っているものの、どちらもオリジナルよりも増えてしまった。<a href="http://www.freetype.org/ttfautohint/">ttfautohint</a>を通す以外には特に何も手を入れなかったので、多分そのせいだろう。もうちょっと色々調整してやらないとうまく小さくできなさそうだ。できれば15KB以下にはしたい。</p>

<hr>

<p>よく使われているタイプフェイスは時々嫌になってしまう。Source Sans Proはもちろん、Open SansやRoboto、そして商用のものでもProxima Novaなどは使われ過ぎててちょっと気になる。これらタイプフェイス自体が悪いわけでは決してない、むしろ優れているからこそ多くのウェブサイトで使われているわけだが、見慣れてしまうとそれほど良く見えてこなくなってしまう。</p>

<p>メジャーなだけあって、変なウェブサイトで使われているところを見てしまうこともそれなりにある。一度や二度なら「しょうがないか」と思えるが、四度も五度も見てしまうとやはり「うーん」となってしまう。</p>

<p>こういう感覚はまったく信用してはいけないのだが、どうしても自分だけで客観視して判断するのは難しい。しかし気になることをそのまま放置するのももやもやするだけなので、このウェブサイト程度の規模ならスパッと変えてしまっても良いだろう。継続のためには何よりもまず自分が快適と感じるウェブサイトである必要がある。</p>]]></content:encoded>
    </item>

    <item>
      <title>CSS MQPacker v3.1.0</title>
      <link>http://hail2u.net/blog/webdesign/node-css-mqpacker-v3.1.0.html</link>
      <description>min-widthを使ったクエリーのみをソートするオプションを追加し、CSS MQPacker v3.1.0をリリースした。sortオプションを有効にすると、まとめられたクエリーのうちmin-widthが使われるクエリーのみソートされる。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/node-css-mqpacker-v3.1.0.html</guid>
      <pubDate>Tue, 10 Mar 2015 00:29:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><code>min-width</code>を使ったクエリーのみをソートするオプションを追加し、<a href="https://github.com/hail2u/node-css-mqpacker">CSS MQPacker</a> v3.1.0をリリースした。<code>sort</code>オプションを有効にすると、まとめられたクエリーのうち<code>min-width</code>が使われるクエリーのみソートされる。</p>

<p>オプションの切り替えに対応するため、新たに引数を渡してインスタンスを作成できるようになった。今までの使われ方を壊さないように実装したので、今までのコードはそのまま動く。</p>

<pre><code>var mqpacker = require(&#39;css-mqpacker&#39;);

var result = mqpacker({
  sort: true
}).pack(css);
console.log(result.css);
</code></pre>

<p>ソート機能を有効にするには<code>sort</code>オプションを<code>true</code>にしてインスタンスを作成してやる。PostCSSのプロセッサー(プラグイン)として使う場合も同じだ。PostCSSのオプションに混ぜ込むことも可能だが、将来的な安全は保証されていないので推奨しない。なおデフォルトでは無効のため、明示的に有効にしてやる必要がある。</p>

<pre><code>@media (min-width: 2em) {}
@media print {}
@media (min-width: 48px) {}
@media (min-width: 16px) {}
.foo {}
@media (min-width: 48px) {}
@media (max-width: 8px) {}
@media (min-width: 2em) {}
@media (min-width: 16px) {}
</code></pre>

<p>例えばこのように<code>min-width</code>クエリーが散在し、それらが複数の単位を用いている上、他の種類のクエリーも混ざっているようなケースを処理してみよう。ありそうもないように思えるが、CSSプリプロセッサーで<code>@media</code>ルールをネストして書いていると似たような構成にはなりうるはずだ。</p>

<pre><code>.foo {}                     /* .foo {} */
@media (min-width: 16px) {} /* @media (min-width: 2em) {} */
@media (min-width: 2em) {}  /* @media print {} */
@media (min-width: 48px) {} /* @media (min-width: 48px) {} */
@media print {}             /* @media (min-width: 16px) {} */
@media (max-width: 8px) {}  /* @media (max-width: 8px) {} */
</code></pre>

<p><code>sort</code>オプションを有効にして処理すると、このように同じメディア・クエリーがまとめられ、後ろに回された上で、<code>min-width</code>クエリーのみがソートされる。わかりやすいように<code>sort</code>オプションを指定しない場合の順序もコメントで併記しておいた。</p>

<p><code>px</code>以外の単位はなんとなく<code>px</code>単位に変換(フォントの初期設定が16pxでArialとみなして変換を行う)されてソートされるので、複数の単位が混ざっていてもそれなりに機能する。<code>in</code>や<code>pt</code>など環境に強く依存する単位はサポートしていないので、無視されソートされることはない。<code>min-width</code>以外に<code>print</code>メディア・タイプなども含め特別視することはないので、それらは今まで通り出現順のまままとめられるというわけだ。</p>

<p>現状では<code>min-width</code>のみ、せいぜいそれに加えて<code>print</code>のみを使って書くのが主流と考えられるので、大抵は問題なく適切な状態に処理されることと思う。なにかおかしいところが見つけたら是非報告して欲しい</p>

<hr>

<p><code>sort</code>オプションには直接関数も指定することができる。こちらを使うと自由にソートすることができる。</p>

<pre><code>var result = mqpacker({
  sort: function (a, b) {
    return a.localeCompare(b);
  }
}).pack(css);
</code></pre>

<p>例えば<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare"><code>String#localeCompare</code></a>を使うと、雑に文字コード順でソートすることができる。</p>

<p>作成した関数は、<em>完全な</em>クエリーの配列に対する<code>Array#sort</code>へと渡される。例えばテストにある<a href="https://github.com/hail2u/node-css-mqpacker/blob/9c40f0a3bc613a86153a2ce719929c46cc4898ec/test/fixtures/sort_ignore-print-queries.css"><code>sort_ignore-print-queries.css</code></a>だと以下のような配列になる。</p>

<pre><code>[
  &quot;(min-width: 2em)&quot;,
  &quot;print and (min-width: 1em)&quot;,
  &quot;print, (min-width: 3em)&quot;,
  &quot;(min-width: 1em)&quot;
]
</code></pre>

<p>これをちゃんと処理しなければならないので、カンマ区切りの処理や<code>and</code>区切りの処理も自前で用意する必要がある。<code>min-width</code>だけでもかなり大変だったので、かなり苦労することと思う。そこそこちゃんとパースした結果を渡すというのも悪くはないと考えていたが、どちらかというとPostCSSというかAST側でやって欲しい機能なので、ツール側で持ってしまうのはやめておいた。</p>

<p>このソート関数の作成は汎用化しようとするとかなり大変な労力を必要とする。特化型で作るのなら簡単だが、その場合はCSS側でソート順を定義してやる方が更に手軽だったりもする。そのためまず出番はないことと思うがどうしても<code>max-width</code>で書きたいという場合などには役に立つかもしれない。</p>

<hr>

<p>ソートする機能の実装はとにかく面倒臭かった。<code>print and (min-width: 1px)</code>は無視して良さそうだが、<code>print, (min-width: 1px)</code>は無視するべきではなさそうだ、など、普段まともにCSSを書いている場合にはまったく考える必要のないエッジ・ケースで時間を浪費したので、ストレスが溜まった。既にいくつか見つけてしまったマイナーな解決できそうもない問題や<a href="http://www.w3.org/TR/mediaqueries-4/">Media Queries Level 4</a>の範囲指定クエリーのこととかで更に気が重い。それらが表面化する頃には、多数のファイルでメディア・クエリーを分散させつつ投げつけても怒られないHTTPS + HTTP/2時代になっていることに期待したい。</p>

<p>このウェブサイトでも同梱しているGruntプラグインのテストがてら稼働させ始めた。メディア・クエリーを抜き出すと以下のような順序で最後に追加されている。</p>

<pre><code>@media (min-width: 352px) {}
@media (min-width: 39.118rem) {}
@media (min-width: 53.487rem) {}
@media not screen {}
@media print {}
</code></pre>

<p>ちゃんと動いていそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>Istanbulとnodeunit</title>
      <link>http://hail2u.net/blog/software/istanbul-and-nodeunit.html</link>
      <description>Istanbulはよく使っていたのだけど、直接叩くことはなかった。初めてこれ単体でnodeunitと組み合わせて使おうかと、node_modules/.bin/nodeunitを引数に指定して実行してもうまく動かなかった。どうやらnodeunitパッケージ内のbin/nodeunitを指定しないとダメらしい。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/istanbul-and-nodeunit.html</guid>
      <pubDate>Mon, 09 Mar 2015 12:21:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/gotwarlost/istanbul">Istanbul</a>はよく使っていたのだけど、直接叩くことはなかった。初めてこれ単体で<a href="https://github.com/caolan/nodeunit">nodeunit</a>と組み合わせて使おうかと、<code>node_modules/.bin/nodeunit</code>を引数に指定して実行してもうまく動かなかった。どうやらnodeunitパッケージ内の<code>bin/nodeunit</code>を指定しないとダメらしい。</p>

<p>プロジェクト・ローカルにインストールしたnodeunitを使う場合、<code>node_modules/.bin/nodeunit</code>を叩いて実行する。</p>

<pre><samp>$ <kbd>./node_modules/.bin/nodeunit test</kbd>
</samp></pre>

<p>これをIstanbulでラップしてコード・カバレッジを調べたい場合、</p>

<pre><samp>$ <kbd>istanbul cover node_modules/nodeunit/bin/nodeunit -- test</kbd>
</samp></pre>

<p>というようにnpmが作成するラッパーではなく、nodeunitパッケージに含まれるスクリプトを直接叩くようにしてやらないと上手く動かないようだ。</p>

<hr>

<figure>
  <a href="/images/blog/istanbul-and-nodeunit.png"><img alt="Istanbulでnodeunitを使ってCSS MQPackerのコード・カバレッジを調査した結果" height="156" src="/images/blog/istanbul-and-nodeunit.png" width="672"></a>

  <figcaption>100% Code Coverage</figcaption>
</figure>

<p>ということでCSSWringとCSS MQPackerはめでたくカバレッジ100%に到達した。CSSWringでは再現できないバグのところを一つ無視させてるけど。</p>]]></content:encoded>
    </item>

    <item>
      <title>TL;DR (Too Light; Didn’t Read)</title>
      <link>http://hail2u.net/blog/webdesign/too-light-didnt-read.html</link>
      <description>コントラストの低さが読みやすさに及ぼす影響についてはそれなりに認知されてきたが、ウェブで使われ始めて間もない軽いウェイトのフォントが読みやすさに与える影響は軽視されている。このことには早いうちから警鐘は鳴らされているが、浸透しそうな気配はない。新しい10のサービスのうち、必ず1つか2つは読めたものじゃない軽いウェイトのフォントが本文でも使われていたりするような印象だ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/too-light-didnt-read.html</guid>
      <pubDate>Sun, 08 Mar 2015 12:08:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="/images/blog/too-light-didnt-read.png"><img alt="TL;DR" height="3840" src="/images/blog/too-light-didnt-read.png" width="2160"></a>
</figure>

<p>コントラストの低さが読みやすさに及ぼす影響についてはそれなりに認知されてきたが、ウェブで使われ始めて間もない軽いウェイトのフォントが読みやすさに与える影響は軽視されている。このことには早いうちから警鐘は鳴らされているが、浸透しそうな気配はない。新しい10のサービスのうち、必ず1つか2つは読めたものじゃない軽いウェイトのフォントが本文でも使われていたりするような印象だ。</p>

<p>とは言うものの慣れてないので自分でもよくやらかしてしまう。作ってから「あー読めない」とか。WCAGにコントラストのバリエーションとしてウェイトとサイズについてもあるともうちょっと意識できそうだ。追加して欲しいみたいなのどこに言えばいいんだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>chやexとpxの対応関係</title>
      <link>http://hail2u.net/blog/webdesign/converting-ch-and-ex-to-px.html</link>
      <description>1chと1pxがどちらが大きいかはすぐにわかることだが、1chと10pxとするとちゃんと答えられる人は少数派だろう。正解はフォントによって違う、だ。その要素で使われているフォントの特定のグリフの特定のパーツの正確なサイズを知らなければ、chやex単位をpx単位に変換することはできない。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/converting-ch-and-ex-to-px.html</guid>
      <pubDate>Sat, 07 Mar 2015 11:16:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><code>1ch</code>と<code>1px</code>がどちらが大きいかはすぐにわかることだが、<code>1ch</code>と<code>10px</code>とするとちゃんと答えられる人は少数派だろう。正解はフォントによって違う、だ。その要素で使われているフォントの特定のグリフの特定のパーツの正確なサイズを知らなければ、<code>ch</code>や<code>ex</code>単位を<code>px</code>単位に変換することはできない。</p>

<p>例えば標準的なArial (のRegular)と特徴的なImpactでどのように変わってくるのかを表にまとめてみよう。基本のフォント・サイズは<code>16px</code>になっているとする。Chrome 41での結果であることも明記しておく。</p>

<table>
<thead>
<tr>
<th>フォント</th>
<th style="text-align:right"><code>100em</code></th>
<th style="text-align:right"><code>100ch</code></th>
<th style="text-align:right"><code>100ex</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Arial</td>
<td style="text-align:right"><code>1600.000px</code></td>
<td style="text-align:right"><code>889.844px</code></td>
<td style="text-align:right"><code>829.688px</code></td>
</tr>
<tr>
<td>Impact</td>
<td style="text-align:right"><code>1600.000px</code></td>
<td style="text-align:right"><code>857.813px</code></td>
<td style="text-align:right"><code>1036.719px</code></td>
</tr>
</tbody>
</table>

<p><code>1em</code>が必ず<code>16px</code>になることに対して、<code>ch</code>と<code>ex</code>単位ではフォントによって変化している。それぞれのフォントのグリフの特定のパーツ、<code>ch</code>単位では<code>0</code>の幅、<code>ex</code>単位では<code>x</code>の高さ(とされるx-height)、が考慮された上で<code>px</code>単位に変換され、計算済みスタイルの値となっていることがわかる。Impactのようなx-heightがかなり高く設定されているフォントでは<code>ex</code>単位で大きく差が出てくるというわけだ。</p>

<p>このことは普通にCSSのプロパティーの値として使う場合はあまり問題になることはない。しかしながらブラウザー以外の何らかのツールで扱おうとすると一定の決めつけが必要となる。そうでないとフォントを調べて係数をひねり出さなければならなくなるからだ。</p>

<p>少なくともメディア・クエリーにおいては初期設定の値を基準として変換されることになるので、Arial (やHelvetica Neue)を基準にした係数を使って変換するのが妥当だろう。Chrome 41でArialを使って調べた<code>px</code>単位に変換するための係数は以下の通りだ。</p>

<table>
<thead>
<tr>
<th style="text-align:right">単位</th>
<th style="text-align:right">to <code>px</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"><code>1ch</code></td>
<td style="text-align:right"><code>8.8984375</code></td>
</tr>
<tr>
<td style="text-align:right"><code>1ex</code></td>
<td style="text-align:right"><code>8.296875</code></td>
</tr>
</tbody>
</table>

<p>これらの係数を使って<code>px</code>単位に変換することで、<code>(min-width: 2ch)</code>というクエリーは<code>(min-width: 1em)</code>というクエリーよりも後に書いた方が良さそうだということがわかる。</p>

<hr>

<p>実際にはメディア・クエリーで使う長さの単位は余程の事情がない限り統一すべきだろう。そして、その統一した単位とは別の単位が使われている可能性があるサードパーティ製のライブラリーは何らかのツールで機械的に処理すべきではない。そのためこういった変換のことを考える必要はまずない。</p>

<p>それでもどうにかして処理してやりたいという場合には、このようにArialやHelvetica Neueを想定して変換してやるしかなさそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>Rhodia dotPad</title>
      <link>http://hail2u.net/blog/gadget/rhodia-dotpad.html</link>
      <description>ドット方眼に目覚めてから愛用しはじめたRHODIAのdotPadの二代目をおろした。僕が使っているのは最小サイズのNo.12で270円。もちろんオレンジ。</description>
      <category>Gadget</category>
      <guid isPermaLink="true">http://hail2u.net/blog/gadget/rhodia-dotpad.html</guid>
      <pubDate>Fri, 06 Mar 2015 09:23:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure>
  <a href="http://www.amazon.co.jp/gp/product/B00JO1JCKK/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00JO1JCKK&amp;linkCode=as2&amp;tag=hail2unet-22"><img alt="ロディア ドットパッド No.12 オレンジ 2冊セット" height="228" src="/images/blog/rhodia-dotpad.jpg" width="2216"></a>
</figure>

<p><a href="/blog/software/dot-grid-and-line-grid.html">ドット方眼</a>に目覚めてから愛用しはじめた<a href="http://www.amazon.co.jp/gp/product/B00JO1JCKK/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00JO1JCKK&amp;linkCode=as2&amp;tag=hail2unet-22">RHODIAのdotPad</a>の二代目をおろした。僕が使っているのは最小サイズのNo.12で270円。もちろんオレンジ。</p>

<p>書き味はRhodiaらしいやつで、ボールペンや鉛筆に向いてる。万年筆(Lamy)とはちょっと相性悪いような気がする。切りはなしやすさもRhodiaと同じ。ただゆがみはないものの、線方眼のものよりも方眼の位置に個体差があるような気がする。気になる場合は文具店で実物確認して買うのが良さそう。</p>

<p>表紙は耐水性がちょっとある。そのための加工のお陰で手触りもスベスベで、長期間使ってもあまり劣化してこない。。裏表紙も同じ。裏表紙の内側には厚めのボール紙が台紙として更にあって、手で持ってる時も安定して書けるという謳い文句通り、しっかりしてる。</p>

<p>ホッチキス留めだけど裏にホッチキス針の先が出てこないとかそういうあたりもちゃんとRhodiaクオリティー。かなり丈夫な方だとは思うけど、やはり端はヘナヘナになってしまう。カバーが欲しい気もするけど、うーん。</p>]]></content:encoded>
    </item>

    <item>
      <title>モバイル版とデスクトップ版、そしてレスポンシブ・ウェブ・デザイン</title>
      <link>http://hail2u.net/blog/webdesign/mobile-version-desktop-version-and-responsive-web-design.html</link>
      <description>専用バージョンのウェブサイトとレスポンシブ・ウェブ・デザインによるウェブサイトの優劣が語られることは多い。そういった場合、どちらが優れているのか、またはどちらが劣っているのか、を思想的な面でも技術的な面でも比較される。その過程で両者があたかも排他的な関係であるようによく語られるが、両者が解決するもの、したいものは違う。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/mobile-version-desktop-version-and-responsive-web-design.html</guid>
      <pubDate>Thu, 05 Mar 2015 09:05:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>専用バージョンのウェブサイトとレスポンシブ・ウェブ・デザインによるウェブサイトの優劣が語られることは多い。そういった場合、どちらが優れているのか、またはどちらが劣っているのか、を思想的な面でも技術的な面でも比較される。その過程で両者があたかも排他的な関係であるようによく語られるが、両者が解決するもの、したいものは違う。</p>

<p>単一のHTMLやCSSで完結することや、それに伴うテストの簡略化や不可欠なツールの削減あたりが、レスポンシブ・ウェブ・デザインがもたらす主なものだろう。もしかするとバックエンドとのやりとりもシンプルにできるかもしれない。つまりコードやビジュアル・デザインのレベルではなく、ウェブサイトの構築というレベルにおいてシンプルにしてくれるということだ。</p>

<p>レスポンシブ・ウェブ・デザインは主にこういった<em>コンテンツとウェブページの間</em>における問題を解決するために採用するものだ。</p>

<p>その一方でウェブページとユーザーの間にある問題を解決することはレスポンシブ・ウェブ・デザインではできない。あるユーザーが複数の端末で閲覧した場合に、一貫性ある体験を提供できることに留まるだろう。無意味ではないが、それだけでは不十分だ。このようなウェブページとユーザーの間にある問題は、ビジュアル・デザインよりももう少し上流にあるデザインにおいて解決されるものだ。</p>

<p>専用バージョンのウェブサイトは、まさにこのあたりを解決するために設計し、作るものだ。場合によってはウェブサイトではなくモバイル・アプリになるかもしれない。</p>

<hr>

<p>少なくとも<em>複数の</em>専用バージョンのウェブサイトを運用する意味はもはやなく、運用や保守におけるコストという点でも魅力的ではないだろう。であるならレスポンシブ・ウェブ・デザインを採用することで、メイン・ターゲット層以外を漸進的にサポートすることは理に適っているはずだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>単一のvar宣言とセミコロンの自動補完</title>
      <link>http://hail2u.net/blog/coding/single-var-pattern-and-automatic-semicolon-insertion.html</link>
      <description>ESLintできれいに拾えるので、スコープ内でvarの先頭出しをやるようにしようかなという気分になっている。その過程でA criticism of the Single Var Pattern in JavaScript, and a simple alternativeという記事を読んだ。デバッガーでステップ実行しづらいという話はともかく、カンマ忘れでセミコロンの自動補完が起こり、変数のグローバル化をもたらしてしまうというのは印象的だった。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/single-var-pattern-and-automatic-semicolon-insertion.html</guid>
      <pubDate>Wed, 04 Mar 2015 07:18:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>ESLintできれいに拾えるので、スコープ内で<code>var</code>の先頭出しをやるようにしようかなという気分になっている。その過程で<a href="http://danhough.com/blog/single-var-pattern-rant/">A criticism of the Single Var Pattern in JavaScript, and a simple alternative</a>という記事を読んだ。デバッガーでステップ実行しづらいという話はともかく、カンマ忘れでセミコロンの自動補完が起こり、変数のグローバル化をもたらしてしまうというのは印象的だった。</p>

<pre><code>var foo = &#39;Foooo&#39;
  bar = &#39;Barrr&#39;,
  baz = &#39;Bazzz&#39;;
</code></pre>

<p>このように一行目のカンマを忘れてしまうと、意図せず<code>bar</code>と<code>baz</code>がグローバル変数になってしまう。この手のエラーもリンターで拾えるとはいえ、見逃してしまった時のことを考えると、こうは書きたくなくなる。</p>

<hr>

<p>最終行がコメントアウトしづらいというような瑣末な問題があることはなんとなく知ってはいたが、ちょっとしたミスが大きなバグへつながるということは知らなかった。<code>var</code>の先頭出しは単一の<code>var</code>宣言で行うものかと思っていたけれど、このあたりにも色々微妙な点があるようだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>media_query_listのパース</title>
      <link>http://hail2u.net/blog/coding/parsing-media-query-list.html</link>
      <description>Media Queriesの各クエリーは、featureとexpのセットもしくはmedia_typeでexpressionが、expressionをandで繋いでmedia_queryが、media_queryをカンマで繋いでmedia_query_listになり、それで完成する。そこそこ正確にパースしてJavaScriptから扱えるようにするためには、まずカンマで区切り、更にandキーワードまたはスペースで区切り、更に同じfeatureがあることを考慮した多次元配列に変換してやる必要がありそうだ。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/parsing-media-query-list.html</guid>
      <pubDate>Tue, 03 Mar 2015 07:34:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>Media Queriesの各クエリーは、<code>feature</code>と<code>exp</code>のセットもしくは<code>media_type</code>で<code>expression</code>が、<code>expression</code>を<code>and</code>で繋いで<code>media_query</code>が、<code>media_query</code>をカンマで繋いで<code>media_query_list</code>になり、それで完成する。そこそこ正確にパースしてJavaScriptから扱えるようにするためには、まずカンマで区切り、更に<code>and</code>キーワードまたはスペースで区切り、更に同じ<code>feature</code>があることを考慮した多次元配列に変換してやる必要がありそうだ。</p>

<p>まず存在しなさそうだが、以下のようなクエリーも理論上はありうる。</p>

<pre>only
  screen and
  (min-width: 1em) and
  (min-width: 2em),
not
  (min-width: 3em) and
  (min-height: 4em) and
  (min-height: 5em)
</pre>

<p>例えばこのようなクエリーを以下のようにできれば良さそうだ。</p>

<pre><code>var mediaQueryList = [
  {
    &#39;min-width&#39;: [&#39;1em&#39;, &#39;2em&#39;],
    &#39;only&#39;: true,
    &#39;screen&#39;: true
  },
  {
    &#39;min-height&#39;: [&#39;4em&#39;, 5em&#39;],
    &#39;min-width&#39;: [&#39;3em&#39;],
    &#39;not&#39;: true
  }
];
</code></pre>

<p>こうするための実装を書いているけどすごい面倒くさくて嫌になってきている。<code>min-width</code>が複数回出てきても良いとか想定していなかった。</p>

<hr>

<p>パースは出来たとしてもどう扱ってソートするかでまた面倒くさい。<code>min-width</code>に絞っていても<code>media_query</code>の中で<em>最大</em>かつその中で<em>最小</em>を基準にソートする必要がありそうだ。他に<code>print, (min-width: 1em)</code>みたいなものの判断も難しい。もうちょっと時間かかりそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>node-feedmix</title>
      <link>http://hail2u.net/blog/coding/node-feedmix.html</link>
      <description>xml2jsを使って複数のRSS 2.0をマージするパッケージ、FeedMixを作った。手元で結構前から使っていたGruntタスクをNode.jsパッケージにして、それを叩くだけのGruntタスクを同梱するという形にした。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/node-feedmix.html</guid>
      <pubDate>Mon, 02 Mar 2015 06:26:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://github.com/Leonidas-from-XIV/node-xml2js">xml2js</a>を使って複数のRSS 2.0をマージするパッケージ、<a href="https://github.com/hail2u/node-feedmix">FeedMix</a>を作った。手元で結構前から使っていたGruntタスクをNode.jsパッケージにして、それを叩くだけのGruntタスクを同梱するという形にした。</p>

<p>混ぜたいRSSファイルを配列として<code>merge()</code>の引数に指定する。XMLファイルではない場合はxml2jsが、RSSファイルではなさそうな場合はFeedMixがそれぞれ例外を吐いて落ちる。落ちる。</p>

<pre><code>var feedmix = require(&#39;feedmix&#39;);
var fs = require(&#39;fs&#39;);

var a = f.readFileSync(&#39;a.rss&#39;, &#39;utf8&#39;);
var b = f.readFileSync(&#39;b.rss&#39;, &#39;utf8&#39;);
var c = f.readFileSync(&#39;c.rss&#39;, &#39;utf8&#39;);
var m = feedmix.merge([a, b, c], {
  trim: true
});
</code></pre>

<p>これで<code>m</code>の中身が<code>b.rss</code>と<code>c.rss</code>のすべての<code>item</code>要素を<code>a.rss</code>へ混ぜ込んだJavaScriptオブジェクトになる。<code>item</code>は<code>pubDate</code>要素の値を使ってソートされるが、切り詰められたりはしない。<code>channel</code>要素は<code>a.rss</code>のものが採用されるが、<code>lastBuildDate</code>要素の値のみ最初の<code>item</code>要素の<code>pubDate</code>要素の値がコピーされ書き換えられる。</p>

<pre><code>console.log(feedmix.stringify(m, {
  cdata: true,
  xmldec: {
    encoding: &#39;UTF-8&#39;,
    version: &#39;1.0&#39;
  }
}));
</code></pre>

<p>XMLへの変換は<code>stringify()</code>へパース結果のオブジェクトを渡して行う。xml2jsのビルダーの単なるラッパーで、特に何もしない。</p>

<p>また<code>merge()</code>では第二引数にxmljsのパーサーのオプションが、<code>strigify()</code>ではxml2jsのビルダーのオプションがそれぞれ指定できる。ただしパーサーの<code>explicitArray</code>オプションはパース後のオブジェクトの構造を変えてしまうので、強制的に<code>true</code>にしているため指定しても効果はない。他にも指定するとおかしくなるオプションがあるかもしれない。</p>

<hr>

<p>同梱されているGruntタスクも凝ってはいない。</p>

<pre><code>feedmix: {
  main: {
    options: {
      builder: {
        cdata: true,
        xmldec: {
          encoding: &#39;UTF-8&#39;,
          version: &#39;1.0&#39;
        }
      },

      parser: {
        trim: true
      }
    },

    dest: &#39;build/feed&#39;,
    src: [
      &#39;src/feed/index.rss&#39;,
      &#39;build/blog/feed&#39;
    ]
  }
}
</code></pre>

<p>こちらは<code>src</code>でファイルを指定してやると<code>dest</code>にマージした結果を吐いてくれる。動的マッピングだと配列の順序が思ったようにいかない可能性があるので、普通に指定したほうが良いだろう。<code>options.builder</code>と<code>options.parser</code>経由で<code>stringify()</code>と<code>merge()</code>に渡すオプションを指定することはできるので、入出力もモジュールと同等に制御することができる。</p>

<hr>

<p>RSS 1.0とかAtomとかもうよく知らないので無視した。RSS 0.9xなどは通ってしまいそうな気がする。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
